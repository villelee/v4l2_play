<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=GB2312"><title>Video for Linux Two API Specification</title><meta name="GENERATOR" content="Modular DocBook HTML Stylesheet Version 1.79"></head><body class="BOOK" alink="#0000FF" bgcolor="#FFFFFF" link="#0000FF" text="#000000" vlink="#840084"><div class="BOOK"><a name="V4L2SPEC"></a><div class="TITLEPAGE"><h1 class="TITLE"><a name="AEN2">Video for Linux Two API Specification</a></h1><h2 class="SUBTITLE">Revision 0.24</h2><h3 class="AUTHOR"><a name="AEN6"></a>Michael H Schimek</h3><div class="AFFILIATION"><div class="ADDRESS"><p class="ADDRESS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="EMAIL">&lt;<a href="mailto:mschimek@gmx.at">mschimek@gmx.at</a>&gt;</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p></div></div><h3 class="AUTHOR"><a name="AEN13"></a>Bill Dirks</h3><h3 class="AUTHOR"><a name="AEN17"></a>Hans Verkuil</h3><h3 class="AUTHOR"><a name="AEN21"></a>Martin Rubli</h3><p class="COPYRIGHT">Copyright &#169; 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 Bill Dirks, Michael H. Schimek, Hans Verkuil, Martin
Rubli</p><div class="LEGALNOTICE"><p></p><a name="AEN37"></a><p>This document is copyrighted &#169; 1999-2008 by Bill
Dirks, Michael H. Schimek, Hans Verkuil and Martin Rubli.</p><p>Permission is granted to copy, distribute and/or modify
this document under the terms of the GNU Free Documentation License,
Version 1.1 or any later version published by the Free Software
Foundation; with no Invariant Sections, with no Front-Cover Texts, and
with no Back-Cover Texts. A copy of the license is included in the
appendix entitled "GNU Free Documentation License".</p><p>Programming examples can be used and distributed without
restrictions.</p><p></p></div><hr></div><div class="TOC"><dl><dt><b>Table of Contents</b></dt><dt><a href="#AEN163">Introduction</a></dt><dt>1. <a href="#COMMON">Common API Elements</a></dt><dd><dl><dt>1.1. <a href="#OPEN">Opening and Closing Devices</a></dt><dd><dl><dt>1.1.1. <a href="#AEN194">Device Naming</a></dt><dt>1.1.2. <a href="#RELATED">Related Devices</a></dt><dt>1.1.3. <a href="#AEN249">Multiple Opens</a></dt><dt>1.1.4. <a href="#AEN270">Shared Data Streams</a></dt><dt>1.1.5. <a href="#AEN273">Functions</a></dt></dl></dd><dt>1.2. <a href="#QUERYCAP">Querying Capabilities</a></dt><dt>1.3. <a href="#APP-PRI">Application Priority</a></dt><dt>1.4. <a href="#VIDEO">Video Inputs and Outputs</a></dt><dt>1.5. <a href="#AUDIO">Audio Inputs and Outputs</a></dt><dt>1.6. <a href="#TUNER">Tuners and Modulators</a></dt><dd><dl><dt>1.6.1. <a href="#AEN396">Tuners</a></dt><dt>1.6.2. <a href="#AEN418">Modulators</a></dt><dt>1.6.3. <a href="#AEN437">Radio Frequency</a></dt><dt>1.6.4. <a href="#AEN445">Satellite Receivers</a></dt></dl></dd><dt>1.7. <a href="#STANDARD">Video Standards</a></dt><dt>1.8. <a href="#CONTROL">User Controls</a></dt><dt>1.9. <a href="#EXTENDED-CONTROLS">Extended Controls</a></dt><dd><dl><dt>1.9.1. <a href="#AEN804">Introduction</a></dt><dt>1.9.2. <a href="#AEN809">The Extended Control API</a></dt><dt>1.9.3. <a href="#AEN840">Enumerating Extended Controls</a></dt><dt>1.9.4. <a href="#AEN867">Creating Control Panels</a></dt><dt>1.9.5. <a href="#MPEG-CONTROLS">MPEG Control Reference</a></dt><dt>1.9.6. <a href="#CAMERA-CONTROLS">Camera Control Reference</a></dt></dl></dd><dt>1.10. <a href="#FORMAT">Data Formats</a></dt><dd><dl><dt>1.10.1. <a href="#AEN1861">Data Format Negotiation</a></dt><dt>1.10.2. <a href="#AEN1894">Image Format Enumeration</a></dt></dl></dd><dt>1.11. <a href="#CROP">Image Cropping, Insertion and Scaling</a></dt><dd><dl><dt>1.11.1. <a href="#AEN1926">Cropping Structures</a></dt><dt>1.11.2. <a href="#AEN1954">Scaling Adjustments</a></dt><dt>1.11.3. <a href="#AEN1969">Examples</a></dt></dl></dd><dt>1.12. <a href="#STREAMING-PAR">Streaming Parameters</a></dt></dl></dd><dt>2. <a href="#PIXFMT">Image Formats</a></dt><dd><dl><dt>2.1. <a href="#AEN2113">Standard Image Formats</a></dt><dt>2.2. <a href="#COLORSPACES">Colorspaces</a></dt><dt>2.3. <a href="#PIXFMT-INDEXED">Indexed Format</a></dt><dt>2.4. <a href="#PIXFMT-RGB">RGB Formats</a></dt><dd><dl><dt><a href="#PACKED-RGB">Packed RGB formats</a>&nbsp;--&nbsp;Packed RGB formats</dt><dt><a href="#V4L2-PIX-FMT-SBGGR8">V4L2_PIX_FMT_SBGGR8 ('BA81')</a>&nbsp;--&nbsp;Bayer RGB format</dt><dt><a href="#V4L2-PIX-FMT-SBGGR16">V4L2_PIX_FMT_SBGGR16 ('BA82')</a>&nbsp;--&nbsp;Bayer RGB format</dt></dl></dd><dt>2.5. <a href="#YUV-FORMATS">YUV Formats</a></dt><dd><dl><dt><a href="#PACKED-YUV">Packed YUV formats</a>&nbsp;--&nbsp;Packed YUV formats</dt><dt><a href="#V4L2-PIX-FMT-GREY">V4L2_PIX_FMT_GREY ('GREY')</a>&nbsp;--&nbsp;Grey-scale image</dt><dt><a href="#V4L2-PIX-FMT-Y16">V4L2_PIX_FMT_Y16 ('Y16 ')</a>&nbsp;--&nbsp;Grey-scale image</dt><dt><a href="#V4L2-PIX-FMT-YUYV">V4L2_PIX_FMT_YUYV ('YUYV')</a>&nbsp;--&nbsp;Packed format with &#189; horizontal chroma
resolution, also known as YUV 4:2:2</dt><dt><a href="#V4L2-PIX-FMT-UYVY">V4L2_PIX_FMT_UYVY ('UYVY')</a>&nbsp;--&nbsp;Variation of
<code class="CONSTANT">V4L2_PIX_FMT_YUYV</code> with different order of samples
in memory</dt><dt><a href="#V4L2-PIX-FMT-Y41P">V4L2_PIX_FMT_Y41P ('Y41P')</a>&nbsp;--&nbsp;Format with &#188; horizontal chroma
resolution, also known as YUV 4:1:1</dt><dt><a href="#AEN4850">V4L2_PIX_FMT_YVU420 ('YV12'), V4L2_PIX_FMT_YUV420 ('YU12')</a>&nbsp;--&nbsp;Planar formats with &#189; horizontal and
vertical chroma resolution, also known as YUV 4:2:0</dt><dt><a href="#AEN5016">V4L2_PIX_FMT_YVU410 ('YVU9'), V4L2_PIX_FMT_YUV410 ('YUV9')</a>&nbsp;--&nbsp;Planar formats with &#188; horizontal and
vertical chroma resolution, also known as YUV 4:1:0</dt><dt><a href="#V4L2-PIX-FMT-YUV422P">V4L2_PIX_FMT_YUV422P ('422P')</a>&nbsp;--&nbsp;Format with &#189; horizontal chroma resolution,
also known as YUV 4:2:2. Planar layout as opposed to
<code class="CONSTANT">V4L2_PIX_FMT_YUYV</code></dt><dt><a href="#V4L2-PIX-FMT-YUV411P">V4L2_PIX_FMT_YUV411P ('411P')</a>&nbsp;--&nbsp;Format with &#188; horizontal chroma resolution,
also known as YUV 4:1:1. Planar layout as opposed to
<code class="CONSTANT">V4L2_PIX_FMT_Y41P</code></dt><dt><a href="#AEN5470">V4L2_PIX_FMT_NV12 ('NV12'), V4L2_PIX_FMT_NV21 ('NV21')</a>&nbsp;--&nbsp;Formats with &#189; horizontal and vertical
chroma resolution, also known as YUV 4:2:0. One luminance and one
chrominance plane with alternating chroma samples as opposed to
<code class="CONSTANT">V4L2_PIX_FMT_YVU420</code></dt></dl></dd><dt>2.6. <a href="#AEN5634">Compressed Formats</a></dt><dt>2.7. <a href="#PIXFMT-RESERVED">Reserved Format Identifiers</a></dt></dl></dd><dt>3. <a href="#IO">Input/Output</a></dt><dd><dl><dt>3.1. <a href="#RW">Read/Write</a></dt><dt>3.2. <a href="#MMAP">Streaming I/O (Memory Mapping)</a></dt><dt>3.3. <a href="#USERP">Streaming I/O (User Pointers)</a></dt><dt>3.4. <a href="#ASYNC">Asynchronous I/O</a></dt><dt>3.5. <a href="#BUFFER">Buffers</a></dt><dd><dl><dt>3.5.1. <a href="#AEN6266">Timecodes</a></dt></dl></dd><dt>3.6. <a href="#FIELD-ORDER">Field Order</a></dt></dl></dd><dt>4. <a href="#DEVICES">Interfaces</a></dt><dd><dl><dt>4.1. <a href="#CAPTURE">Video Capture Interface</a></dt><dd><dl><dt>4.1.1. <a href="#AEN6498">Querying Capabilities</a></dt><dt>4.1.2. <a href="#AEN6510">Supplemental Functions</a></dt><dt>4.1.3. <a href="#AEN6520">Image Format Negotiation</a></dt><dt>4.1.4. <a href="#AEN6563">Reading Images</a></dt></dl></dd><dt>4.2. <a href="#OVERLAY">Video Overlay Interface</a></dt><dd><dl><dt>4.2.1. <a href="#AEN6587">Querying Capabilities</a></dt><dt>4.2.2. <a href="#AEN6595">Supplemental Functions</a></dt><dt>4.2.3. <a href="#AEN6605">Setup</a></dt><dt>4.2.4. <a href="#AEN6635">Overlay Window</a></dt><dt>4.2.5. <a href="#AEN6826">Enabling Overlay</a></dt></dl></dd><dt>4.3. <a href="#OUTPUT">Video Output Interface</a></dt><dd><dl><dt>4.3.1. <a href="#AEN6839">Querying Capabilities</a></dt><dt>4.3.2. <a href="#AEN6849">Supplemental Functions</a></dt><dt>4.3.3. <a href="#AEN6859">Image Format Negotiation</a></dt><dt>4.3.4. <a href="#AEN6902">Writing Images</a></dt></dl></dd><dt>4.4. <a href="#OSD">Video Output Overlay Interface</a></dt><dd><dl><dt>4.4.1. <a href="#AEN6923">Querying Capabilities</a></dt><dt>4.4.2. <a href="#AEN6932">Framebuffer</a></dt><dt>4.4.3. <a href="#AEN6953">Overlay Window and Scaling</a></dt><dt>4.4.4. <a href="#AEN6987">Enabling Overlay</a></dt></dl></dd><dt>4.5. <a href="#CODEC">Codec Interface</a></dt><dt>4.6. <a href="#EFFECT">Effect Devices Interface</a></dt><dt>4.7. <a href="#RAW-VBI">Raw VBI Data Interface</a></dt><dd><dl><dt>4.7.1. <a href="#AEN7029">Querying Capabilities</a></dt><dt>4.7.2. <a href="#AEN7038">Supplemental Functions</a></dt><dt>4.7.3. <a href="#AEN7045">Raw VBI Format Negotiation</a></dt><dt>4.7.4. <a href="#AEN7218">Reading and writing VBI images</a></dt></dl></dd><dt>4.8. <a href="#SLICED">Sliced VBI Data Interface</a></dt><dd><dl><dt>4.8.1. <a href="#AEN7248">Querying Capabilities</a></dt><dt>4.8.2. <a href="#AEN7258">Supplemental Functions</a></dt><dt>4.8.3. <a href="#AEN7265">Sliced VBI Format Negotiation</a></dt><dt>4.8.4. <a href="#AEN7483">Reading and writing sliced VBI data</a></dt></dl></dd><dt>4.9. <a href="#TTX">Teletext Interface</a></dt><dt>4.10. <a href="#RADIO">Radio Interface</a></dt><dd><dl><dt>4.10.1. <a href="#AEN7585">Querying Capabilities</a></dt><dt>4.10.2. <a href="#AEN7594">Supplemental Functions</a></dt><dt>4.10.3. <a href="#AEN7600">Programming</a></dt></dl></dd><dt>4.11. <a href="#RDS">RDS Interface</a></dt></dl></dd><dt>I. <a href="#USER-FUNC">Function Reference</a></dt><dd><dl><dt><a href="#FUNC-CLOSE">V4L2 close()</a>&nbsp;--&nbsp;Close a V4L2 device</dt><dt><a href="#FUNC-IOCTL">V4L2 ioctl()</a>&nbsp;--&nbsp;Program a V4L2 device</dt><dt><a href="#VIDIOC-CROPCAP">ioctl VIDIOC_CROPCAP</a>&nbsp;--&nbsp;Information about the video cropping and scaling abilities</dt><dt><a href="#VIDIOC-DBG-G-REGISTER">ioctl VIDIOC_DBG_G_REGISTER, VIDIOC_DBG_S_REGISTER</a>&nbsp;--&nbsp;Read or write hardware registers</dt><dt><a href="#VIDIOC-ENCODER-CMD">ioctl VIDIOC_ENCODER_CMD, VIDIOC_TRY_ENCODER_CMD</a>&nbsp;--&nbsp;Execute an encoder command</dt><dt><a href="#VIDIOC-ENUMAUDIO">ioctl VIDIOC_ENUMAUDIO</a>&nbsp;--&nbsp;Enumerate audio inputs</dt><dt><a href="#VIDIOC-ENUMAUDIOOUT">ioctl VIDIOC_ENUMAUDOUT</a>&nbsp;--&nbsp;Enumerate audio outputs</dt><dt><a href="#VIDIOC-ENUM-FMT">ioctl VIDIOC_ENUM_FMT</a>&nbsp;--&nbsp;Enumerate image formats</dt><dt><a href="#VIDIOC-ENUM-FRAMESIZES">ioctl VIDIOC_ENUM_FRAMESIZES</a>&nbsp;--&nbsp;Enumerate frame sizes</dt><dt><a href="#VIDIOC-ENUM-FRAMEINTERVALS">ioctl VIDIOC_ENUM_FRAMEINTERVALS</a>&nbsp;--&nbsp;Enumerate frame intervals</dt><dt><a href="#VIDIOC-ENUMINPUT">ioctl VIDIOC_ENUMINPUT</a>&nbsp;--&nbsp;Enumerate video inputs</dt><dt><a href="#VIDIOC-ENUMOUTPUT">ioctl VIDIOC_ENUMOUTPUT</a>&nbsp;--&nbsp;Enumerate video outputs</dt><dt><a href="#VIDIOC-ENUMSTD">ioctl VIDIOC_ENUMSTD</a>&nbsp;--&nbsp;Enumerate supported video standards</dt><dt><a href="#VIDIOC-G-AUDIO">ioctl VIDIOC_G_AUDIO, VIDIOC_S_AUDIO</a>&nbsp;--&nbsp;Query or select the current audio input and its
attributes</dt><dt><a href="#VIDIOC-G-AUDIOOUT">ioctl VIDIOC_G_AUDOUT, VIDIOC_S_AUDOUT</a>&nbsp;--&nbsp;Query or select the current audio output</dt><dt><a href="#VIDIOC-G-CHIP-IDENT">ioctl VIDIOC_G_CHIP_IDENT</a>&nbsp;--&nbsp;Identify the chips on a TV card</dt><dt><a href="#VIDIOC-G-CROP">ioctl VIDIOC_G_CROP, VIDIOC_S_CROP</a>&nbsp;--&nbsp;Get or set the current cropping rectangle</dt><dt><a href="#VIDIOC-G-CTRL">ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL</a>&nbsp;--&nbsp;Get or set the value of a control</dt><dt><a href="#VIDIOC-G-ENC-INDEX">ioctl VIDIOC_G_ENC_INDEX</a>&nbsp;--&nbsp;Get meta data about a compressed video stream</dt><dt><a href="#VIDIOC-G-EXT-CTRLS">ioctl VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS,
VIDIOC_TRY_EXT_CTRLS</a>&nbsp;--&nbsp;Get or set the value of several controls, try control
values</dt><dt><a href="#VIDIOC-G-FBUF">ioctl VIDIOC_G_FBUF, VIDIOC_S_FBUF</a>&nbsp;--&nbsp;Get or set frame buffer overlay parameters</dt><dt><a href="#VIDIOC-G-FMT">ioctl VIDIOC_G_FMT, VIDIOC_S_FMT,
VIDIOC_TRY_FMT</a>&nbsp;--&nbsp;Get or set the data format, try a format</dt><dt><a href="#VIDIOC-G-FREQUENCY">ioctl VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY</a>&nbsp;--&nbsp;Get or set tuner or modulator radio
frequency</dt><dt><a href="#VIDIOC-G-INPUT">ioctl VIDIOC_G_INPUT, VIDIOC_S_INPUT</a>&nbsp;--&nbsp;Query or select the current video input</dt><dt><a href="#VIDIOC-G-JPEGCOMP">ioctl VIDIOC_G_JPEGCOMP, VIDIOC_S_JPEGCOMP</a>&nbsp;--&nbsp;</dt><dt><a href="#VIDIOC-G-MODULATOR">ioctl VIDIOC_G_MODULATOR, VIDIOC_S_MODULATOR</a>&nbsp;--&nbsp;Get or set modulator attributes</dt><dt><a href="#VIDIOC-G-OUTPUT">ioctl VIDIOC_G_OUTPUT, VIDIOC_S_OUTPUT</a>&nbsp;--&nbsp;Query or select the current video output</dt><dt><a href="#VIDIOC-G-PARM">ioctl VIDIOC_G_PARM, VIDIOC_S_PARM</a>&nbsp;--&nbsp;Get or set streaming parameters</dt><dt><a href="#VIDIOC-G-PRIORITY">ioctl VIDIOC_G_PRIORITY, VIDIOC_S_PRIORITY</a>&nbsp;--&nbsp;Query or request the access priority associated with a
file descriptor</dt><dt><a href="#VIDIOC-G-SLICED-VBI-CAP">ioctl VIDIOC_G_SLICED_VBI_CAP</a>&nbsp;--&nbsp;Query sliced VBI capabilities</dt><dt><a href="#VIDIOC-G-STD">ioctl VIDIOC_G_STD, VIDIOC_S_STD</a>&nbsp;--&nbsp;Query or select the video standard of the current input</dt><dt><a href="#VIDIOC-G-TUNER">ioctl VIDIOC_G_TUNER, VIDIOC_S_TUNER</a>&nbsp;--&nbsp;Get or set tuner attributes</dt><dt><a href="#VIDIOC-LOG-STATUS">ioctl VIDIOC_LOG_STATUS</a>&nbsp;--&nbsp;Log driver status information</dt><dt><a href="#VIDIOC-OVERLAY">ioctl VIDIOC_OVERLAY</a>&nbsp;--&nbsp;Start or stop video overlay</dt><dt><a href="#VIDIOC-QBUF">ioctl VIDIOC_QBUF, VIDIOC_DQBUF</a>&nbsp;--&nbsp;Exchange a buffer with the driver</dt><dt><a href="#VIDIOC-QUERYBUF">ioctl VIDIOC_QUERYBUF</a>&nbsp;--&nbsp;Query the status of a buffer</dt><dt><a href="#VIDIOC-QUERYCAP">ioctl VIDIOC_QUERYCAP</a>&nbsp;--&nbsp;Query device capabilities</dt><dt><a href="#VIDIOC-QUERYCTRL">ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERYMENU</a>&nbsp;--&nbsp;Enumerate controls and menu control items</dt><dt><a href="#VIDIOC-QUERYSTD">ioctl VIDIOC_QUERYSTD</a>&nbsp;--&nbsp;Sense the video standard received by the current
input</dt><dt><a href="#VIDIOC-REQBUFS">ioctl VIDIOC_REQBUFS</a>&nbsp;--&nbsp;Initiate Memory Mapping or User Pointer I/O</dt><dt><a href="#VIDIOC-STREAMON">ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF</a>&nbsp;--&nbsp;Start or stop streaming I/O</dt><dt><a href="#FUNC-MMAP">V4L2 mmap()</a>&nbsp;--&nbsp;Map device memory into application address space</dt><dt><a href="#FUNC-MUNMAP">V4L2 munmap()</a>&nbsp;--&nbsp;Unmap device memory</dt><dt><a href="#FUNC-OPEN">V4L2 open()</a>&nbsp;--&nbsp;Open a V4L2 device</dt><dt><a href="#FUNC-POLL">V4L2 poll()</a>&nbsp;--&nbsp;Wait for some event on a file descriptor</dt><dt><a href="#FUNC-READ">V4L2 read()</a>&nbsp;--&nbsp;Read from a V4L2 device</dt><dt><a href="#FUNC-SELECT">V4L2 select()</a>&nbsp;--&nbsp;Synchronous I/O multiplexing</dt><dt><a href="#FUNC-WRITE">V4L2 write()</a>&nbsp;--&nbsp;Write to a V4L2 device</dt></dl></dd><dt>5. <a href="#DRIVER">V4L2 Driver Programming</a></dt><dt>6. <a href="#COMPAT">Changes</a></dt><dd><dl><dt>6.1. <a href="#DIFF-V4L">Differences between V4L and V4L2</a></dt><dd><dl><dt>6.1.1. <a href="#AEN14602">Opening and Closing Devices</a></dt><dt>6.1.2. <a href="#AEN14665">Querying Capabilities</a></dt><dt>6.1.3. <a href="#AEN14821">Video Sources</a></dt><dt>6.1.4. <a href="#AEN14877">Tuning</a></dt><dt>6.1.5. <a href="#V4L-IMAGE-PROPERTIES">Image Properties</a></dt><dt>6.1.6. <a href="#AEN15120">Audio</a></dt><dt>6.1.7. <a href="#AEN15205">Frame Buffer Overlay</a></dt><dt>6.1.8. <a href="#AEN15269">Cropping</a></dt><dt>6.1.9. <a href="#AEN15302">Reading Images, Memory Mapping</a></dt><dt>6.1.10. <a href="#AEN15385">Reading Raw VBI Data</a></dt><dt>6.1.11. <a href="#AEN15438">Miscellaneous</a></dt></dl></dd><dt>6.2. <a href="#HIST-V4L2">Changes of the V4L2 API</a></dt><dd><dl><dt>6.2.1. <a href="#AEN15449">Early Versions</a></dt><dt>6.2.2. <a href="#AEN15499">V4L2 Version 0.16 1999-01-31</a></dt><dt>6.2.3. <a href="#AEN15502">V4L2 Version 0.18 1999-03-16</a></dt><dt>6.2.4. <a href="#AEN15505">V4L2 Version 0.19 1999-06-05</a></dt><dt>6.2.5. <a href="#AEN15514">V4L2 Version 0.20 (1999-09-10)</a></dt><dt>6.2.6. <a href="#AEN15575">V4L2 Version 0.20 incremental changes</a></dt><dt>6.2.7. <a href="#AEN15628">V4L2 Version 0.20 2000-11-23</a></dt><dt>6.2.8. <a href="#AEN15657">V4L2 Version 0.20 2002-07-25</a></dt><dt>6.2.9. <a href="#AEN15660">V4L2 in Linux 2.5.46, 2002-10</a></dt><dt>6.2.10. <a href="#AEN16046">V4L2 2003-06-19</a></dt><dt>6.2.11. <a href="#AEN16089">V4L2 2003-11-05</a></dt><dt>6.2.12. <a href="#AEN16131">V4L2 in Linux 2.6.6, 2004-05-09</a></dt><dt>6.2.13. <a href="#AEN16139">V4L2 in Linux 2.6.8</a></dt><dt>6.2.14. <a href="#AEN16149">V4L2 spec erratum 2004-08-01</a></dt><dt>6.2.15. <a href="#AEN16170">V4L2 in Linux 2.6.14</a></dt><dt>6.2.16. <a href="#AEN16176">V4L2 in Linux 2.6.15</a></dt><dt>6.2.17. <a href="#AEN16203">V4L2 spec erratum 2005-11-27</a></dt><dt>6.2.18. <a href="#AEN16212">V4L2 spec erratum 2006-01-10</a></dt><dt>6.2.19. <a href="#AEN16223">V4L2 spec erratum 2006-02-03</a></dt><dt>6.2.20. <a href="#AEN16231">V4L2 spec erratum 2006-02-04</a></dt><dt>6.2.21. <a href="#AEN16241">V4L2 in Linux 2.6.17</a></dt><dt>6.2.22. <a href="#AEN16261">V4L2 spec erratum 2006-09-23 (Draft 0.15)</a></dt><dt>6.2.23. <a href="#AEN16297">V4L2 in Linux 2.6.18</a></dt><dt>6.2.24. <a href="#AEN16319">V4L2 in Linux 2.6.19</a></dt><dt>6.2.25. <a href="#AEN16338">V4L2 spec erratum 2006-10-12 (Draft 0.17)</a></dt><dt>6.2.26. <a href="#AEN16345">V4L2 in Linux 2.6.21</a></dt><dt>6.2.27. <a href="#AEN16351">V4L2 in Linux 2.6.22</a></dt><dt>6.2.28. <a href="#AEN16378">V4L2 in Linux 2.6.24</a></dt><dt>6.2.29. <a href="#AEN16388">V4L2 in Linux 2.6.25</a></dt></dl></dd><dt>6.3. <a href="#OTHER">Relation of V4L2 to other Linux multimedia APIs</a></dt><dd><dl><dt>6.3.1. <a href="#XVIDEO">X Video Extension</a></dt><dt>6.3.2. <a href="#AEN16446">Digital Video</a></dt><dt>6.3.3. <a href="#AEN16450">Audio Interfaces</a></dt></dl></dd><dt>6.4. <a href="#EXPERIMENTAL">Experimental API Elements</a></dt><dt>6.5. <a href="#OBSOLETE">Obsolete API Elements</a></dt></dl></dd><dt>A. <a href="#VIDEODEV">Video For Linux Two Header File</a></dt><dt>B. <a href="#CAPTURE-EXAMPLE">Video Capture Example</a></dt><dt>C. <a href="#FDL">GNU Free Documentation License</a></dt><dd><dl><dt>C.1. <a href="#FDL-PREAMBLE">0. PREAMBLE</a></dt><dt>C.2. <a href="#FDL-SECTION1">1. APPLICABILITY AND DEFINITIONS</a></dt><dt>C.3. <a href="#FDL-SECTION2">2. VERBATIM COPYING</a></dt><dt>C.4. <a href="#FDL-SECTION3">3. COPYING IN QUANTITY</a></dt><dt>C.5. <a href="#FDL-SECTION4">4. MODIFICATIONS</a></dt><dt>C.6. <a href="#FDL-SECTION5">5. COMBINING DOCUMENTS</a></dt><dt>C.7. <a href="#FDL-SECTION6">6. COLLECTIONS OF DOCUMENTS</a></dt><dt>C.8. <a href="#FDL-SECTION7">7. AGGREGATION WITH INDEPENDENT WORKS</a></dt><dt>C.9. <a href="#FDL-SECTION8">8. TRANSLATION</a></dt><dt>C.10. <a href="#FDL-SECTION9">9. TERMINATION</a></dt><dt>C.11. <a href="#FDL-SECTION10">10. FUTURE REVISIONS OF THIS LICENSE</a></dt><dt>C.12. <a href="#FDL-USING">Addendum</a></dt></dl></dd><dt><a href="#AEN16960">List of Types</a></dt><dt><a href="#AEN17127">References</a></dt></dl></div><div class="LOT"><dl class="LOT"><dt><b>List of Figures</b></dt><dt>1-1. <a href="#CROP-SCALE">Image Cropping, Insertion and Scaling</a></dt><dt>3-1. <a href="#FIELDSEQ-TB">Field Order, Top Field First Transmitted</a></dt><dt>3-2. <a href="#FIELDSEQ-BT">Field Order, Bottom Field First Transmitted</a></dt><dt>4-1. <a href="#VBI-HSYNC">Line synchronization</a></dt><dt>4-2. <a href="#VBI-525">ITU-R 525 line numbering (M/NTSC and M/PAL)</a></dt><dt>4-3. <a href="#VBI-625">ITU-R 625 line numbering</a></dt></dl></div><div class="LOT"><dl class="LOT"><dt><b>List of Examples</b></dt><dt>1-1. <a href="#AEN328">Information about the current video input</a></dt><dt>1-2. <a href="#AEN336">Switching to the first video input</a></dt><dt>1-3. <a href="#AEN382">Information about the current audio input</a></dt><dt>1-4. <a href="#AEN388">Switching to the first audio input</a></dt><dt>1-5. <a href="#AEN510">Information about the current video standard</a></dt><dt>1-6. <a href="#AEN519">Listing the video standards supported by the current
input</a></dt><dt>1-7. <a href="#AEN530">Selecting a new video standard</a></dt><dt>1-8. <a href="#AEN778">Enumerating all controls</a></dt><dt>1-9. <a href="#AEN789">Changing controls</a></dt><dt>1-10. <a href="#AEN1972">Resetting the cropping parameters</a></dt><dt>1-11. <a href="#AEN1983">Simple downscaling</a></dt><dt>1-12. <a href="#AEN1991">Selecting an output area</a></dt><dt>1-13. <a href="#AEN1996">Current scaling factor and pixel aspect</a></dt><dt>2-1. <a href="#AEN2217">ITU-R Rec. BT.601 color conversion</a></dt><dt>2-1. <a href="#AEN3061"><code class="CONSTANT">V4L2_PIX_FMT_BGR24</code> 4 ¡Á 4 pixel
image</a></dt><dt>2-1. <a href="#AEN3746"><code class="CONSTANT">V4L2_PIX_FMT_SBGGR8</code> 4 ¡Á 4
pixel image</a></dt><dt>2-1. <a href="#AEN3809"><code class="CONSTANT">V4L2_PIX_FMT_SBGGR16</code> 4 ¡Á 4
pixel image</a></dt><dt>2-1. <a href="#AEN4196"><code class="CONSTANT">V4L2_PIX_FMT_GREY</code> 4 ¡Á 4
pixel image</a></dt><dt>2-1. <a href="#AEN4257"><code class="CONSTANT">V4L2_PIX_FMT_Y16</code> 4 ¡Á 4
pixel image</a></dt><dt>2-1. <a href="#AEN4351"><code class="CONSTANT">V4L2_PIX_FMT_YUYV</code> 4 ¡Á 4
pixel image</a></dt><dt>2-1. <a href="#AEN4496"><code class="CONSTANT">V4L2_PIX_FMT_UYVY</code> 4 ¡Á 4
pixel image</a></dt><dt>2-1. <a href="#AEN4645"><code class="CONSTANT">V4L2_PIX_FMT_Y41P</code> 8 ¡Á 4
pixel image</a></dt><dt>2-1. <a href="#AEN4871"><code class="CONSTANT">V4L2_PIX_FMT_YVU420</code> 4 ¡Á 4
pixel image</a></dt><dt>2-1. <a href="#AEN5032"><code class="CONSTANT">V4L2_PIX_FMT_YVU410</code> 4 ¡Á 4
pixel image</a></dt><dt>2-1. <a href="#AEN5170"><code class="CONSTANT">V4L2_PIX_FMT_YUV422P</code> 4 ¡Á 4
pixel image</a></dt><dt>2-1. <a href="#AEN5337"><code class="CONSTANT">V4L2_PIX_FMT_YUV411P</code> 4 ¡Á 4
pixel image</a></dt><dt>2-1. <a href="#AEN5493"><code class="CONSTANT">V4L2_PIX_FMT_NV12</code> 4 ¡Á 4
pixel image</a></dt><dt>3-1. <a href="#AEN5823">Mapping buffers</a></dt><dt>3-2. <a href="#AEN5899">Initiating streaming I/O with user pointers</a></dt><dt>4-1. <a href="#AEN6949">Finding a framebuffer device for OSD</a></dt></dl></div><div class="PREFACE"><hr><h1><a name="AEN163"></a>Introduction</h1><p>Video For Linux Two is the second version of the Video For
Linux API, a kernel interface for analog radio and video capture and
output drivers.</p><p>Early drivers used ad-hoc interfaces. These were replaced in
Linux 2.2 by Alan Cox' V4L API, based on the interface of the bttv
driver. In 1999 Bill Dirks started the development of V4L2 to fix some
shortcomings of V4L and to support a wider range of devices. The API
was revised again in 2002 prior to its inclusion in Linux 2.5/2.6, and
work continues on improvements and additions while maintaining
compatibility with existing drivers and applications. In 2006/2007
efforts began on FreeBSD drivers with a V4L2 interface.</p><p>This book documents the V4L2 API. Intended audience are
driver and application writers.</p><p>If you have questions or ideas regarding the API, please
write to the Video4Linux mailing list: <a href="https://listman.redhat.com/mailman/listinfo/video4linux-list" target="_top">https://listman.redhat.com/mailman/listinfo/video4linux-list</a>. For inquiries about
the V4L2 specification contact the maintainer <a href="mailto:mschimek@gmx.at" target="_top">mschimek@gmx.at</a>.</p><p>The latest version of this document and the DocBook SGML
sources are hosted at <a href="http://v4l2spec.bytesex.org/" target="_top">http://v4l2spec.bytesex.org</a>,
and <a href="http://linuxtv.org/downloads/video4linux/API/V4L2_API" target="_top">http://linuxtv.org/downloads/video4linux/API/V4L2_API</a>.</p></div><div class="CHAPTER"><hr><h1><a name="COMMON"></a>Chapter 1. Common API Elements</h1><p>Programming a V4L2 device consists of these
steps:</p><p></p><ul><li><p>Opening the device</p></li><li><p>Changing device properties, selecting a video and audio
input, video standard, picture brightness a.&nbsp;o.</p></li><li><p>Negotiating a data format</p></li><li><p>Negotiating an input/output method</p></li><li><p>The actual input/output loop</p></li><li><p>Closing the device</p></li></ul><p>In practice most steps are optional and can be executed out of
order. It depends on the V4L2 device type, you can read about the
details in <a href="#DEVICES">Chapter 4</a>. In this chapter we will discuss
the basic concepts applicable to all devices.</p><div class="SECTION"><hr><h2 class="SECTION"><a name="OPEN">1.1. Opening and Closing Devices</a></h2><div class="SECTION"><h3 class="SECTION"><a name="AEN194">1.1.1. Device Naming</a></h3><p>V4L2 drivers are implemented as kernel modules, loaded
manually by the system administrator or automatically when a device is
first opened. The driver modules plug into the "videodev" kernel
module. It provides helper functions and a common application
interface specified in this document.</p><p>Each driver thus loaded registers one or more device nodes
with major number 81 and a minor number between 0 and 255. Assigning
minor numbers to V4L2 devices is entirely up to the system administrator,
this is primarily intended to solve conflicts between devices.<a name="AEN198" href="#FTN.AEN198"><span class="footnote">[1]</span></a> The module options to select minor numbers are named
after the device special file with a "_nr" suffix. For example "video_nr"
for <tt class="FILENAME">/dev/video</tt> video capture devices. The number is
an offset to the base minor number associated with the device type.
<a name="AEN201" href="#FTN.AEN201"><span class="footnote">[2]</span></a> When the driver supports multiple devices of the same
type more than one minor number can be assigned, separated by commas:
</p><div class="INFORMALEXAMPLE"><p></p><a name="AEN203"></a><pre class="SCREEN">&gt; insmod mydriver.o video_nr=0,1 radio_nr=0,1</pre><p></p></div><p></p><p>In <tt class="FILENAME">/etc/modules.conf</tt> this may be
written as: </p><div class="INFORMALEXAMPLE"><p></p><a name="AEN207"></a><pre class="SCREEN">alias char-major-81-0 mydriver
alias char-major-81-1 mydriver
alias char-major-81-64 mydriver              <a name="ALIAS"><img src="v4l2_files/1.gif" alt="(1)" border="0" hspace="0" vspace="0"></a>
options mydriver video_nr=0,1 radio_nr=0,1   <a name="OPTIONS"><img src="v4l2_files/2.gif" alt="(2)" border="0" hspace="0" vspace="0"></a>
          </pre><div class="CALLOUTLIST"><dl compact="COMPACT"><dt><a href="#ALIAS"><img src="v4l2_files/1.gif" alt="(1)" border="0" hspace="0" vspace="0"></a></dt><dd>When an application attempts to open a device
special file with major number 81 and minor number 0, 1, or 64, load
"mydriver" (and the "videodev" module it depends upon).</dd><dt><a href="#OPTIONS"><img src="v4l2_files/2.gif" alt="(2)" border="0" hspace="0" vspace="0"></a></dt><dd>Register the first two video capture devices with
minor number 0 and 1 (base number is 0), the first two radio device
with minor number 64 and 65 (base 64).</dd></dl></div><p></p></div> When no minor number is given as module
option the driver supplies a default. <a href="#DEVICES">Chapter 4</a>
recommends the base minor numbers to be used for the various device
types. Obviously minor numbers must be unique. When the number is
already in use the <span class="emphasis"><i class="EMPHASIS">offending device</i></span> will not be
registered. <p></p><p>By convention system administrators create various
character device special files with these major and minor numbers in
the <tt class="FILENAME">/dev</tt> directory. The names recomended for the
different V4L2 device types are listed in <a href="#DEVICES">Chapter 4</a>.</p><p>The creation of character special files (with
<span class="APPLICATION">mknod</span>) is a privileged operation and
devices cannot be opened by major and minor number. That means
applications cannot <span class="emphasis"><i class="EMPHASIS">reliable</i></span> scan for loaded or
installed drivers. The user must enter a device name, or the
application can try the conventional device names.</p><p>Under the device filesystem (devfs) the minor number
options are ignored. V4L2 drivers (or by proxy the "videodev" module)
automatically create the required device files in the
<tt class="FILENAME">/dev/v4l</tt> directory using the conventional device
names above.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="RELATED">1.1.2. Related Devices</a></h3><p>Devices can support several related functions. For example
video capturing, video overlay and VBI capturing are related because
these functions share, amongst other, the same video input and tuner
frequency. V4L and earlier versions of V4L2 used the same device name
and minor number for video capturing and overlay, but different ones
for VBI. Experience showed this approach has several problems<a name="AEN229" href="#FTN.AEN229"><span class="footnote">[3]</span></a>, and to make things worse the V4L videodev module
used to prohibit multiple opens of a device.</p><p>As a remedy the present version of the V4L2 API relaxed the
concept of device types with specific names and minor numbers. For
compatibility with old applications drivers must still register different
minor numbers to assign a default function to the device. But if related
functions are supported by the driver they must be available under all
registered minor numbers. The desired function can be selected after
opening the device as described in <a href="#DEVICES">Chapter 4</a>.</p><p>Imagine a driver supporting video capturing, video
overlay, raw VBI capturing, and FM radio reception. It registers three
devices with minor number 0, 64 and 224 (this numbering scheme is
inherited from the V4L API). Regardless if
<tt class="FILENAME">/dev/video</tt> (81, 0) or
<tt class="FILENAME">/dev/vbi</tt> (81, 224) is opened the application can
select any one of the video capturing, overlay or VBI capturing
functions. Without programming (e.&nbsp;g. reading from the device
with <span class="APPLICATION">dd</span> or <span class="APPLICATION">cat</span>)
<tt class="FILENAME">/dev/video</tt> captures video images, while
<tt class="FILENAME">/dev/vbi</tt> captures raw VBI data.
<tt class="FILENAME">/dev/radio</tt> (81, 64) is invariable a radio device,
unrelated to the video functions. Being unrelated does not imply the
devices can be used at the same time, however. The <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>
function may very well return an <span class="ERRORCODE">EBUSY</span> error code.</p><p>Besides video input or output the hardware may also
support audio sampling or playback. If so, these functions are
implemented as OSS or ALSA PCM devices and eventually OSS or ALSA
audio mixer. The V4L2 API makes no provisions yet to find these
related devices. If you have an idea please write to the Video4Linux
mailing list: <a href="https://listman.redhat.com/mailman/listinfo/video4linux-list" target="_top">https://listman.redhat.com/mailman/listinfo/video4linux-list</a>.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN249">1.1.3. Multiple Opens</a></h3><p>In general, V4L2 devices can be opened more than once.
When this is supported by the driver, users can for example start a
"panel" application to change controls like brightness or audio
volume, while another application captures video and audio. In other words, panel
applications are comparable to an OSS or ALSA audio mixer application.
When a device supports multiple functions like capturing and overlay
<span class="emphasis"><i class="EMPHASIS">simultaneously</i></span>, multiple opens allow concurrent
use of the device by forked processes or specialized applications.</p><p>Multiple opens are optional, although drivers should
permit at least concurrent accesses without data exchange, i.&nbsp;e. panel
applications. This implies <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a> can return an <span class="ERRORCODE">EBUSY</span> error code when the
device is already in use, as well as <a href="#FUNC-IOCTL"><code class="FUNCTION">ioctl()</code></a> functions initiating
data exchange (namely the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl), and the <a href="#FUNC-READ"><code class="FUNCTION">read()</code></a>
and <a href="#FUNC-WRITE"><code class="FUNCTION">write()</code></a> functions.</p><p>Mere opening a V4L2 device does not grant exclusive
access.<a name="AEN266" href="#FTN.AEN266"><span class="footnote">[4]</span></a> Initiating data exchange however assigns the right
to read or write the requested type of data, and to change related
properties, to this file descriptor. Applications can request
additional access privileges using the priority mechanism described in
<a href="#APP-PRI">Section 1.3</a>.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN270">1.1.4. Shared Data Streams</a></h3><p>V4L2 drivers should not support multiple applications
reading or writing the same data stream on a device by copying
buffers, time multiplexing or similar means. This is better handled by
a proxy application in user space. When the driver supports stream
sharing anyway it must be implemented transparently. The V4L2 API does
not specify how conflicts are solved. </p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN273">1.1.5. Functions</a></h3><p>To open and close V4L2 devices applications use the
<a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a> and <a href="#FUNC-CLOSE"><code class="FUNCTION">close()</code></a> function, respectively. Devices are
programmed using the <a href="#FUNC-IOCTL"><code class="FUNCTION">ioctl()</code></a> function as explained in the
following sections.</p></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="QUERYCAP">1.2. Querying Capabilities</a></h2><p>Because V4L2 covers a wide variety of devices not all
aspects of the API are equally applicable to all types of devices.
Furthermore devices of the same type have different capabilities and
this specification permits the omission of a few complicated and less
important parts of the API.</p><p>The <a href="#VIDIOC-QUERYCAP"><code class="CONSTANT">VIDIOC_QUERYCAP</code></a> ioctl is available to check if the kernel
device is compatible with this specification, and to query the <a href="#DEVICES">functions</a> and <a href="#IO">I/O
methods</a> supported by the device. Other features can be queried
by calling the respective ioctl, for example <a href="#VIDIOC-ENUMINPUT"><code class="CONSTANT">VIDIOC_ENUMINPUT</code></a>
to learn about the number, types and names of video connectors on the
device. Although abstraction is a major objective of this API, the
ioctl also allows driver specific applications to reliable identify
the driver.</p><p>All V4L2 drivers must support
<code class="CONSTANT">VIDIOC_QUERYCAP</code>. Applications should always call
this ioctl after opening the device.</p></div><div class="SECTION"><hr><h2 class="SECTION"><a name="APP-PRI">1.3. Application Priority</a></h2><p>When multiple applications share a device it may be
desirable to assign them different priorities. Contrary to the
traditional "rm -rf /" school of thought a video recording application
could for example block other applications from changing video
controls or switching the current TV channel. Another objective is to
permit low priority applications working in background, which can be
preempted by user controlled applications and automatically regain
control of the device at a later time.</p><p>Since these features cannot be implemented entirely in user
space V4L2 defines the <a href="#VIDIOC-G-PRIORITY"><code class="CONSTANT">VIDIOC_G_PRIORITY</code></a> and <a href="#VIDIOC-G-PRIORITY"><code class="CONSTANT">VIDIOC_S_PRIORITY</code></a>
ioctls to request and query the access priority associate with a file
descriptor. Opening a device assigns a medium priority, compatible
with earlier versions of V4L2 and drivers not supporting these ioctls.
Applications requiring a different priority will usually call
<code class="CONSTANT">VIDIOC_S_PRIORITY</code> after verifying the device with
the <a href="#VIDIOC-QUERYCAP"><code class="CONSTANT">VIDIOC_QUERYCAP</code></a> ioctl.</p><p>Ioctls changing driver properties, such as <a href="#VIDIOC-G-INPUT"><code class="CONSTANT">VIDIOC_S_INPUT</code></a>,
return an <span class="ERRORCODE">EBUSY</span> error code after another application obtained higher priority.
An event mechanism to notify applications about asynchronous property
changes has been proposed but not added yet.</p></div><div class="SECTION"><hr><h2 class="SECTION"><a name="VIDEO">1.4. Video Inputs and Outputs</a></h2><p>Video inputs and outputs are physical connectors of a
device. These can be for example RF connectors (antenna/cable), CVBS
a.k.a. Composite Video, S-Video or RGB connectors. Only video and VBI
capture devices have inputs, output devices have outputs, at least one
each. Radio devices have no video inputs or outputs.</p><p>To learn about the number and attributes of the
available inputs and outputs applications can enumerate them with the
<a href="#VIDIOC-ENUMINPUT"><code class="CONSTANT">VIDIOC_ENUMINPUT</code></a> and <a href="#VIDIOC-ENUMOUTPUT"><code class="CONSTANT">VIDIOC_ENUMOUTPUT</code></a> ioctl, respectively. The
struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a> returned by the <code class="CONSTANT">VIDIOC_ENUMINPUT</code>
ioctl also contains signal status information applicable when the
current video input is queried.</p><p>The <a href="#VIDIOC-G-INPUT"><code class="CONSTANT">VIDIOC_G_INPUT</code></a> and <a href="#VIDIOC-G-OUTPUT"><code class="CONSTANT">VIDIOC_G_OUTPUT</code></a> ioctl return the
index of the current video input or output. To select a different
input or output applications call the <a href="#VIDIOC-G-INPUT"><code class="CONSTANT">VIDIOC_S_INPUT</code></a> and
<a href="#VIDIOC-G-OUTPUT"><code class="CONSTANT">VIDIOC_S_OUTPUT</code></a> ioctl. Drivers must implement all the input ioctls
when the device has one or more inputs, all the output ioctls when the
device has one or more outputs.</p><div class="EXAMPLE"><a name="AEN328"></a><p><b>Example 1-1. Information about the current video input</b></p><pre class="PROGRAMLISTING">struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a> input;
int index;

if (-1 == ioctl (fd, <a href="#VIDIOC-G-INPUT"><code class="CONSTANT">VIDIOC_G_INPUT</code></a>, &amp;index)) {
        perror ("VIDIOC_G_INPUT");
        exit (EXIT_FAILURE);
}

memset (&amp;input, 0, sizeof (input));
input.index = index;

if (-1 == ioctl (fd, <a href="#VIDIOC-ENUMINPUT"><code class="CONSTANT">VIDIOC_ENUMINPUT</code></a>, &amp;input)) {
        perror ("VIDIOC_ENUMINPUT");
        exit (EXIT_FAILURE);
}

printf ("Current input: %s\n", input.name);
      </pre></div><div class="EXAMPLE"><a name="AEN336"></a><p><b>Example 1-2. Switching to the first video input</b></p><pre class="PROGRAMLISTING">int index;

index = 0;

if (-1 == ioctl (fd, <a href="#VIDIOC-G-INPUT"><code class="CONSTANT">VIDIOC_S_INPUT</code></a>, &amp;index)) {
        perror ("VIDIOC_S_INPUT");
        exit (EXIT_FAILURE);
}
      </pre></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="AUDIO">1.5. Audio Inputs and Outputs</a></h2><p>Audio inputs and outputs are physical connectors of a
device. Video capture devices have inputs, output devices have
outputs, zero or more each. Radio devices have no audio inputs or
outputs. They have exactly one tuner which in fact
<span class="emphasis"><i class="EMPHASIS">is</i></span> an audio source, but this API associates
tuners with video inputs or outputs only, and radio devices have
none of these.<a name="AEN345" href="#FTN.AEN345"><span class="footnote">[5]</span></a> A connector on a TV card to loop back the received
audio signal to a sound card is not considered an audio output.</p><p>Audio and video inputs and outputs are associated. Selecting
a video source also selects an audio source. This is most evident when
the video and audio source is a tuner. Further audio connectors can
combine with more than one video input or output. Assumed two
composite video inputs and two audio inputs exist, there may be up to
four valid combinations. The relation of video and audio connectors
is defined in the <code class="STRUCTFIELD">audioset</code> field of the
respective struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a> or struct&nbsp;<a href="#V4L2-OUTPUT">v4l2_output</a>, where each bit represents
the index number, starting at zero, of one audio input or output.</p><p>To learn about the number and attributes of the
available inputs and outputs applications can enumerate them with the
<a href="#VIDIOC-ENUMAUDIO"><code class="CONSTANT">VIDIOC_ENUMAUDIO</code></a> and <a href="#VIDIOC-ENUMAUDIOOUT"><code class="CONSTANT">VIDIOC_ENUMAUDOUT</code></a> ioctl, respectively. The
struct&nbsp;<a href="#V4L2-AUDIO">v4l2_audio</a> returned by the <code class="CONSTANT">VIDIOC_ENUMAUDIO</code> ioctl
also contains signal status information applicable when the current
audio input is queried.</p><p>The <a href="#VIDIOC-G-AUDIO"><code class="CONSTANT">VIDIOC_G_AUDIO</code></a> and <a href="#VIDIOC-G-AUDIOOUT"><code class="CONSTANT">VIDIOC_G_AUDOUT</code></a> ioctl report
the current audio input and output, respectively. Note that, unlike
<a href="#VIDIOC-G-INPUT"><code class="CONSTANT">VIDIOC_G_INPUT</code></a> and <a href="#VIDIOC-G-OUTPUT"><code class="CONSTANT">VIDIOC_G_OUTPUT</code></a> these ioctls return a structure
as <code class="CONSTANT">VIDIOC_ENUMAUDIO</code> and
<code class="CONSTANT">VIDIOC_ENUMAUDOUT</code> do, not just an index.</p><p>To select an audio input and change its properties
applications call the <a href="#VIDIOC-G-AUDIO"><code class="CONSTANT">VIDIOC_S_AUDIO</code></a> ioctl. To select an audio
output (which presently has no changeable properties) applications
call the <a href="#VIDIOC-G-AUDIOOUT"><code class="CONSTANT">VIDIOC_S_AUDOUT</code></a> ioctl.</p><p>Drivers must implement all input ioctls when the device
has one or more inputs, all output ioctls when the device has one
or more outputs. When the device has any audio inputs or outputs the
driver must set the <code class="CONSTANT">V4L2_CAP_AUDIO</code> flag in the
struct&nbsp;<a href="#V4L2-CAPABILITY">v4l2_capability</a> returned by the <a href="#VIDIOC-QUERYCAP"><code class="CONSTANT">VIDIOC_QUERYCAP</code></a> ioctl.</p><div class="EXAMPLE"><a name="AEN382"></a><p><b>Example 1-3. Information about the current audio input</b></p><pre class="PROGRAMLISTING">struct&nbsp;<a href="#V4L2-AUDIO">v4l2_audio</a> audio;

memset (&amp;audio, 0, sizeof (audio));

if (-1 == ioctl (fd, <a href="#VIDIOC-G-AUDIO"><code class="CONSTANT">VIDIOC_G_AUDIO</code></a>, &amp;audio)) {
        perror ("VIDIOC_G_AUDIO");
        exit (EXIT_FAILURE);
}

printf ("Current input: %s\n", audio.name);
      </pre></div><div class="EXAMPLE"><a name="AEN388"></a><p><b>Example 1-4. Switching to the first audio input</b></p><pre class="PROGRAMLISTING">struct&nbsp;<a href="#V4L2-AUDIO">v4l2_audio</a> audio;

memset (&amp;audio, 0, sizeof (audio)); /* clear audio.mode, audio.reserved */

audio.index = 0;

if (-1 == ioctl (fd, <a href="#VIDIOC-G-AUDIO"><code class="CONSTANT">VIDIOC_S_AUDIO</code></a>, &amp;audio)) {
        perror ("VIDIOC_S_AUDIO");
        exit (EXIT_FAILURE);
}
      </pre></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="TUNER">1.6. Tuners and Modulators</a></h2><div class="SECTION"><h3 class="SECTION"><a name="AEN396">1.6.1. Tuners</a></h3><p>Video input devices can have one or more tuners
demodulating a RF signal. Each tuner is associated with one or more
video inputs, depending on the number of RF connectors on the tuner.
The <code class="STRUCTFIELD">type</code> field of the respective
struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a> returned by the <a href="#VIDIOC-ENUMINPUT"><code class="CONSTANT">VIDIOC_ENUMINPUT</code></a> ioctl is set to
<code class="CONSTANT">V4L2_INPUT_TYPE_TUNER</code> and its
<code class="STRUCTFIELD">tuner</code> field contains the index number of
the tuner.</p><p>Radio devices have exactly one tuner with index zero, no
video inputs.</p><p>To query and change tuner properties applications use the
<a href="#VIDIOC-G-TUNER"><code class="CONSTANT">VIDIOC_G_TUNER</code></a> and <a href="#VIDIOC-G-TUNER"><code class="CONSTANT">VIDIOC_S_TUNER</code></a> ioctl, respectively. The
struct&nbsp;<a href="#V4L2-TUNER">v4l2_tuner</a> returned by <code class="CONSTANT">VIDIOC_G_TUNER</code> also
contains signal status information applicable when the tuner of the
current video input, or a radio tuner is queried. Note that
<code class="CONSTANT">VIDIOC_S_TUNER</code> does not switch the current tuner,
when there is more than one at all. The tuner is solely determined by
the current video input. Drivers must support both ioctls and set the
<code class="CONSTANT">V4L2_CAP_TUNER</code> flag in the struct&nbsp;<a href="#V4L2-CAPABILITY">v4l2_capability</a>
returned by the <a href="#VIDIOC-QUERYCAP"><code class="CONSTANT">VIDIOC_QUERYCAP</code></a> ioctl when the device has one or
more tuners.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN418">1.6.2. Modulators</a></h3><p>Video output devices can have one or more modulators, uh,
modulating a video signal for radiation or connection to the antenna
input of a TV set or video recorder. Each modulator is associated with
one or more video outputs, depending on the number of RF connectors on
the modulator. The <code class="STRUCTFIELD">type</code> field of the
respective struct&nbsp;<a href="#V4L2-OUTPUT">v4l2_output</a> returned by the <a href="#VIDIOC-ENUMOUTPUT"><code class="CONSTANT">VIDIOC_ENUMOUTPUT</code></a> ioctl is
set to <code class="CONSTANT">V4L2_OUTPUT_TYPE_MODULATOR</code> and its
<code class="STRUCTFIELD">modulator</code> field contains the index number
of the modulator. This specification does not define radio output
devices.</p><p>To query and change modulator properties applications use
the <a href="#VIDIOC-G-MODULATOR"><code class="CONSTANT">VIDIOC_G_MODULATOR</code></a> and <a href="#VIDIOC-G-MODULATOR"><code class="CONSTANT">VIDIOC_S_MODULATOR</code></a> ioctl. Note that
<code class="CONSTANT">VIDIOC_S_MODULATOR</code> does not switch the current
modulator, when there is more than one at all. The modulator is solely
determined by the current video output. Drivers must support both
ioctls and set the <code class="CONSTANT">V4L2_CAP_TUNER</code> (sic) flag in
the struct&nbsp;<a href="#V4L2-CAPABILITY">v4l2_capability</a> returned by the <a href="#VIDIOC-QUERYCAP"><code class="CONSTANT">VIDIOC_QUERYCAP</code></a> ioctl when the
device has one or more modulators.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN437">1.6.3. Radio Frequency</a></h3><p>To get and set the tuner or modulator radio frequency
applications use the <a href="#VIDIOC-G-FREQUENCY"><code class="CONSTANT">VIDIOC_G_FREQUENCY</code></a> and <a href="#VIDIOC-G-FREQUENCY"><code class="CONSTANT">VIDIOC_S_FREQUENCY</code></a>
ioctl which both take a pointer to a struct&nbsp;<a href="#V4L2-FREQUENCY">v4l2_frequency</a>. These ioctls
are used for TV and radio devices alike. Drivers must support both
ioctls when the tuner or modulator ioctls are supported, or
when the device is a radio device.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN445">1.6.4. Satellite Receivers</a></h3><p>To be discussed. See also 
proposals by Peter Schlaf, video4linux-list@redhat.com on 23 Oct 2002,
subject: "Re: [V4L] Re: v4l2 api".</p></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="STANDARD">1.7. Video Standards</a></h2><p>Video devices typically support one or more different video
standards or variations of standards. Each video input and output may
support another set of standards. This set is reported by the
<code class="STRUCTFIELD">std</code> field of struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a> and
struct&nbsp;<a href="#V4L2-OUTPUT">v4l2_output</a> returned by the <a href="#VIDIOC-ENUMINPUT"><code class="CONSTANT">VIDIOC_ENUMINPUT</code></a> and
<a href="#VIDIOC-ENUMOUTPUT"><code class="CONSTANT">VIDIOC_ENUMOUTPUT</code></a> ioctl, respectively.</p><p>V4L2 defines one bit for each analog video standard
currently in use worldwide, and sets aside bits for driver defined
standards, e.&nbsp;g. hybrid standards to watch NTSC video tapes on PAL TVs
and vice versa. Applications can use the predefined bits to select a
particular standard, although presenting the user a menu of supported
standards is preferred. To enumerate and query the attributes of the
supported standards applications use the <a href="#VIDIOC-ENUMSTD"><code class="CONSTANT">VIDIOC_ENUMSTD</code></a> ioctl.</p><p>Many of the defined standards are actually just variations
of a few major standards. The hardware may in fact not distinguish
between them, or do so internal and switch automatically. Therefore
enumerated standards also contain sets of one or more standard
bits.</p><p>Assume a hypothetic tuner capable of demodulating B/PAL,
G/PAL and I/PAL signals. The first enumerated standard is a set of B
and G/PAL, switched automatically depending on the selected radio
frequency in UHF or VHF band. Enumeration gives a "PAL-B/G" or "PAL-I"
choice. Similar a Composite input may collapse standards, enumerating
"PAL-B/G/H/I", "NTSC-M" and "SECAM-D/K".<a name="AEN463" href="#FTN.AEN463"><span class="footnote">[6]</span></a></p><p>To query and select the standard used by the current video
input or output applications call the <a href="#VIDIOC-G-STD"><code class="CONSTANT">VIDIOC_G_STD</code></a> and
<a href="#VIDIOC-G-STD"><code class="CONSTANT">VIDIOC_S_STD</code></a> ioctl, respectively. The <span class="emphasis"><i class="EMPHASIS">received</i></span>
standard can be sensed with the <a href="#VIDIOC-QUERYSTD"><code class="CONSTANT">VIDIOC_QUERYSTD</code></a> ioctl. Note parameter of all these ioctls is a pointer to a <a href="#V4L2-STD-ID">v4l2_std_id</a> type (a standard set), <span class="emphasis"><i class="EMPHASIS">not</i></span> an index into the standard enumeration.<a name="AEN475" href="#FTN.AEN475"><span class="footnote">[7]</span></a> Drivers must implement all video standard ioctls
when the device has one or more video inputs or outputs.</p><p>Special rules apply to USB cameras where the notion of video
standards makes little sense. More generally any capture device,
output devices accordingly, which is </p><p></p><ul><li><p>incapable of capturing fields or frames at the nominal
rate of the video standard, or</p></li><li><p>where <a href="#BUFFER">timestamps</a> refer
to the instant the field or frame was received by the driver, not the
capture time, or</p></li><li><p>where <a href="#BUFFER">sequence numbers</a>
refer to the frames received by the driver, not the captured
frames.</p></li></ul> Here the driver shall set the
<code class="STRUCTFIELD">std</code> field of struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a> and struct&nbsp;<a href="#V4L2-OUTPUT">v4l2_output</a>
to zero, the <code class="CONSTANT">VIDIOC_G_STD</code>,
<code class="CONSTANT">VIDIOC_S_STD</code>,
<code class="CONSTANT">VIDIOC_QUERYSTD</code> and
<code class="CONSTANT">VIDIOC_ENUMSTD</code> ioctls shall return the
<span class="ERRORCODE">EINVAL</span> error code.<a name="AEN507" href="#FTN.AEN507"><span class="footnote">[8]</span></a><p></p><div class="EXAMPLE"><a name="AEN510"></a><p><b>Example 1-5. Information about the current video standard</b></p><pre class="PROGRAMLISTING"><a href="#V4L2-STD-ID">v4l2_std_id</a> std_id;
struct&nbsp;<a href="#V4L2-STANDARD">v4l2_standard</a> standard;

if (-1 == ioctl (fd, <a href="#VIDIOC-G-STD"><code class="CONSTANT">VIDIOC_G_STD</code></a>, &amp;std_id)) {
        /* Note when VIDIOC_ENUMSTD always returns EINVAL this
           is no video device or it falls under the USB exception,
           and VIDIOC_G_STD returning EINVAL is no error. */

        perror ("VIDIOC_G_STD");
        exit (EXIT_FAILURE);
}

memset (&amp;standard, 0, sizeof (standard));
standard.index = 0;

while (0 == ioctl (fd, <a href="#VIDIOC-ENUMSTD"><code class="CONSTANT">VIDIOC_ENUMSTD</code></a>, &amp;standard)) {
        if (standard.id &amp; std_id) {
               printf ("Current video standard: %s\n", standard.name);
               exit (EXIT_SUCCESS);
        }

        standard.index++;
}

/* EINVAL indicates the end of the enumeration, which cannot be
   empty unless this device falls under the USB exception. */

if (errno == EINVAL || standard.index == 0) {
        perror ("VIDIOC_ENUMSTD");
        exit (EXIT_FAILURE);
}
      </pre></div><div class="EXAMPLE"><a name="AEN519"></a><p><b>Example 1-6. Listing the video standards supported by the current
input</b></p><pre class="PROGRAMLISTING">struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a> input;
struct&nbsp;<a href="#V4L2-STANDARD">v4l2_standard</a> standard;

memset (&amp;input, 0, sizeof (input));

if (-1 == ioctl (fd, <a href="#VIDIOC-G-INPUT"><code class="CONSTANT">VIDIOC_G_INPUT</code></a>, &amp;input.index)) {
        perror ("VIDIOC_G_INPUT");
        exit (EXIT_FAILURE);
}

if (-1 == ioctl (fd, <a href="#VIDIOC-ENUMINPUT"><code class="CONSTANT">VIDIOC_ENUMINPUT</code></a>, &amp;input)) {
        perror ("VIDIOC_ENUM_INPUT");
        exit (EXIT_FAILURE);
}

printf ("Current input %s supports:\n", input.name);

memset (&amp;standard, 0, sizeof (standard));
standard.index = 0;

while (0 == ioctl (fd, <a href="#VIDIOC-ENUMSTD"><code class="CONSTANT">VIDIOC_ENUMSTD</code></a>, &amp;standard)) {
        if (standard.id &amp; input.std)
                printf ("%s\n", standard.name);

        standard.index++;
}

/* EINVAL indicates the end of the enumeration, which cannot be
   empty unless this device falls under the USB exception. */

if (errno != EINVAL || standard.index == 0) {
        perror ("VIDIOC_ENUMSTD");
        exit (EXIT_FAILURE);
}
      </pre></div><div class="EXAMPLE"><a name="AEN530"></a><p><b>Example 1-7. Selecting a new video standard</b></p><pre class="PROGRAMLISTING">struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a> input;
<a href="#V4L2-STD-ID">v4l2_std_id</a> std_id;

memset (&amp;input, 0, sizeof (input));

if (-1 == ioctl (fd, <a href="#VIDIOC-G-INPUT"><code class="CONSTANT">VIDIOC_G_INPUT</code></a>, &amp;input.index)) {
        perror ("VIDIOC_G_INPUT");
        exit (EXIT_FAILURE);
}

if (-1 == ioctl (fd, <a href="#VIDIOC-ENUMINPUT"><code class="CONSTANT">VIDIOC_ENUMINPUT</code></a>, &amp;input)) {
        perror ("VIDIOC_ENUM_INPUT");
        exit (EXIT_FAILURE);
}

if (0 == (input.std &amp; V4L2_STD_PAL_BG)) {
        fprintf (stderr, "Oops. B/G PAL is not supported.\n");
        exit (EXIT_FAILURE);
}

/* Note this is also supposed to work when only B
   <span class="emphasis"><i class="EMPHASIS">or</i></span> G/PAL is supported. */

std_id = V4L2_STD_PAL_BG;

if (-1 == ioctl (fd, <a href="#VIDIOC-G-STD"><code class="CONSTANT">VIDIOC_S_STD</code></a>, &amp;std_id)) {
        perror ("VIDIOC_S_STD");
        exit (EXIT_FAILURE);
}
      </pre></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="CONTROL">1.8. User Controls</a></h2><p>Devices typically have a number of user-settable controls
such as brightness, saturation and so on, which would be presented to
the user on a graphical user interface. But, different devices
will have different controls available, and furthermore, the range of
possible values, and the default value will vary from device to
device. The control ioctls provide the information and a mechanism to
create a nice user interface for these controls that will work
correctly with any device.</p><p>All controls are accessed using an ID value. V4L2 defines
several IDs for specific purposes. Drivers can also implement their
own custom controls using <code class="CONSTANT">V4L2_CID_PRIVATE_BASE</code>
and higher values. The pre-defined control IDs have the prefix
<code class="CONSTANT">V4L2_CID_</code>, and are listed in <a href="#CONTROL-ID">Table 1-1</a>. The ID is used when querying the attributes of
a control, and when getting or setting the current value.</p><p>Generally applications should present controls to the user
without assumptions about their purpose. Each control comes with a
name string the user is supposed to understand. When the purpose is
non-intuitive the driver writer should provide a user manual, a user
interface plug-in or a driver specific panel application. Predefined
IDs were introduced to change a few controls programmatically, for
example to mute a device during a channel switch.</p><p>Drivers may enumerate different controls after switching
the current video input or output, tuner or modulator, or audio input
or output. Different in the sense of other bounds, another default and
current value, step size or other menu items. A control with a certain
<span class="emphasis"><i class="EMPHASIS">custom</i></span> ID can also change name and
type.<a name="AEN552" href="#FTN.AEN552"><span class="footnote">[9]</span></a> Control values are stored globally, they do not
change when switching except to stay within the reported bounds. They
also do not change e.&nbsp;g. when the device is opened or closed, when the
tuner radio frequency is changed or generally never without
application request. Since V4L2 specifies no event mechanism, panel
applications intended to cooperate with other panel applications (be
they built into a larger application, as a TV viewer) may need to
regularly poll control values to update their user
interface.<a name="AEN555" href="#FTN.AEN555"><span class="footnote">[10]</span></a></p><div class="TABLE"><a name="CONTROL-ID"></a><p><b>Table 1-1. Control IDs</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><thead><tr><th>ID</th><th>Type</th><th>Description</th></tr></thead><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_CID_BASE</code></td><td>&nbsp;</td><td>First predefined ID, equal to
<code class="CONSTANT">V4L2_CID_BRIGHTNESS</code>.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_USER_BASE</code></td><td>&nbsp;</td><td>Synonym of <code class="CONSTANT">V4L2_CID_BASE</code>.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_BRIGHTNESS</code></td><td>integer</td><td>Picture brightness, or more precisely, the black
level.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_CONTRAST</code></td><td>integer</td><td>Picture contrast or luma gain.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_SATURATION</code></td><td>integer</td><td>Picture color saturation or chroma gain.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_HUE</code></td><td>integer</td><td>Hue or color balance.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_AUDIO_VOLUME</code></td><td>integer</td><td>Overall audio volume. Note some drivers also
provide an OSS or ALSA mixer interface.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_AUDIO_BALANCE</code></td><td>integer</td><td>Audio stereo balance. Minimum corresponds to all
the way left, maximum to right.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_AUDIO_BASS</code></td><td>integer</td><td>Audio bass adjustment.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_AUDIO_TREBLE</code></td><td>integer</td><td>Audio treble adjustment.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_AUDIO_MUTE</code></td><td>boolean</td><td>Mute audio, i.&nbsp;e. set the volume to zero, however
without affecting <code class="CONSTANT">V4L2_CID_AUDIO_VOLUME</code>. Like
ALSA drivers, V4L2 drivers must mute at load time to avoid excessive
noise. Actually the entire device should be reset to a low power
consumption state.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_AUDIO_LOUDNESS</code></td><td>boolean</td><td>Loudness mode (bass boost).</td></tr><tr><td><code class="CONSTANT">V4L2_CID_BLACK_LEVEL</code></td><td>integer</td><td>Another name for brightness (not a synonym of
<code class="CONSTANT">V4L2_CID_BRIGHTNESS</code>). This control is deprecated
and should not be used in new drivers and applications.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_AUTO_WHITE_BALANCE</code></td><td>boolean</td><td>Automatic white balance (cameras).</td></tr><tr><td><code class="CONSTANT">V4L2_CID_DO_WHITE_BALANCE</code></td><td>button</td><td>This is an action control. When set (the value is
ignored), the device will do a white balance and then hold the current
setting. Contrast this with the boolean
<code class="CONSTANT">V4L2_CID_AUTO_WHITE_BALANCE</code>, which, when
activated, keeps adjusting the white balance.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_RED_BALANCE</code></td><td>integer</td><td>Red chroma balance.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_BLUE_BALANCE</code></td><td>integer</td><td>Blue chroma balance.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_GAMMA</code></td><td>integer</td><td>Gamma adjust.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_WHITENESS</code></td><td>integer</td><td>Whiteness for grey-scale devices. This is a synonym
for <code class="CONSTANT">V4L2_CID_GAMMA</code>. This control is deprecated
and should not be used in new drivers and applications.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_EXPOSURE</code></td><td>integer</td><td>Exposure (cameras). [Unit?]</td></tr><tr><td><code class="CONSTANT">V4L2_CID_AUTOGAIN</code></td><td>boolean</td><td>Automatic gain/exposure control.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_GAIN</code></td><td>integer</td><td>Gain control.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_HFLIP</code></td><td>boolean</td><td>Mirror the picture horizontally.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_VFLIP</code></td><td>boolean</td><td>Mirror the picture vertically.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_HCENTER_DEPRECATED</code> (formerly <code class="CONSTANT">V4L2_CID_HCENTER</code>)</td><td>integer</td><td>Horizontal image centering. This control is
deprecated. New drivers and applications should use the <a href="#CAMERA-CONTROLS">Camera class controls</a>
<code class="CONSTANT">V4L2_CID_PAN_ABSOLUTE</code>,
<code class="CONSTANT">V4L2_CID_PAN_RELATIVE</code> and
<code class="CONSTANT">V4L2_CID_PAN_RESET</code> instead.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_VCENTER_DEPRECATED</code>
            (formerly <code class="CONSTANT">V4L2_CID_VCENTER</code>)</td><td>integer</td><td>Vertical image centering. Centering is intended to
<span class="emphasis"><i class="EMPHASIS">physically</i></span> adjust cameras. For image cropping see
<a href="#CROP">Section 1.11</a>, for clipping <a href="#OVERLAY">Section 4.2</a>. This
control is deprecated. New drivers and applications should use the
<a href="#CAMERA-CONTROLS">Camera class controls</a>
<code class="CONSTANT">V4L2_CID_TILT_ABSOLUTE</code>,
<code class="CONSTANT">V4L2_CID_TILT_RELATIVE</code> and
<code class="CONSTANT">V4L2_CID_TILT_RESET</code> instead.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_POWER_LINE_FREQUENCY</code></td><td>integer</td><td>Enables a power line frequency filter to avoid
flicker. Possible values are:
<code class="CONSTANT">V4L2_CID_POWER_LINE_FREQUENCY_DISABLED</code> (0),
<code class="CONSTANT">V4L2_CID_POWER_LINE_FREQUENCY_50HZ</code> (1) and
<code class="CONSTANT">V4L2_CID_POWER_LINE_FREQUENCY_60HZ</code> (2).</td></tr><tr><td><code class="CONSTANT">V4L2_CID_HUE_AUTO</code></td><td>boolean</td><td>Enables automatic hue control by the device. The
effect of setting <code class="CONSTANT">V4L2_CID_HUE</code> while automatic
hue control is enabled is undefined, drivers should ignore such
request.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_WHITE_BALANCE_TEMPERATURE</code></td><td>integer</td><td>This control specifies the white balance settings
as a color temperature in Kelvin. A driver should have a minimum of
2800 (incandescent) to 6500 (daylight). For more information about
color temperature see <a href="http://en.wikipedia.org/wiki/Color_temperature" target="_top">Wikipedia</a>.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_SHARPNESS</code></td><td>integer</td><td>Adjusts the sharpness filters in a camera. The
minimum value disables the filters, higher values give a sharper
picture.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_BACKLIGHT_COMPENSATION</code></td><td>integer</td><td>Adjusts the backlight compensation in a camera. The
minimum value disables backlight compensation.</td></tr><tr><td><code class="CONSTANT">V4L2_CID_LASTP1</code></td><td>&nbsp;</td><td>End of the predefined control IDs (currently
<code class="CONSTANT">V4L2_CID_BACKLIGHT_COMPENSATION</code> + 1).</td></tr><tr><td><code class="CONSTANT">V4L2_CID_PRIVATE_BASE</code></td><td>&nbsp;</td><td>ID of the first custom (driver specific) control.
Applications depending on particular custom controls should check the
driver name and version, see <a href="#QUERYCAP">Section 1.2</a>.</td></tr></tbody></table></div><p>Applications can enumerate the available controls with the
<a href="#VIDIOC-QUERYCTRL"><code class="CONSTANT">VIDIOC_QUERYCTRL</code></a> and <a href="#VIDIOC-QUERYCTRL"><code class="CONSTANT">VIDIOC_QUERYMENU</code></a> ioctls, get and set a
control value with the <a href="#VIDIOC-G-CTRL"><code class="CONSTANT">VIDIOC_G_CTRL</code></a> and <a href="#VIDIOC-G-CTRL"><code class="CONSTANT">VIDIOC_S_CTRL</code></a> ioctls.
Drivers must implement <code class="CONSTANT">VIDIOC_QUERYCTRL</code>,
<code class="CONSTANT">VIDIOC_G_CTRL</code> and
<code class="CONSTANT">VIDIOC_S_CTRL</code> when the device has one or more
controls, <code class="CONSTANT">VIDIOC_QUERYMENU</code> when it has one or
more menu type controls.</p><div class="EXAMPLE"><a name="AEN778"></a><p><b>Example 1-8. Enumerating all controls</b></p><pre class="PROGRAMLISTING">struct&nbsp;<a href="#V4L2-QUERYCTRL">v4l2_queryctrl</a> queryctrl;
struct&nbsp;<a href="#V4L2-QUERYMENU">v4l2_querymenu</a> querymenu;

static void
enumerate_menu (void)
{
        printf ("  Menu items:\n");

        memset (&amp;querymenu, 0, sizeof (querymenu));
        querymenu.id = queryctrl.id;

        for (querymenu.index = queryctrl.minimum;
             querymenu.index &lt;= queryctrl.maximum;
              querymenu.index++) {
                if (0 == ioctl (fd, <a href="#VIDIOC-QUERYCTRL"><code class="CONSTANT">VIDIOC_QUERYMENU</code></a>, &amp;querymenu)) {
                        printf ("  %s\n", querymenu.name);
                } else {
                        perror ("VIDIOC_QUERYMENU");
                        exit (EXIT_FAILURE);
                }
        }
}

memset (&amp;queryctrl, 0, sizeof (queryctrl));

for (queryctrl.id = V4L2_CID_BASE;
     queryctrl.id &lt; V4L2_CID_LASTP1;
     queryctrl.id++) {
        if (0 == ioctl (fd, <a href="#VIDIOC-QUERYCTRL"><code class="CONSTANT">VIDIOC_QUERYCTRL</code></a>, &amp;queryctrl)) {
                if (queryctrl.flags &amp; V4L2_CTRL_FLAG_DISABLED)
                        continue;

                printf ("Control %s\n", queryctrl.name);

                if (queryctrl.type == V4L2_CTRL_TYPE_MENU)
                        enumerate_menu ();
        } else {
                if (errno == EINVAL)
                        continue;

                perror ("VIDIOC_QUERYCTRL");
                exit (EXIT_FAILURE);
        }
}

for (queryctrl.id = V4L2_CID_PRIVATE_BASE;;
     queryctrl.id++) {
        if (0 == ioctl (fd, <a href="#VIDIOC-QUERYCTRL"><code class="CONSTANT">VIDIOC_QUERYCTRL</code></a>, &amp;queryctrl)) {
                if (queryctrl.flags &amp; V4L2_CTRL_FLAG_DISABLED)
                        continue;

                printf ("Control %s\n", queryctrl.name);

                if (queryctrl.type == V4L2_CTRL_TYPE_MENU)
                        enumerate_menu ();
        } else {
                if (errno == EINVAL)
                        break;

                perror ("VIDIOC_QUERYCTRL");
                exit (EXIT_FAILURE);
        }
}</pre></div><div class="EXAMPLE"><a name="AEN789"></a><p><b>Example 1-9. Changing controls</b></p><pre class="PROGRAMLISTING">struct&nbsp;<a href="#V4L2-QUERYCTRL">v4l2_queryctrl</a> queryctrl;
struct&nbsp;<a href="#V4L2-CONTROL">v4l2_control</a> control;

memset (&amp;queryctrl, 0, sizeof (queryctrl));
queryctrl.id = V4L2_CID_BRIGHTNESS;

if (-1 == ioctl (fd, <a href="#VIDIOC-QUERYCTRL"><code class="CONSTANT">VIDIOC_QUERYCTRL</code></a>, &amp;queryctrl)) {
        if (errno != EINVAL) {
                perror ("VIDIOC_QUERYCTRL");
                exit (EXIT_FAILURE);
        } else {
                printf ("V4L2_CID_BRIGHTNESS is not supported\n");
        }
} else if (queryctrl.flags &amp; V4L2_CTRL_FLAG_DISABLED) {
        printf ("V4L2_CID_BRIGHTNESS is not supported\n");
} else {
        memset (&amp;control, 0, sizeof (control));
        control.id = V4L2_CID_BRIGHTNESS;
        control.value = queryctrl.default_value;

        if (-1 == ioctl (fd, <a href="#VIDIOC-G-CTRL"><code class="CONSTANT">VIDIOC_S_CTRL</code></a>, &amp;control)) {
                perror ("VIDIOC_S_CTRL");
                exit (EXIT_FAILURE);
        }
}

memset (&amp;control, 0, sizeof (control));
control.id = V4L2_CID_CONTRAST;

if (0 == ioctl (fd, <a href="#VIDIOC-G-CTRL"><code class="CONSTANT">VIDIOC_G_CTRL</code></a>, &amp;control)) {
        control.value += 1;

        /* The driver may clamp the value or return ERANGE, ignored here */

        if (-1 == ioctl (fd, <a href="#VIDIOC-G-CTRL"><code class="CONSTANT">VIDIOC_S_CTRL</code></a>, &amp;control)
            &amp;&amp; errno != ERANGE) {
                perror ("VIDIOC_S_CTRL");
                exit (EXIT_FAILURE);
        }
/* Ignore if V4L2_CID_CONTRAST is unsupported */
} else if (errno != EINVAL) {
        perror ("VIDIOC_G_CTRL");
        exit (EXIT_FAILURE);
}

control.id = V4L2_CID_AUDIO_MUTE;
control.value = TRUE; /* silence */

/* Errors ignored */
ioctl (fd, VIDIOC_S_CTRL, &amp;control);</pre></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="EXTENDED-CONTROLS">1.9. Extended Controls</a></h2><div class="SECTION"><h3 class="SECTION"><a name="AEN804">1.9.1. Introduction</a></h3><p>The control mechanism as originally designed was meant
to be used for user settings (brightness, saturation, etc). However,
it turned out to be a very useful model for implementing more
complicated driver APIs where each driver implements only a subset of
a larger API.</p><p>The MPEG encoding API was the driving force behind
designing and implementing this extended control mechanism: the MPEG
standard is quite large and the currently supported hardware MPEG
encoders each only implement a subset of this standard. Further more,
many parameters relating to how the video is encoded into an MPEG
stream are specific to the MPEG encoding chip since the MPEG standard
only defines the format of the resulting MPEG stream, not how the
video is actually encoded into that format.</p><p>Unfortunately, the original control API lacked some
features needed for these new uses and so it was extended into the
(not terribly originally named) extended control API.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN809">1.9.2. The Extended Control API</a></h3><p>Three new ioctls are available: <a href="#VIDIOC-G-EXT-CTRLS"><code class="CONSTANT">VIDIOC_G_EXT_CTRLS</code></a>,
<a href="#VIDIOC-G-EXT-CTRLS"><code class="CONSTANT">VIDIOC_S_EXT_CTRLS</code></a> and <a href="#VIDIOC-G-EXT-CTRLS"><code class="CONSTANT">VIDIOC_TRY_EXT_CTRLS</code></a>. These ioctls act on
arrays of controls (as opposed to the <a href="#VIDIOC-G-CTRL"><code class="CONSTANT">VIDIOC_G_CTRL</code></a> and
<a href="#VIDIOC-G-CTRL"><code class="CONSTANT">VIDIOC_S_CTRL</code></a> ioctls that act on a single control). This is needed
since it is often required to atomically change several controls at
once.</p><p>Each of the new ioctls expects a pointer to a
struct&nbsp;<a href="#V4L2-EXT-CONTROLS">v4l2_ext_controls</a>. This structure contains a pointer to the control
array, a count of the number of controls in that array and a control
class. Control classes are used to group similar controls into a
single class. For example, control class
<code class="CONSTANT">V4L2_CTRL_CLASS_USER</code> contains all user controls
(i.&nbsp;e. all controls that can also be set using the old
<code class="CONSTANT">VIDIOC_S_CTRL</code> ioctl). Control class
<code class="CONSTANT">V4L2_CTRL_CLASS_MPEG</code> contains all controls
relating to MPEG encoding, etc.</p><p>All controls in the control array must belong to the
specified control class. An error is returned if this is not the
case.</p><p>It is also possible to use an empty control array (count
== 0) to check whether the specified control class is
supported.</p><p>The control array is a struct&nbsp;<a href="#V4L2-EXT-CONTROL">v4l2_ext_control</a> array. The
<code class="STRUCTNAME">v4l2_ext_control</code> structure is very similar to
struct&nbsp;<a href="#V4L2-CONTROL">v4l2_control</a>, except for the fact that it also allows for 64-bit
values and pointers to be passed (although the latter is not yet used
anywhere).</p><p>It is important to realize that due to the flexibility of
controls it is necessary to check whether the control you want to set
actually is supported in the driver and what the valid range of values
is. So use the <a href="#VIDIOC-QUERYCTRL"><code class="CONSTANT">VIDIOC_QUERYCTRL</code></a> and <a href="#VIDIOC-QUERYCTRL"><code class="CONSTANT">VIDIOC_QUERYMENU</code></a> ioctls to
check this. Also note that it is possible that some of the menu
indices in a control of type <code class="CONSTANT">V4L2_CTRL_TYPE_MENU</code>
may not be supported (<code class="CONSTANT">VIDIOC_QUERYMENU</code> will
return an error). A good example is the list of supported MPEG audio
bitrates. Some drivers only support one or two bitrates, others
support a wider range.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN840">1.9.3. Enumerating Extended Controls</a></h3><p>The recommended way to enumerate over the extended
controls is by using <a href="#VIDIOC-QUERYCTRL"><code class="CONSTANT">VIDIOC_QUERYCTRL</code></a> in combination with the
<code class="CONSTANT">V4L2_CTRL_FLAG_NEXT_CTRL</code> flag:</p><div class="INFORMALEXAMPLE"><p></p><a name="AEN846"></a><pre class="PROGRAMLISTING">struct&nbsp;<a href="#V4L2-QUERYCTRL">v4l2_queryctrl</a> qctrl;

qctrl.id = V4L2_CTRL_FLAG_NEXT_CTRL;
while (0 == ioctl (fd, <a href="#VIDIOC-QUERYCTRL"><code class="CONSTANT">VIDIOC_QUERYCTRL</code></a>, &amp;qctrl)) {
        /* ... */
        qctrl.id |= V4L2_CTRL_FLAG_NEXT_CTRL;
}</pre><p></p></div><p>The initial control ID is set to 0 ORed with the
<code class="CONSTANT">V4L2_CTRL_FLAG_NEXT_CTRL</code> flag. The
<code class="CONSTANT">VIDIOC_QUERYCTRL</code> ioctl will return the first
control with a higher ID than the specified one. When no such controls
are found an error is returned.</p><p>If you want to get all controls within a specific control
class, then you can set the initial
<code class="STRUCTFIELD">qctrl.id</code> value to the control class and add
an extra check to break out of the loop when a control of another
control class is found:</p><div class="INFORMALEXAMPLE"><p></p><a name="AEN856"></a><pre class="PROGRAMLISTING">qctrl.id = V4L2_CTRL_CLASS_MPEG | V4L2_CTRL_FLAG_NEXT_CTRL;
while (0 == ioctl (fd, <a href="#VIDIOC-QUERYCTRL"><code class="CONSTANT">VIDIOC_QUERYCTRL</code></a>, &amp;qctrl)) {
        if (V4L2_CTRL_ID2CLASS (qctrl.id) != V4L2_CTRL_CLASS_MPEG)
                break;
                /* ... */
                qctrl.id |= V4L2_CTRL_FLAG_NEXT_CTRL;
        }</pre><p></p></div><p>The 32-bit <code class="STRUCTFIELD">qctrl.id</code> value is
subdivided into three bit ranges: the top 4 bits are reserved for
flags (e.&nbsp;g. <code class="CONSTANT">V4L2_CTRL_FLAG_NEXT_CTRL</code>) and are not
actually part of the ID. The remaining 28 bits form the control ID, of
which the most significant 12 bits define the control class and the
least significant 16 bits identify the control within the control
class. It is guaranteed that these last 16 bits are always non-zero
for controls. The range of 0x1000 and up are reserved for
driver-specific controls. The macro
<code class="CONSTANT">V4L2_CTRL_ID2CLASS(id)</code> returns the control class
ID based on a control ID.</p><p>If the driver does not support extended controls, then
<code class="CONSTANT">VIDIOC_QUERYCTRL</code> will fail when used in
combination with <code class="CONSTANT">V4L2_CTRL_FLAG_NEXT_CTRL</code>. In
that case the old method of enumerating control should be used (see
1.8). But if it is supported, then it is guaranteed to enumerate over
all controls, including driver-private controls.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN867">1.9.4. Creating Control Panels</a></h3><p>It is possible to create control panels for a graphical
user interface where the user can select the various controls.
Basically you will have to iterate over all controls using the method
described above. Each control class starts with a control of type
<code class="CONSTANT">V4L2_CTRL_TYPE_CTRL_CLASS</code>.
<code class="CONSTANT">VIDIOC_QUERYCTRL</code> will return the name of this
control class which can be used as the title of a tab page within a
control panel.</p><p>The flags field of struct&nbsp;<a href="#V4L2-QUERYCTRL">v4l2_queryctrl</a> also contains hints on
the behavior of the control. See the <a href="#VIDIOC-QUERYCTRL"><code class="CONSTANT">VIDIOC_QUERYCTRL</code></a> documentation
for more details.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="MPEG-CONTROLS">1.9.5. MPEG Control Reference</a></h3><p>Below all controls within the MPEG control class are
described. First the generic controls, then controls specific for
certain hardware.</p><div class="SECTION"><hr><h4 class="SECTION"><a name="AEN879">1.9.5.1. Generic MPEG Controls</a></h4><div class="TABLE"><a name="MPEG-CONTROL-ID"></a><p><b>Table 1-2. MPEG Control IDs</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="7%"><col title="C2" width="40%"><col title="C3" width="13%"><col title="C4" width="40%"></colgroup><thead><tr><th colspan="2" align="LEFT">ID</th><th align="LEFT">Type</th><td>&nbsp;</td></tr><tr><th>&nbsp;</th><th colspan="3" align="LEFT">Description</th></tr></thead><tbody valign="TOP"><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_CLASS</code>&nbsp;</td><td>class</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">The MPEG class
descriptor. Calling <a href="#VIDIOC-QUERYCTRL"><code class="CONSTANT">VIDIOC_QUERYCTRL</code></a> for this control will return a
description of this control class. This description can be used as the
caption of a Tab page in a GUI, for example.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_STREAM_TYPE</code>&nbsp;</td><td>enum</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">The MPEG-1, -2 or -4
output stream type. One cannot assume anything here. Each hardware
MPEG encoder tends to support different subsets of the available MPEG
stream types. The currently defined stream types are:</td></tr><tr><td>&nbsp;</td><td colspan="3"><table class="CALSTABLE" border="0"><colgroup><col><col></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_MPEG_STREAM_TYPE_MPEG2_PS</code>&nbsp;</td><td>MPEG-2 program stream</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_STREAM_TYPE_MPEG2_TS</code>&nbsp;</td><td>MPEG-2 transport stream</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_STREAM_TYPE_MPEG1_SS</code>&nbsp;</td><td>MPEG-1 system stream</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_STREAM_TYPE_MPEG2_DVD</code>&nbsp;</td><td>MPEG-2 DVD-compatible stream</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_STREAM_TYPE_MPEG1_VCD</code>&nbsp;</td><td>MPEG-1 VCD-compatible stream</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_STREAM_TYPE_MPEG2_SVCD</code>&nbsp;</td><td>MPEG-2 SVCD-compatible stream</td></tr></tbody></table></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_STREAM_PID_PMT</code>&nbsp;</td><td>integer</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Program Map Table
Packet ID for the MPEG transport stream (default 16)</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_STREAM_PID_AUDIO</code>&nbsp;</td><td>integer</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Audio Packet ID for
the MPEG transport stream (default 256)</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_STREAM_PID_VIDEO</code>&nbsp;</td><td>integer</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Video Packet ID for
the MPEG transport stream (default 260)</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_STREAM_PID_PCR</code>&nbsp;</td><td>integer</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Packet ID for the
MPEG transport stream carrying PCR fields (default 259)</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_STREAM_PES_ID_AUDIO</code>&nbsp;</td><td>integer</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Audio ID for MPEG
PES</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_STREAM_PES_ID_VIDEO</code>&nbsp;</td><td>integer</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Video ID for MPEG
PES</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_STREAM_VBI_FMT</code>&nbsp;</td><td>enum</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Some cards can embed
VBI data (e.&nbsp;g. Closed Caption, Teletext) into the MPEG stream. This
control selects whether VBI data should be embedded, and if so, what
embedding method should be used. The list of possible VBI formats
depends on the driver. The currently defined VBI format types
are:</td></tr><tr><td>&nbsp;</td><td colspan="3"><table class="CALSTABLE" border="0"><colgroup><col><col></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_MPEG_STREAM_VBI_FMT_NONE</code>&nbsp;</td><td>No VBI in the MPEG stream</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_STREAM_VBI_FMT_IVTV</code>&nbsp;</td><td>VBI in private packets, IVTV format (documented
in the kernel sources in the file <tt class="FILENAME">Documentation/video4linux/cx2341x/README.vbi</tt>)</td></tr></tbody></table></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ</code>&nbsp;</td><td>enum</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">MPEG Audio sampling
frequency. Possible values are:</td></tr><tr><td>&nbsp;</td><td colspan="3"><table class="CALSTABLE" border="0"><colgroup><col><col></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_SAMPLING_FREQ_44100</code>&nbsp;</td><td>44.1 kHz</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000</code>&nbsp;</td><td>48 kHz</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_SAMPLING_FREQ_32000</code>&nbsp;</td><td>32 kHz</td></tr></tbody></table></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_AUDIO_ENCODING</code>&nbsp;</td><td>enum</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">MPEG Audio encoding.
Possible values are:</td></tr><tr><td>&nbsp;</td><td colspan="3"><table class="CALSTABLE" border="0"><colgroup><col><col></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_ENCODING_LAYER_1</code>&nbsp;</td><td>MPEG Layer I encoding</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_ENCODING_LAYER_2</code>&nbsp;</td><td>MPEG Layer II encoding</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_ENCODING_LAYER_3</code>&nbsp;</td><td>MPEG Layer III encoding</td></tr></tbody></table></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_AUDIO_L1_BITRATE</code>&nbsp;</td><td>enum</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Layer I bitrate.
Possible values are:</td></tr><tr><td>&nbsp;</td><td colspan="3"><table class="CALSTABLE" border="0"><colgroup><col><col></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L1_BITRATE_32K</code>&nbsp;</td><td>32 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L1_BITRATE_64K</code>&nbsp;</td><td>64 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L1_BITRATE_96K</code>&nbsp;</td><td>96 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L1_BITRATE_128K</code>&nbsp;</td><td>128 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L1_BITRATE_160K</code>&nbsp;</td><td>160 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L1_BITRATE_192K</code>&nbsp;</td><td>192 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L1_BITRATE_224K</code>&nbsp;</td><td>224 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L1_BITRATE_256K</code>&nbsp;</td><td>256 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L1_BITRATE_288K</code>&nbsp;</td><td>288 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L1_BITRATE_320K</code>&nbsp;</td><td>320 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L1_BITRATE_352K</code>&nbsp;</td><td>352 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L1_BITRATE_384K</code>&nbsp;</td><td>384 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L1_BITRATE_416K</code>&nbsp;</td><td>416 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L1_BITRATE_448K</code>&nbsp;</td><td>448 kbit/s</td></tr></tbody></table></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_AUDIO_L2_BITRATE</code>&nbsp;</td><td>enum</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Layer II bitrate.
Possible values are:</td></tr><tr><td>&nbsp;</td><td colspan="3"><table class="CALSTABLE" border="0"><colgroup><col><col></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L2_BITRATE_32K</code>&nbsp;</td><td>32 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L2_BITRATE_48K</code>&nbsp;</td><td>48 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L2_BITRATE_56K</code>&nbsp;</td><td>56 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L2_BITRATE_64K</code>&nbsp;</td><td>64 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L2_BITRATE_80K</code>&nbsp;</td><td>80 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L2_BITRATE_96K</code>&nbsp;</td><td>96 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L2_BITRATE_112K</code>&nbsp;</td><td>112 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L2_BITRATE_128K</code>&nbsp;</td><td>128 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L2_BITRATE_160K</code>&nbsp;</td><td>160 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L2_BITRATE_192K</code>&nbsp;</td><td>192 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L2_BITRATE_224K</code>&nbsp;</td><td>224 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L2_BITRATE_256K</code>&nbsp;</td><td>256 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L2_BITRATE_320K</code>&nbsp;</td><td>320 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L2_BITRATE_384K</code>&nbsp;</td><td>384 kbit/s</td></tr></tbody></table></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_AUDIO_L3_BITRATE</code>&nbsp;</td><td>enum</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Layer III bitrate.
Possible values are:</td></tr><tr><td>&nbsp;</td><td colspan="3"><table class="CALSTABLE" border="0"><colgroup><col><col></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L3_BITRATE_32K</code>&nbsp;</td><td>32 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L3_BITRATE_40K</code>&nbsp;</td><td>40 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L3_BITRATE_48K</code>&nbsp;</td><td>48 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L3_BITRATE_56K</code>&nbsp;</td><td>56 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L3_BITRATE_64K</code>&nbsp;</td><td>64 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L3_BITRATE_80K</code>&nbsp;</td><td>80 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L3_BITRATE_96K</code>&nbsp;</td><td>96 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L3_BITRATE_112K</code>&nbsp;</td><td>112 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L3_BITRATE_128K</code>&nbsp;</td><td>128 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L3_BITRATE_160K</code>&nbsp;</td><td>160 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L3_BITRATE_192K</code>&nbsp;</td><td>192 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L3_BITRATE_224K</code>&nbsp;</td><td>224 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L3_BITRATE_256K</code>&nbsp;</td><td>256 kbit/s</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_L3_BITRATE_320K</code>&nbsp;</td><td>320 kbit/s</td></tr></tbody></table></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_AUDIO_MODE</code>&nbsp;</td><td>enum</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">MPEG Audio mode.
Possible values are:</td></tr><tr><td>&nbsp;</td><td colspan="3"><table class="CALSTABLE" border="0"><colgroup><col><col></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_MODE_STEREO</code>&nbsp;</td><td>Stereo</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_MODE_JOINT_STEREO</code>&nbsp;</td><td>Joint Stereo</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_MODE_DUAL</code>&nbsp;</td><td>Bilingual</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_MODE_MONO</code>&nbsp;</td><td>Mono</td></tr></tbody></table></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_AUDIO_MODE_EXTENSION</code>&nbsp;</td><td>enum</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Joint Stereo
audio mode extension. In Layer I and II they indicate which subbands
are in intensity stereo. All other subbands are coded in stereo. Layer
III is not (yet) supported. Possible values
are:</td></tr><tr><td>&nbsp;</td><td colspan="3"><table class="CALSTABLE" border="0"><colgroup><col><col></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_4</code>&nbsp;</td><td>Subbands 4-31 in intensity stereo</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_8</code>&nbsp;</td><td>Subbands 8-31 in intensity stereo</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_12</code>&nbsp;</td><td>Subbands 12-31 in intensity stereo</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_16</code>&nbsp;</td><td>Subbands 16-31 in intensity stereo</td></tr></tbody></table></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_AUDIO_EMPHASIS</code>&nbsp;</td><td>enum</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Audio Emphasis.
Possible values are:</td></tr><tr><td>&nbsp;</td><td colspan="3"><table class="CALSTABLE" border="0"><colgroup><col><col></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_EMPHASIS_NONE</code>&nbsp;</td><td>None</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_EMPHASIS_50_DIV_15_uS</code>&nbsp;</td><td>50/15 microsecond emphasis</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_EMPHASIS_CCITT_J17</code>&nbsp;</td><td>CCITT J.17</td></tr></tbody></table></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_AUDIO_CRC</code>&nbsp;</td><td>enum</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">CRC method. Possible
values are:</td></tr><tr><td>&nbsp;</td><td colspan="3"><table class="CALSTABLE" border="0"><colgroup><col><col></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_CRC_NONE</code>&nbsp;</td><td>None</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_AUDIO_CRC_CRC16</code>&nbsp;</td><td>16 bit parity check</td></tr></tbody></table></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_AUDIO_MUTE</code>&nbsp;</td><td>bool</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Mutes the audio when
capturing. This is not done by muting audio hardware, which can still
produce a slight hiss, but in the encoder itself, guaranteeing a fixed
and reproducable audio bitstream. 0 = unmuted, 1 = muted.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_VIDEO_ENCODING</code>&nbsp;</td><td>enum</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">MPEG Video encoding
method. Possible values are:</td></tr><tr><td>&nbsp;</td><td colspan="3"><table class="CALSTABLE" border="0"><colgroup><col><col></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_MPEG_VIDEO_ENCODING_MPEG_1</code>&nbsp;</td><td>MPEG-1 Video encoding</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_VIDEO_ENCODING_MPEG_2</code>&nbsp;</td><td>MPEG-2 Video encoding</td></tr></tbody></table></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_VIDEO_ASPECT</code>&nbsp;</td><td>enum</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Video aspect.
Possible values are:</td></tr><tr><td>&nbsp;</td><td colspan="3"><table class="CALSTABLE" border="0"><colgroup><col><col></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_MPEG_VIDEO_ASPECT_1x1</code>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_VIDEO_ASPECT_4x3</code>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_VIDEO_ASPECT_16x9</code>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_VIDEO_ASPECT_221x100</code>&nbsp;</td><td>&nbsp;</td></tr></tbody></table></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_VIDEO_B_FRAMES</code>&nbsp;</td><td>integer</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Number of B-Frames
(default 2)</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_VIDEO_GOP_SIZE</code>&nbsp;</td><td>integer</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">GOP size (default
12)</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_VIDEO_GOP_CLOSURE</code>&nbsp;</td><td>bool</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">GOP closure (default
1)</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_VIDEO_PULLDOWN</code>&nbsp;</td><td>bool</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Enable 3:2 pulldown
(default 0)</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_VIDEO_BITRATE_MODE</code>&nbsp;</td><td>enum</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Video bitrate mode.
Possible values are:</td></tr><tr><td>&nbsp;</td><td colspan="3"><table class="CALSTABLE" border="0"><colgroup><col><col></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_MPEG_VIDEO_BITRATE_MODE_VBR</code>&nbsp;</td><td>Variable bitrate</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_VIDEO_BITRATE_MODE_CBR</code>&nbsp;</td><td>Constant bitrate</td></tr></tbody></table></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_VIDEO_BITRATE</code>&nbsp;</td><td>integer</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Video bitrate in bits
per second.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_VIDEO_BITRATE_PEAK</code>&nbsp;</td><td>integer</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Peak video bitrate in
bits per second. Must be larger or equal to the average video bitrate.
It is ignored if the video bitrate mode is set to constant
bitrate.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_VIDEO_TEMPORAL_DECIMATION</code>&nbsp;</td><td>integer</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">For every captured
frame, skip this many subsequent frames (default 0).</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_VIDEO_MUTE</code>&nbsp;</td><td>bool</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">"Mutes" the video to a
fixed color when capturing. This is useful for testing, to produce a
fixed video bitstream. 0 = unmuted, 1 = muted.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_VIDEO_MUTE_YUV</code>&nbsp;</td><td>integer</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Sets the "mute" color
of the video. The supplied 32-bit integer is interpreted as follows (bit
0 = least significant bit):</td></tr><tr><td>&nbsp;</td><td colspan="3"><table class="CALSTABLE" border="0"><colgroup><col><col></colgroup><tbody valign="TOP"><tr><td>Bit 0:7</td><td>V chrominance information</td></tr><tr><td>Bit 8:15</td><td>U chrominance information</td></tr><tr><td>Bit 16:23</td><td>Y luminance information</td></tr><tr><td>Bit 24:31</td><td>Must be zero.</td></tr></tbody></table></td></tr></tbody></table></div></div><div class="SECTION"><hr><h4 class="SECTION"><a name="AEN1509">1.9.5.2. CX2341x MPEG Controls</a></h4><p>The following MPEG class controls deal with MPEG
encoding settings that are specific to the Conexant CX23415 and
CX23416 MPEG encoding chips.</p><div class="TABLE"><a name="CX2341X-CONTROL-ID"></a><p><b>Table 1-3. CX2341x Control IDs</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="7%"><col title="C2" width="40%"><col title="C3" width="13%"><col title="C4" width="40%"></colgroup><thead><tr><th colspan="2" align="LEFT">ID</th><th align="LEFT">Type</th><td>&nbsp;</td></tr><tr><th>&nbsp;</th><th colspan="3" align="LEFT">Description</th></tr></thead><tbody valign="TOP"><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE</code>&nbsp;</td><td>enum</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Sets the Spatial
Filter mode (default <code class="CONSTANT">MANUAL</code>). Possible values
are:</td></tr><tr><td>&nbsp;</td><td colspan="3"><table class="CALSTABLE" border="0"><colgroup><col><col></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_MANUAL</code>&nbsp;</td><td>Choose the filter manually</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_AUTO</code>&nbsp;</td><td>Choose the filter automatically</td></tr></tbody></table></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER</code>&nbsp;</td><td>integer&nbsp;(0-15)</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">The setting for the
Spatial Filter. 0 = off, 15 = maximum. (Default is 0.)</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE</code>&nbsp;</td><td>enum</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Select the algorithm
to use for the Luma Spatial Filter (default
<code class="CONSTANT">1D_HOR</code>). Possible values:</td></tr><tr><td>&nbsp;</td><td colspan="3"><table class="CALSTABLE" border="0"><colgroup><col><col></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_OFF</code>&nbsp;</td><td>No filter</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_HOR</code>&nbsp;</td><td>One-dimensional horizontal</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_VERT</code>&nbsp;</td><td>One-dimensional vertical</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_HV_SEPARABLE</code>&nbsp;</td><td>Two-dimensional separable</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_SYM_NON_SEPARABLE</code>&nbsp;</td><td>Two-dimensional symmetrical
non-separable</td></tr></tbody></table></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE</code>&nbsp;</td><td>enum</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Select the algorithm
for the Chroma Spatial Filter (default <code class="CONSTANT">1D_HOR</code>).
Possible values are:</td></tr><tr><td>&nbsp;</td><td colspan="3"><table class="CALSTABLE" border="0"><colgroup><col><col></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_OFF</code>&nbsp;</td><td>No filter</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_1D_HOR</code>&nbsp;</td><td>One-dimensional horizontal</td></tr></tbody></table></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE</code>&nbsp;</td><td>enum</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Sets the Temporal
Filter mode (default <code class="CONSTANT">MANUAL</code>). Possible values
are:</td></tr><tr><td>&nbsp;</td><td colspan="3"><table class="CALSTABLE" border="0"><colgroup><col><col></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_MANUAL</code>&nbsp;</td><td>Choose the filter manually</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_AUTO</code>&nbsp;</td><td>Choose the filter automatically</td></tr></tbody></table></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER</code>&nbsp;</td><td>integer&nbsp;(0-31)</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">The setting for the
Temporal Filter. 0 = off, 31 = maximum. (Default is 8 for full-scale
capturing and 0 for scaled capturing.)</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE</code>&nbsp;</td><td>enum</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Median Filter Type
(default <code class="CONSTANT">OFF</code>). Possible values are:</td></tr><tr><td>&nbsp;</td><td colspan="3"><table class="CALSTABLE" border="0"><colgroup><col><col></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_OFF</code>&nbsp;</td><td>No filter</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR</code>&nbsp;</td><td>Horizontal filter</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_VERT</code>&nbsp;</td><td>Vertical filter</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR_VERT</code>&nbsp;</td><td>Horizontal and vertical filter</td></tr><tr><td><code class="CONSTANT">V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_DIAG</code>&nbsp;</td><td>Diagonal filter</td></tr></tbody></table></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_BOTTOM</code>&nbsp;</td><td>integer&nbsp;(0-255)</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Threshold above which
the luminance median filter is enabled (default 0)</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_TOP</code>&nbsp;</td><td>integer&nbsp;(0-255)</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Threshold below which
the luminance median filter is enabled (default 255)</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_BOTTOM</code>&nbsp;</td><td>integer&nbsp;(0-255)</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Threshold above which
the chroma median filter is enabled (default 0)</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_TOP</code>&nbsp;</td><td>integer&nbsp;(0-255)</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Threshold below which
the chroma median filter is enabled (default 255)</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_MPEG_CX2341X_STREAM_INSERT_NAV_PACKETS</code>&nbsp;</td><td>bool</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">The CX2341X MPEG encoder
can insert one empty MPEG-2 PES packet into the stream between every
four video frames. The packet size is 2048 bytes, including the
packet_start_code_prefix and stream_id fields. The stream_id is 0xBF
(private stream 2). The payload consists of 0x00 bytes, to be filled
in by the application. 0 = do not insert, 1 = insert packets.</td></tr></tbody></table></div></div></div><div class="SECTION"><hr><h3 class="SECTION"><a name="CAMERA-CONTROLS">1.9.6. Camera Control Reference</a></h3><p>The Camera class includes controls for mechanical (or
equivalent digital) features of a device such as controllable lenses
or sensors.</p><div class="TABLE"><a name="CAMERA-CONTROL-ID"></a><p><b>Table 1-4. Camera Control IDs</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="7%"><col title="C2" width="40%"><col title="C3" width="13%"><col title="C4" width="40%"></colgroup><thead><tr><th colspan="2" align="LEFT">ID</th><th align="LEFT">Type</th><td>&nbsp;</td></tr><tr><th>&nbsp;</th><th colspan="3" align="LEFT">Description</th></tr></thead><tbody valign="TOP"><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_CAMERA_CLASS</code>&nbsp;</td><td>class</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">The Camera class
descriptor. Calling <a href="#VIDIOC-QUERYCTRL"><code class="CONSTANT">VIDIOC_QUERYCTRL</code></a> for this control will return a
description of this control class.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_EXPOSURE_AUTO</code>&nbsp;</td><td>integer</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Enables automatic
adjustments of the exposure time and/or iris aperture. The effect of
manual changes of the exposure time or iris aperture while these
features are enabled is undefined, drivers should ignore such
requests. Possible values are:</td></tr><tr><td>&nbsp;</td><td colspan="3"><table class="CALSTABLE" border="0"><colgroup><col><col></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_EXPOSURE_AUTO</code>&nbsp;</td><td>Automatic exposure time, automatic iris
aperture.</td></tr><tr><td><code class="CONSTANT">V4L2_EXPOSURE_MANUAL</code>&nbsp;</td><td>Manual exposure time, manual iris.</td></tr><tr><td><code class="CONSTANT">V4L2_EXPOSURE_SHUTTER_PRIORITY</code>&nbsp;</td><td>Manual exposure time, auto iris.</td></tr><tr><td><code class="CONSTANT">V4L2_EXPOSURE_APERTURE_PRIORITY</code>&nbsp;</td><td>Auto exposure time, manual iris.</td></tr></tbody></table></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_EXPOSURE_ABSOLUTE</code>&nbsp;</td><td>integer</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Determines the exposure
time of the camera sensor. The exposure time is limited by the frame
interval. Drivers should interpret the values as 100 &#181;s units,
where the value 1 stands for 1/10000th of a second, 10000 for 1 second
and 100000 for 10 seconds.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_EXPOSURE_AUTO_PRIORITY</code>&nbsp;</td><td>boolean</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">When
<code class="CONSTANT">V4L2_CID_EXPOSURE_AUTO</code> is set to
<code class="CONSTANT">AUTO</code> or <code class="CONSTANT">SHUTTER_PRIORITY</code>,
this control determines if the device may dynamically vary the frame
rate. By default this feature is disabled (0) and the frame rate must
remain constant.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_PAN_RELATIVE</code>&nbsp;</td><td>integer</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">This control turns the
camera horizontally by the specified amount. The unit is undefined. A
positive value moves the camera to the right (clockwise when viewed
from above), a negative value to the left. A value of zero does not
cause motion.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_TILT_RELATIVE</code>&nbsp;</td><td>integer</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">This control turns the
camera vertically by the specified amount. The unit is undefined. A
positive value moves the camera up, a negative value down. A value of
zero does not cause motion.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_PAN_RESET</code>&nbsp;</td><td>boolean</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">When this control is set
to <code class="CONSTANT">TRUE</code> (1), the camera moves horizontally to the
default position.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_TILT_RESET</code>&nbsp;</td><td>boolean</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">When this control is set
to <code class="CONSTANT">TRUE</code> (1), the camera moves vertically to the
default position.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_PAN_ABSOLUTE</code>&nbsp;</td><td>integer</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">This control
turns the camera horizontally to the specified position. Positive
values move the camera to the right (clockwise when viewed from above),
negative values to the left. Drivers should interpret the values as arc
seconds, with valid values between -180 * 3600 and +180 * 3600
inclusive.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_TILT_ABSOLUTE</code>&nbsp;</td><td>integer</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">This control
turns the camera vertically to the specified position. Positive values
move the camera up, negative values down. Drivers should interpret the
values as arc seconds, with valid values between -180 * 3600 and +180
* 3600 inclusive.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_FOCUS_ABSOLUTE</code>&nbsp;</td><td>integer</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">This control sets the
focal point of the camera to the specified position. The unit is
undefined. Positive values set the focus closer to the camera,
negative values towards infinity.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_FOCUS_RELATIVE</code>&nbsp;</td><td>integer</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">This control moves the
focal point of the camera by the specified amount. The unit is
undefined. Positive values move the focus closer to the camera,
negative values towards infinity.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="2"><code class="CONSTANT">V4L2_CID_FOCUS_AUTO</code>&nbsp;</td><td>boolean</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td colspan="3">Enables automatic focus
adjustments. The effect of manual focus adjustments while this feature
is enabled is undefined, drivers should ignore such requests.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table></div></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="FORMAT">1.10. Data Formats</a></h2><div class="SECTION"><h3 class="SECTION"><a name="AEN1861">1.10.1. Data Format Negotiation</a></h3><p>Different devices exchange different kinds of data with
applications, for example video images, raw or sliced VBI data, RDS
datagrams. Even within one kind many different formats are possible,
in particular an abundance of image formats. Although drivers must
provide a default and the selection persists across closing and
reopening a device, applications should always negotiate a data format
before engaging in data exchange. Negotiation means the application
asks for a particular format and the driver selects and reports the
best the hardware can do to satisfy the request. Of course
applications can also just query the current selection.</p><p>A single mechanism exists to negotiate all data formats
using the aggregate struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a> and the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_G_FMT</code></a> and
<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctls. Additionally the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_TRY_FMT</code></a> ioctl can be
used to examine what the hardware <span class="emphasis"><i class="EMPHASIS">could</i></span> do,
without actually selecting a new data format. The data formats
supported by the V4L2 API are covered in the respective device section
in <a href="#DEVICES">Chapter 4</a>. For a closer look at image formats see
<a href="#PIXFMT">Chapter 2</a>.</p><p>The <code class="CONSTANT">VIDIOC_S_FMT</code> ioctl is a major
turning-point in the initialization sequence. Prior to this point
multiple panel applications can access the same device concurrently to
select the current input, change controls or modify other properties.
The first <code class="CONSTANT">VIDIOC_S_FMT</code> assigns a logical stream
(video data, VBI data etc.) exclusively to one file descriptor.</p><p>Exclusive means no other application, more precisely no
other file descriptor, can grab this stream or change device
properties inconsistent with the negotiated parameters. A video
standard change for example, when the new standard uses a different
number of scan lines, can invalidate the selected image format.
Therefore only the file descriptor owning the stream can make
invalidating changes. Accordingly multiple file descriptors which
grabbed different logical streams prevent each other from interfering
with their settings. When for example video overlay is about to start
or already in progress, simultaneous video capturing may be restricted
to the same cropping and image size.</p><p>When applications omit the
<code class="CONSTANT">VIDIOC_S_FMT</code> ioctl its locking side effects are
implied by the next step, the selection of an I/O method with the
<a href="#VIDIOC-REQBUFS"><code class="CONSTANT">VIDIOC_REQBUFS</code></a> ioctl or implicit with the first <a href="#FUNC-READ"><code class="FUNCTION">read()</code></a> or
<a href="#FUNC-WRITE"><code class="FUNCTION">write()</code></a> call.</p><p>Generally only one logical stream can be assigned to a
file descriptor, the exception being drivers permitting simultaneous
video capturing and overlay using the same file descriptor for
compatibility with V4L and earlier versions of V4L2. Switching the
logical stream or returning into "panel mode" is possible by closing
and reopening the device. Drivers <span class="emphasis"><i class="EMPHASIS">may</i></span> support a
switch using <code class="CONSTANT">VIDIOC_S_FMT</code>.</p><p>All drivers exchanging data with
applications must support the <code class="CONSTANT">VIDIOC_G_FMT</code> and
<code class="CONSTANT">VIDIOC_S_FMT</code> ioctl. Implementation of the
<code class="CONSTANT">VIDIOC_TRY_FMT</code> is highly recommended but
optional.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN1894">1.10.2. Image Format Enumeration</a></h3><p>Apart of the generic format negotiation functions
a special ioctl to enumerate all image formats supported by video
capture, overlay or output devices is available.<a name="AEN1897" href="#FTN.AEN1897"><span class="footnote">[11]</span></a></p><p>The <a href="#VIDIOC-ENUM-FMT"><code class="CONSTANT">VIDIOC_ENUM_FMT</code></a> ioctl must be supported
by all drivers exchanging image data with applications.</p><div class="IMPORTANT"><blockquote class="IMPORTANT"><p><b>Important: </b>Drivers are not supposed to convert image formats in
kernel space. They must enumerate only formats directly supported by
the hardware. If necessary driver writers should publish an example
conversion routine or library for integration into applications.</p></blockquote></div></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="CROP">1.11. Image Cropping, Insertion and Scaling</a></h2><p>Some video capture devices can sample a subsection of the
picture and shrink or enlarge it to an image of arbitrary size. We
call these abilities cropping and scaling. Some video output devices
can scale an image up or down and insert it at an arbitrary scan line
and horizontal offset into a video signal.</p><p>Applications can use the following API to select an area in
the video signal, query the default area and the hardware limits.
<span class="emphasis"><i class="EMPHASIS">Despite their name, the <a href="#VIDIOC-CROPCAP"><code class="CONSTANT">VIDIOC_CROPCAP</code></a>, <a href="#VIDIOC-G-CROP"><code class="CONSTANT">VIDIOC_G_CROP</code></a>
and <a href="#VIDIOC-G-CROP"><code class="CONSTANT">VIDIOC_S_CROP</code></a> ioctls apply to input as well as output
devices.</i></span></p><p>Scaling requires a source and a target. On a video capture
or overlay device the source is the video signal, and the cropping
ioctls determine the area actually sampled. The target are images
read by the application or overlaid onto the graphics screen. Their
size (and position for an overlay) is negotiated with the
<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_G_FMT</code></a> and <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctls.</p><p>On a video output device the source are the images passed in
by the application, and their size is again negotiated with the
<code class="CONSTANT">VIDIOC_G/S_FMT</code> ioctls, or may be encoded in a
compressed video stream. The target is the video signal, and the
cropping ioctls determine the area where the images are
inserted.</p><p>Source and target rectangles are defined even if the device
does not support scaling or the <code class="CONSTANT">VIDIOC_G/S_CROP</code>
ioctls. Their size (and position where applicable) will be fixed in
this case. <span class="emphasis"><i class="EMPHASIS">All capture and output device must support the
<code class="CONSTANT">VIDIOC_CROPCAP</code> ioctl such that applications can
determine if scaling takes place.</i></span></p><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN1926">1.11.1. Cropping Structures</a></h3><div class="FIGURE"><a name="CROP-SCALE"></a><p><b>Figure 1-1. Image Cropping, Insertion and Scaling</b></p><div class="MEDIAOBJECT"><p><img src="v4l2_files/crop.gif"></p></div></div><p>For capture devices the coordinates of the top left
corner, width and height of the area which can be sampled is given by
the <code class="STRUCTFIELD">bounds</code> substructure of the
struct&nbsp;<a href="#V4L2-CROPCAP">v4l2_cropcap</a> returned by the <code class="CONSTANT">VIDIOC_CROPCAP</code>
ioctl. To support a wide range of hardware this specification does not
define an origin or units. However by convention drivers should
horizontally count unscaled samples relative to 0H (the leading edge
of the horizontal sync pulse, see <a href="#VBI-HSYNC">Figure 4-1</a>).
Vertically ITU-R line
numbers of the first field (<a href="#VBI-525">Figure 4-2</a>, <a href="#VBI-625">Figure 4-3</a>), multiplied by two if the driver can capture both
fields.</p><p>The top left corner, width and height of the source
rectangle, that is the area actually sampled, is given by struct&nbsp;<a href="#V4L2-CROP">v4l2_crop</a>
using the same coordinate system as struct&nbsp;<a href="#V4L2-CROPCAP">v4l2_cropcap</a>. Applications can
use the <code class="CONSTANT">VIDIOC_G_CROP</code> and
<code class="CONSTANT">VIDIOC_S_CROP</code> ioctls to get and set this
rectangle. It must lie completely within the capture boundaries and
the driver may further adjust the requested size and/or position
according to hardware limitations.</p><p>Each capture device has a default source rectangle, given
by the <code class="STRUCTFIELD">defrect</code> substructure of
struct&nbsp;<a href="#V4L2-CROPCAP">v4l2_cropcap</a>. The center of this rectangle shall align with the
center of the active picture area of the video signal, and cover what
the driver writer considers the complete picture. Drivers shall reset
the source rectangle to the default when the driver is first loaded,
but not later.</p><p>For output devices these structures and ioctls are used
accordingly, defining the <span class="emphasis"><i class="EMPHASIS">target</i></span> rectangle where
the images will be inserted into the video signal.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN1954">1.11.2. Scaling Adjustments</a></h3><p>Video hardware can have various cropping, insertion and
scaling limitations. It may only scale up or down, support only
discrete scaling factors, or have different scaling abilities in
horizontal and vertical direction. Also it may not support scaling at
all. At the same time the struct&nbsp;<a href="#V4L2-CROP">v4l2_crop</a> rectangle may have to be
aligned, and both the source and target rectangles may have arbitrary
upper and lower size limits. In particular the maximum
<code class="STRUCTFIELD">width</code> and <code class="STRUCTFIELD">height</code>
in struct&nbsp;<a href="#V4L2-CROP">v4l2_crop</a> may be smaller than the
struct&nbsp;<a href="#V4L2-CROPCAP">v4l2_cropcap</a>.<code class="STRUCTFIELD">bounds</code> area. Therefore, as
usual, drivers are expected to adjust the requested parameters and
return the actual values selected.</p><p>Applications can change the source or the target rectangle
first, as they may prefer a particular image size or a certain area in
the video signal. If the driver has to adjust both to satisfy hardware
limitations, the last requested rectangle shall take priority, and the
driver should preferably adjust the opposite one. The <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_TRY_FMT</code></a>
ioctl however shall not change the driver state and therefore only
adjust the requested rectangle.</p><p>Suppose scaling on a video capture device is restricted to
a factor 1:1 or 2:1 in either direction and the target image size must
be a multiple of 16&nbsp;¡Á&nbsp;16 pixels. The source cropping
rectangle is set to defaults, which are also the upper limit in this
example, of 640&nbsp;¡Á&nbsp;400 pixels at offset 0,&nbsp;0. An
application requests an image size of 300&nbsp;¡Á&nbsp;225
pixels, assuming video will be scaled down from the "full picture"
accordingly. The driver sets the image size to the closest possible
values 304&nbsp;¡Á&nbsp;224, then chooses the cropping rectangle
closest to the requested size, that is 608&nbsp;¡Á&nbsp;224
(224&nbsp;¡Á&nbsp;2:1 would exceed the limit 400). The offset
0,&nbsp;0 is still valid, thus unmodified. Given the default cropping
rectangle reported by <code class="CONSTANT">VIDIOC_CROPCAP</code> the
application can easily propose another offset to center the cropping
rectangle.</p><p>Now the application may insist on covering an area using a
picture aspect ratio closer to the original request, so it asks for a
cropping rectangle of 608&nbsp;¡Á&nbsp;456 pixels. The present
scaling factors limit cropping to 640&nbsp;¡Á&nbsp;384, so the
driver returns the cropping size 608&nbsp;¡Á&nbsp;384 and adjusts
the image size to closest possible 304&nbsp;¡Á&nbsp;192.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN1969">1.11.3. Examples</a></h3><p>Source and target rectangles shall remain unchanged across
closing and reopening a device, such that piping data into or out of a
device will work without special preparations. More advanced
applications should ensure the parameters are suitable before starting
I/O.</p><div class="EXAMPLE"><a name="AEN1972"></a><p><b>Example 1-10. Resetting the cropping parameters</b></p><p>(A video capture device is assumed; change
<code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_CAPTURE</code> for other
devices.)</p><pre class="PROGRAMLISTING">struct&nbsp;<a href="#V4L2-CROPCAP">v4l2_cropcap</a> cropcap;
struct&nbsp;<a href="#V4L2-CROP">v4l2_crop</a> crop;

memset (&amp;cropcap, 0, sizeof (cropcap));
cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

if (-1 == ioctl (fd, <a href="#VIDIOC-CROPCAP"><code class="CONSTANT">VIDIOC_CROPCAP</code></a>, &amp;cropcap)) {
        perror ("VIDIOC_CROPCAP");
        exit (EXIT_FAILURE);
}

memset (&amp;crop, 0, sizeof (crop));
crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
crop.c = cropcap.defrect; 

/* Ignore if cropping is not supported (EINVAL). */

if (-1 == ioctl (fd, <a href="#VIDIOC-G-CROP"><code class="CONSTANT">VIDIOC_S_CROP</code></a>, &amp;crop)
    &amp;&amp; errno != EINVAL) {
        perror ("VIDIOC_S_CROP");
        exit (EXIT_FAILURE);
}
      </pre></div><div class="EXAMPLE"><a name="AEN1983"></a><p><b>Example 1-11. Simple downscaling</b></p><p>(A video capture device is assumed.)</p><pre class="PROGRAMLISTING">struct&nbsp;<a href="#V4L2-CROPCAP">v4l2_cropcap</a> cropcap;
struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a> format;

reset_cropping_parameters ();

/* Scale down to 1/4 size of full picture. */

memset (&amp;format, 0, sizeof (format)); /* defaults */

format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

format.fmt.pix.width = cropcap.defrect.width &gt;&gt; 1;
format.fmt.pix.height = cropcap.defrect.height &gt;&gt; 1;
format.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;

if (-1 == ioctl (fd, <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a>, &amp;format)) {
        perror ("VIDIOC_S_FORMAT");
        exit (EXIT_FAILURE);
}

/* We could check the actual image size now, the actual scaling factor
   or if the driver can scale at all. */
        </pre></div><div class="EXAMPLE"><a name="AEN1991"></a><p><b>Example 1-12. Selecting an output area</b></p><pre class="PROGRAMLISTING">struct&nbsp;<a href="#V4L2-CROPCAP">v4l2_cropcap</a> cropcap;
struct&nbsp;<a href="#V4L2-CROP">v4l2_crop</a> crop;

memset (&amp;cropcap, 0, sizeof (cropcap));
cropcap.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;

if (-1 == ioctl (fd, VIDIOC_CROPCAP, &amp;cropcap)) {
        perror ("VIDIOC_CROPCAP");
        exit (EXIT_FAILURE);
}

memset (&amp;crop, 0, sizeof (crop));

crop.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
crop.c = cropcap.defrect;

/* Scale the width and height to 50 % of their original size
   and center the output. */

crop.c.width /= 2;
crop.c.height /= 2;
crop.c.left += crop.c.width / 2;
crop.c.top += crop.c.height / 2;

/* Ignore if cropping is not supported (EINVAL). */

if (-1 == ioctl (fd, VIDIOC_S_CROP, &amp;crop)
    &amp;&amp; errno != EINVAL) {
        perror ("VIDIOC_S_CROP");
        exit (EXIT_FAILURE);
}</pre></div><div class="EXAMPLE"><a name="AEN1996"></a><p><b>Example 1-13. Current scaling factor and pixel aspect</b></p><p>(A video capture device is assumed.)</p><pre class="PROGRAMLISTING">struct&nbsp;<a href="#V4L2-CROPCAP">v4l2_cropcap</a> cropcap;
struct&nbsp;<a href="#V4L2-CROP">v4l2_crop</a> crop;
struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a> format;
double hscale, vscale;
double aspect;
int dwidth, dheight;

memset (&amp;cropcap, 0, sizeof (cropcap));
cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

if (-1 == ioctl (fd, <a href="#VIDIOC-CROPCAP"><code class="CONSTANT">VIDIOC_CROPCAP</code></a>, &amp;cropcap)) {
        perror ("VIDIOC_CROPCAP");
        exit (EXIT_FAILURE);
}

memset (&amp;crop, 0, sizeof (crop));
crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

if (-1 == ioctl (fd, <a href="#VIDIOC-G-CROP"><code class="CONSTANT">VIDIOC_G_CROP</code></a>, &amp;crop)) {
        if (errno != EINVAL) {
                perror ("VIDIOC_G_CROP");
                exit (EXIT_FAILURE);
        }

        /* Cropping not supported. */
        crop.c = cropcap.defrect;
}

memset (&amp;format, 0, sizeof (format));
format.fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

if (-1 == ioctl (fd, <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_G_FMT</code></a>, &amp;format)) {
        perror ("VIDIOC_G_FMT");
        exit (EXIT_FAILURE);
}

/* The scaling applied by the driver. */

hscale = format.fmt.pix.width / (double) crop.c.width;
vscale = format.fmt.pix.height / (double) crop.c.height;

aspect = cropcap.pixelaspect.numerator /
         (double) cropcap.pixelaspect.denominator;
aspect = aspect * hscale / vscale;

/* Devices following ITU-R BT.601 do not capture
   square pixels. For playback on a computer monitor
   we should scale the images to this size. */

dwidth = format.fmt.pix.width / aspect;
dheight = format.fmt.pix.height;
        </pre></div></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="STREAMING-PAR">1.12. Streaming Parameters</a></h2><p>Streaming parameters are intended to optimize the video
capture process as well as I/O. Presently applications can request a
high quality capture mode with the <a href="#VIDIOC-G-PARM"><code class="CONSTANT">VIDIOC_S_PARM</code></a> ioctl.</p><p>The current video standard determines a nominal number of
frames per second. If less than this number of frames is to be
captured or output, applications can request frame skipping or
duplicating on the driver side. This is especially useful when using
the <a href="#FUNC-READ"><code class="FUNCTION">read()</code></a> or <a href="#FUNC-WRITE"><code class="FUNCTION">write()</code></a>, which are not augmented by timestamps
or sequence counters, and to avoid unneccessary data copying.</p><p>Finally these ioctls can be used to determine the number of
buffers used internally by a driver in read/write mode. For
implications see the section discussing the <a href="#FUNC-READ"><code class="FUNCTION">read()</code></a>
function.</p><p>To get and set the streaming parameters applications call
the <a href="#VIDIOC-G-PARM"><code class="CONSTANT">VIDIOC_G_PARM</code></a> and <a href="#VIDIOC-G-PARM"><code class="CONSTANT">VIDIOC_S_PARM</code></a> ioctl, respectively. They take
a pointer to a struct&nbsp;<a href="#V4L2-STREAMPARM">v4l2_streamparm</a>, which contains a union holding
separate parameters for input and output devices.</p><p>These ioctls are optional, drivers need not implement
them. If so, they return the <span class="ERRORCODE">EINVAL</span> error code.</p></div></div><div class="CHAPTER"><hr><h1><a name="PIXFMT"></a>Chapter 2. Image Formats</h1><p>The V4L2 API was primarily designed for devices exchanging
image data with applications. The
<code class="STRUCTNAME">v4l2_pix_format</code> structure defines the format
and layout of an image in memory. Image formats are negotiated with
the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl. (The explanations here focus on video
capturing and output, for overlay frame buffer formats see also
<a href="#VIDIOC-G-FBUF"><code class="CONSTANT">VIDIOC_G_FBUF</code></a>.)</p><div class="TABLE"><a name="V4L2-PIX-FORMAT"></a><p><b>Table 2-1. struct <code class="STRUCTNAME">v4l2_pix_format</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">width</code></td><td>Image width in pixels.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">height</code></td><td>Image height in pixels.</td></tr><tr><td colspan="3">Applications set these fields to
request an image size, drivers return the closest possible values. In
case of planar formats the <code class="STRUCTFIELD">width</code> and
<code class="STRUCTFIELD">height</code> applies to the largest plane. To
avoid ambiguities drivers must return values rounded up to a multiple
of the scale factor of any smaller planes. For example when the image
format is YUV 4:2:0, <code class="STRUCTFIELD">width</code> and
<code class="STRUCTFIELD">height</code> must be multiples of two.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">pixelformat</code></td><td>The pixel format or type of compression, set by the
application. This is a little endian <a href="#V4L2-FOURCC">four character code</a>. V4L2 defines
standard RGB formats in <a href="#RGB-FORMATS">Table 2-1</a>, YUV formats in <a href="#YUV-FORMATS">Section 2.5</a>, and reserved codes in <a href="#RESERVED-FORMATS">Table 2-8</a></td></tr><tr><td>enum&nbsp;<a href="#V4L2-FIELD">v4l2_field</a></td><td><code class="STRUCTFIELD">field</code></td><td>Video images are typically interlaced. Applications
can request to capture or output only the top or bottom field, or both
fields interlaced or sequentially stored in one buffer or alternating
in separate buffers. Drivers return the actual field order selected.
For details see <a href="#FIELD-ORDER">Section 3.6</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">bytesperline</code></td><td>Distance in bytes between the leftmost pixels in two
adjacent lines.</td></tr><tr><td colspan="3"><p>Both applications and drivers
can set this field to request padding bytes at the end of each line.
Drivers however may ignore the value requested by the application,
returning <code class="STRUCTFIELD">width</code> times bytes per pixel or a
larger value required by the hardware. That implies applications can
just set this field to zero to get a reasonable
default.</p><p>Video hardware may access padding bytes,
therefore they must reside in accessible memory. Consider cases where
padding bytes after the last line of an image cross a system page
boundary. Input devices may write padding bytes, the value is
undefined. Output devices ignore the contents of padding
bytes.</p><p>When the image format is planar the
<code class="STRUCTFIELD">bytesperline</code> value applies to the largest
plane and is divided by the same factor as the
<code class="STRUCTFIELD">width</code> field for any smaller planes. For
example the Cb and Cr planes of a YUV 4:2:0 image have half as many
padding bytes following each line as the Y plane. To avoid ambiguities
drivers must return a <code class="STRUCTFIELD">bytesperline</code> value
rounded up to a multiple of the scale factor.</p></td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">sizeimage</code></td><td>Size in bytes of the buffer to hold a complete image,
set by the driver. Usually this is
<code class="STRUCTFIELD">bytesperline</code> times
<code class="STRUCTFIELD">height</code>. When the image consists of variable
length compressed data this is the maximum number of bytes required to
hold an image.</td></tr><tr><td>enum&nbsp;<a href="#V4L2-COLORSPACE">v4l2_colorspace</a></td><td><code class="STRUCTFIELD">colorspace</code></td><td>This information supplements the
<code class="STRUCTFIELD">pixelformat</code> and must be set by the driver,
see <a href="#COLORSPACES">Section 2.2</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">priv</code></td><td>Reserved for custom (driver defined) additional
information about formats. When not used drivers and applications must
set this field to zero.</td></tr></tbody></table></div><div class="SECTION"><hr><h2 class="SECTION"><a name="AEN2113">2.1. Standard Image Formats</a></h2><p>In order to exchange images between drivers and
applications, it is necessary to have standard image data formats
which both sides will interpret the same way. V4L2 includes several
such formats, and this section is intended to be an unambiguous
specification of the standard image data formats in V4L2.</p><p>V4L2 drivers are not limited to these formats, however.
Driver-specific formats are possible. In that case the application may
depend on a codec to convert images to one of the standard formats
when needed. But the data can still be stored and retrieved in the
proprietary format. For example, a device may support a proprietary
compressed format. Applications can still capture and save the data in
the compressed format, saving much disk space, and later use a codec
to convert the images to the X Windows screen format when the video is
to be displayed.</p><p>Even so, ultimately, some standard formats are needed, so
the V4L2 specification would not be complete without well-defined
standard formats.</p><p>The V4L2 standard formats are mainly uncompressed formats. The
pixels are always arranged in memory from left to right, and from top
to bottom. The first byte of data in the image buffer is always for
the leftmost pixel of the topmost row. Following that is the pixel
immediately to its right, and so on until the end of the top row of
pixels. Following the rightmost pixel of the row there may be zero or
more bytes of padding to guarantee that each row of pixel data has a
certain alignment. Following the pad bytes, if any, is data for the
leftmost pixel of the second row from the top, and so on. The last row
has just as many pad bytes after it as the other rows.</p><p>In V4L2 each format has an identifier which looks like
<code class="CONSTANT">PIX_FMT_XXX</code>, defined in the <a href="#VIDEODEV">videodev.h</a> header file. These identifiers
represent <a href="#V4L2-FOURCC">four character codes</a>
which are also listed below, however they are not the same as those
used in the Windows world.</p></div><div class="SECTION"><hr><h2 class="SECTION"><a name="COLORSPACES">2.2. Colorspaces</a></h2><p>[intro]</p><p>      </p><p></p><div class="VARIABLELIST"><dl><dt>Gamma Correction</dt><dd><p>[to do]</p><p>E'<sub>R</sub> = f(R)</p><p>E'<sub>G</sub> = f(G)</p><p>E'<sub>B</sub> = f(B)</p></dd><dt>Construction of luminance and color-difference
signals</dt><dd><p>[to do]</p><p>E'<sub>Y</sub> =
Coeff<sub>R</sub> E'<sub>R</sub>
+ Coeff<sub>G</sub> E'<sub>G</sub>
+ Coeff<sub>B</sub> E'<sub>B</sub></p><p>(E'<sub>R</sub> - E'<sub>Y</sub>) = E'<sub>R</sub>
- Coeff<sub>R</sub> E'<sub>R</sub>
- Coeff<sub>G</sub> E'<sub>G</sub>
- Coeff<sub>B</sub> E'<sub>B</sub></p><p>(E'<sub>B</sub> - E'<sub>Y</sub>) = E'<sub>B</sub>
- Coeff<sub>R</sub> E'<sub>R</sub>
- Coeff<sub>G</sub> E'<sub>G</sub>
- Coeff<sub>B</sub> E'<sub>B</sub></p></dd><dt>Re-normalized color-difference signals</dt><dd><p>The color-difference signals are scaled back to unity
range [-0.5;+0.5]:</p><p>K<sub>B</sub> = 0.5 / (1 - Coeff<sub>B</sub>)</p><p>K<sub>R</sub> = 0.5 / (1 - Coeff<sub>R</sub>)</p><p>P<sub>B</sub> =
K<sub>B</sub> (E'<sub>B</sub> - E'<sub>Y</sub>) =
  0.5 (Coeff<sub>R</sub> / Coeff<sub>B</sub>) E'<sub>R</sub>
+ 0.5 (Coeff<sub>G</sub> / Coeff<sub>B</sub>) E'<sub>G</sub>
+ 0.5 E'<sub>B</sub></p><p>P<sub>R</sub> =
K<sub>R</sub> (E'<sub>R</sub> - E'<sub>Y</sub>) =
  0.5 E'<sub>R</sub>
+ 0.5 (Coeff<sub>G</sub> / Coeff<sub>R</sub>) E'<sub>G</sub>
+ 0.5 (Coeff<sub>B</sub> / Coeff<sub>R</sub>) E'<sub>B</sub></p></dd><dt>Quantization</dt><dd><p>[to do]</p><p>Y' = (Lum. Levels - 1) ¡¤ E'<sub>Y</sub> + Lum. Offset</p><p>C<sub>B</sub> = (Chrom. Levels - 1)
¡¤ P<sub>B</sub> + Chrom. Offset</p><p>C<sub>R</sub> = (Chrom. Levels - 1)
¡¤ P<sub>R</sub> + Chrom. Offset</p><p>Rounding to the nearest integer and clamping to the range
[0;255] finally yields the digital color components Y'CbCr
stored in YUV images.</p></dd></dl></div>
    <p></p><div class="EXAMPLE"><a name="AEN2217"></a><p><b>Example 2-1. ITU-R Rec. BT.601 color conversion</b></p><p>Forward Transformation</p><pre class="PROGRAMLISTING">int ER, EG, EB;         /* gamma corrected RGB input [0;255] */
int Y1, Cb, Cr;         /* output [0;255] */

double r, g, b;         /* temporaries */
double y1, pb, pr;

int
clamp (double x)
{
        int r = x;      /* round to nearest */

        if (r &lt; 0)         return 0;
        else if (r &gt; 255)  return 255;
        else               return r;
}

r = ER / 255.0;
g = EG / 255.0;
b = EB / 255.0;

y1  =  0.299  * r + 0.587 * g + 0.114  * b;
pb  = -0.169  * r - 0.331 * g + 0.5    * b;
pr  =  0.5    * r - 0.419 * g - 0.081  * b;

Y1 = clamp (219 * y1 + 16);
Cb = clamp (224 * pb + 128);
Cr = clamp (224 * pr + 128);

/* or shorter */

y1 = 0.299 * ER + 0.587 * EG + 0.114 * EB;

Y1 = clamp ( (219 / 255.0)                    *       y1  + 16);
Cb = clamp (((224 / 255.0) / (2 - 2 * 0.114)) * (EB - y1) + 128);
Cr = clamp (((224 / 255.0) / (2 - 2 * 0.299)) * (ER - y1) + 128);
      </pre><p>Inverse Transformation</p><pre class="PROGRAMLISTING">int Y1, Cb, Cr;         /* gamma pre-corrected input [0;255] */
int ER, EG, EB;         /* output [0;255] */

double r, g, b;         /* temporaries */
double y1, pb, pr;

int
clamp (double x)
{
        int r = x;      /* round to nearest */

        if (r &lt; 0)         return 0;
        else if (r &gt; 255)  return 255;
        else               return r;
}

y1 = (255 / 219.0) * (Y1 - 16);
pb = (255 / 224.0) * (Cb - 128);
pr = (255 / 224.0) * (Cr - 128);

r = 1.0 * y1 + 0     * pb + 1.402 * pr;
g = 1.0 * y1 - 0.344 * pb - 0.714 * pr;
b = 1.0 * y1 + 1.772 * pb + 0     * pr;

ER = clamp (r * 255); /* [ok? one should prob. limit y1,pb,pr] */
EG = clamp (g * 255);
EB = clamp (b * 255);
      </pre></div><div class="TABLE"><a name="V4L2-COLORSPACE"></a><p><b>Table 2-2. enum v4l2_colorspace</b></p><table class="CALSTABLE" border="1" width="100%"><colgroup><col align="LEFT" width="9%"><col align="CENTER" width="9%"><col align="LEFT" width="9%"><col title="CR" width="9%"><col title="CG" width="9%"><col title="CB" width="9%"><col title="WP" width="9%"><col title="GC" width="9%"><col title="LUM" width="9%"><col title="QY" width="9%"><col title="QC" width="9%"></colgroup><thead><tr><th rowspan="2">Identifier</th><th rowspan="2">Value</th><th rowspan="2">Description</th><th colspan="3">Chromaticities<a name="AEN2246" href="#FTN.AEN2246"><span class="footnote">[a]</span></a></th><th rowspan="2">White Point</th><th rowspan="2">Gamma Correction</th><th rowspan="2">Luminance E'<sub>Y</sub></th><th colspan="2">Quantization</th></tr><tr><th>Red</th><th>Green</th><th>Blue</th><th>Y'</th><th>Cb, Cr</th></tr></thead><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_COLORSPACE_SMPTE170M</code></td><td>1</td><td>NTSC/PAL according to <a href="#SMPTE170M"><abbr class="ABBREV">SMPTE&nbsp;170M</abbr></a>,
<a href="#ITU601"><abbr class="ABBREV">ITU&nbsp;BT.601</abbr></a></td><td>x&nbsp;=&nbsp;0.630, y&nbsp;=&nbsp;0.340</td><td>x&nbsp;=&nbsp;0.310, y&nbsp;=&nbsp;0.595</td><td>x&nbsp;=&nbsp;0.155, y&nbsp;=&nbsp;0.070</td><td>x&nbsp;=&nbsp;0.3127, y&nbsp;=&nbsp;0.3290,
            Illuminant D<sub>65</sub></td><td>E' = 4.5&nbsp;I&nbsp;for&nbsp;I&nbsp;¡Ü0.018,
1.099&nbsp;I<sup>0.45</sup>&nbsp;-&nbsp;0.099&nbsp;for&nbsp;0.018&nbsp;&lt;&nbsp;I</td><td>0.299&nbsp;E'<sub>R</sub>
+&nbsp;0.587&nbsp;E'<sub>G</sub>
+&nbsp;0.114&nbsp;E'<sub>B</sub></td><td>219&nbsp;E'<sub>Y</sub>&nbsp;+&nbsp;16</td><td>224&nbsp;P<sub>B,R</sub>&nbsp;+&nbsp;128</td></tr><tr><td><code class="CONSTANT">V4L2_COLORSPACE_SMPTE240M</code></td><td>2</td><td>1125-Line (US) HDTV, see <a href="#SMPTE240M"><abbr class="ABBREV">SMPTE&nbsp;240M</abbr></a></td><td>x&nbsp;=&nbsp;0.630, y&nbsp;=&nbsp;0.340</td><td>x&nbsp;=&nbsp;0.310, y&nbsp;=&nbsp;0.595</td><td>x&nbsp;=&nbsp;0.155, y&nbsp;=&nbsp;0.070</td><td>x&nbsp;=&nbsp;0.3127, y&nbsp;=&nbsp;0.3290,
            Illuminant D<sub>65</sub></td><td>E' = 4&nbsp;I&nbsp;for&nbsp;I&nbsp;¡Ü0.0228,
1.1115&nbsp;I<sup>0.45</sup>&nbsp;-&nbsp;0.1115&nbsp;for&nbsp;0.0228&nbsp;&lt;&nbsp;I</td><td>0.212&nbsp;E'<sub>R</sub>
+&nbsp;0.701&nbsp;E'<sub>G</sub>
+&nbsp;0.087&nbsp;E'<sub>B</sub></td><td>219&nbsp;E'<sub>Y</sub>&nbsp;+&nbsp;16</td><td>224&nbsp;P<sub>B,R</sub>&nbsp;+&nbsp;128</td></tr><tr><td><code class="CONSTANT">V4L2_COLORSPACE_REC709</code></td><td>3</td><td>HDTV and modern devices, see <a href="#ITU709"><abbr class="ABBREV">ITU&nbsp;BT.709</abbr></a></td><td>x&nbsp;=&nbsp;0.640, y&nbsp;=&nbsp;0.330</td><td>x&nbsp;=&nbsp;0.300, y&nbsp;=&nbsp;0.600</td><td>x&nbsp;=&nbsp;0.150, y&nbsp;=&nbsp;0.060</td><td>x&nbsp;=&nbsp;0.3127, y&nbsp;=&nbsp;0.3290,
            Illuminant D<sub>65</sub></td><td>E' = 4.5&nbsp;I&nbsp;for&nbsp;I&nbsp;¡Ü0.018,
1.099&nbsp;I<sup>0.45</sup>&nbsp;-&nbsp;0.099&nbsp;for&nbsp;0.018&nbsp;&lt;&nbsp;I</td><td>0.2125&nbsp;E'<sub>R</sub> 
+&nbsp;0.7154&nbsp;E'<sub>G</sub>
+&nbsp;0.0721&nbsp;E'<sub>B</sub></td><td>219&nbsp;E'<sub>Y</sub>&nbsp;+&nbsp;16</td><td>224&nbsp;P<sub>B,R</sub>&nbsp;+&nbsp;128</td></tr><tr><td><code class="CONSTANT">V4L2_COLORSPACE_BT878</code></td><td>4</td><td>Broken Bt878 extents<a name="AEN2329" href="#FTN.AEN2329"><span class="footnote">[b]</span></a>, <a href="#ITU601"><abbr class="ABBREV">ITU&nbsp;BT.601</abbr></a></td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>0.299&nbsp;E'<sub>R</sub>
+&nbsp;0.587&nbsp;E'<sub>G</sub>
+&nbsp;0.114&nbsp;E'<sub>B</sub></td><td><span class="emphasis"><i class="EMPHASIS">237</i></span>&nbsp;E'<sub>Y</sub>&nbsp;+&nbsp;16</td><td>224&nbsp;P<sub>B,R</sub>&nbsp;+&nbsp;128 (probably)</td></tr><tr><td><code class="CONSTANT">V4L2_COLORSPACE_470_SYSTEM_M</code></td><td>5</td><td>M/NTSC<a name="AEN2352" href="#FTN.AEN2352"><span class="footnote">[c]</span></a> according to <a href="#ITU470"><abbr class="ABBREV">ITU&nbsp;BT.470</abbr></a>, <a href="#ITU601"><abbr class="ABBREV">ITU&nbsp;BT.601</abbr></a></td><td>x&nbsp;=&nbsp;0.67, y&nbsp;=&nbsp;0.33</td><td>x&nbsp;=&nbsp;0.21, y&nbsp;=&nbsp;0.71</td><td>x&nbsp;=&nbsp;0.14, y&nbsp;=&nbsp;0.08</td><td>x&nbsp;=&nbsp;0.310, y&nbsp;=&nbsp;0.316, Illuminant C</td><td>?</td><td>0.299&nbsp;E'<sub>R</sub>
+&nbsp;0.587&nbsp;E'<sub>G</sub>
+&nbsp;0.114&nbsp;E'<sub>B</sub></td><td>219&nbsp;E'<sub>Y</sub>&nbsp;+&nbsp;16</td><td>224&nbsp;P<sub>B,R</sub>&nbsp;+&nbsp;128</td></tr><tr><td><code class="CONSTANT">V4L2_COLORSPACE_470_SYSTEM_BG</code></td><td>6</td><td>625-line PAL and SECAM systems according to <a href="#ITU470"><abbr class="ABBREV">ITU&nbsp;BT.470</abbr></a>, <a href="#ITU601"><abbr class="ABBREV">ITU&nbsp;BT.601</abbr></a></td><td>x&nbsp;=&nbsp;0.64, y&nbsp;=&nbsp;0.33</td><td>x&nbsp;=&nbsp;0.29, y&nbsp;=&nbsp;0.60</td><td>x&nbsp;=&nbsp;0.15, y&nbsp;=&nbsp;0.06</td><td>x&nbsp;=&nbsp;0.313, y&nbsp;=&nbsp;0.329,
Illuminant D<sub>65</sub></td><td>?</td><td>0.299&nbsp;E'<sub>R</sub>
+&nbsp;0.587&nbsp;E'<sub>G</sub>
+&nbsp;0.114&nbsp;E'<sub>B</sub></td><td>219&nbsp;E'<sub>Y</sub>&nbsp;+&nbsp;16</td><td>224&nbsp;P<sub>B,R</sub>&nbsp;+&nbsp;128</td></tr><tr><td><code class="CONSTANT">V4L2_COLORSPACE_JPEG</code></td><td>7</td><td>JPEG Y'CbCr, see <a href="#JFIF"><abbr class="ABBREV">JFIF</abbr></a>, <a href="#ITU601"><abbr class="ABBREV">ITU&nbsp;BT.601</abbr></a></td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>0.299&nbsp;E'<sub>R</sub>
+&nbsp;0.587&nbsp;E'<sub>G</sub>
+&nbsp;0.114&nbsp;E'<sub>B</sub></td><td>256&nbsp;E'<sub>Y</sub>&nbsp;+&nbsp;16<a name="AEN2408" href="#FTN.AEN2408"><span class="footnote">[d]</span></a></td><td>256&nbsp;P<sub>B,R</sub>&nbsp;+&nbsp;128</td></tr><tr><td><code class="CONSTANT">V4L2_COLORSPACE_SRGB</code></td><td>8</td><td>[?]</td><td>x&nbsp;=&nbsp;0.640, y&nbsp;=&nbsp;0.330</td><td>x&nbsp;=&nbsp;0.300, y&nbsp;=&nbsp;0.600</td><td>x&nbsp;=&nbsp;0.150, y&nbsp;=&nbsp;0.060</td><td>x&nbsp;=&nbsp;0.3127, y&nbsp;=&nbsp;0.3290,
            Illuminant D<sub>65</sub></td><td>E' = 4.5&nbsp;I&nbsp;for&nbsp;I&nbsp;¡Ü0.018,
1.099&nbsp;I<sup>0.45</sup>&nbsp;-&nbsp;0.099&nbsp;for&nbsp;0.018&nbsp;&lt;&nbsp;I</td><td colspan="3">n/a</td></tr></tbody><tbody><tr><td colspan="11">Notes:<br><a name="FTN.AEN2246">a. </a>The coordinates of the color primaries are
given in the CIE system (1931)<br><a name="FTN.AEN2329">b. </a>The ubiquitous Bt878 video capture chip
quantizes E'<sub>Y</sub> to 238 levels, yielding a range
of Y' = 16 ¡­ 253, unlike Rec. 601 Y' = 16 ¡­
235. This is not a typo in the Bt878 documentation, it has been
implemented in silicon. The chroma extents are unclear.<br><a name="FTN.AEN2352">c. </a>No identifier exists for M/PAL which uses
the chromaticities of M/NTSC, the remaining parameters are equal to B and
G/PAL.<br><a name="FTN.AEN2408">d. </a>Note JFIF quantizes
Y'P<sub>B</sub>P<sub>R</sub> in range [0;+1] and
[-0.5;+0.5] to <span class="emphasis"><i class="EMPHASIS">257</i></span> levels, however Y'CbCr signals
are still clamped to [0;255].<br></td></tr></tbody></table></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="PIXFMT-INDEXED">2.3. Indexed Format</a></h2><p>In this format each pixel is represented by an 8 bit index
into a 256 entry ARGB palette. It is intended for <a href="#OSD">Video Output Overlays</a> only. There are no ioctls to
access the palette, this must be done with ioctls of the Linux framebuffer API.</p><div class="TABLE"><a name="AEN2432"></a><p><b>Table 2-3. Indexed Image Format</b></p><a name="V4L2-PIX-FMT-PAL8"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col title="ID" align="LEFT" width="1*"><col title="FOURCC" width="1*"><col title="BIT" width="1*"><col title="B07" align="CENTER" width="1*"><col title="B06" align="CENTER" width="1*"><col title="B05" align="CENTER" width="1*"><col title="B04" align="CENTER" width="1*"><col title="B03" align="CENTER" width="1*"><col title="B02" align="CENTER" width="1*"><col title="B01" align="CENTER" width="1*"><col title="B00" align="CENTER" width="1*"><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th>Identifier</th><th>Code</th><th>&nbsp;</th><th colspan="8">Byte&nbsp;0</th><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><th>&nbsp;</th><th>&nbsp;</th><th>Bit</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr></thead><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_PIX_FMT_PAL8</code></td><td>'PAL8'</td><td>&nbsp;</td><td>i<sub>7</sub></td><td>i<sub>6</sub></td><td>i<sub>5</sub></td><td>i<sub>4</sub></td><td>i<sub>3</sub></td><td>i<sub>2</sub></td><td>i<sub>1</sub></td><td>i<sub>0</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="PIXFMT-RGB">2.4. RGB Formats</a></h2><div class="TOC"><dl><dt><b>Table of Contents</b></dt><dt><a href="#PACKED-RGB">Packed RGB formats</a>&nbsp;--&nbsp;Packed RGB formats</dt><dt><a href="#V4L2-PIX-FMT-SBGGR8">V4L2_PIX_FMT_SBGGR8 ('BA81')</a>&nbsp;--&nbsp;Bayer RGB format</dt><dt><a href="#V4L2-PIX-FMT-SBGGR16">V4L2_PIX_FMT_SBGGR16 ('BA82')</a>&nbsp;--&nbsp;Bayer RGB format</dt></dl></div><h1><a name="PACKED-RGB"></a>Packed RGB formats</h1><div class="REFNAMEDIV"><a name="AEN2496"></a><h2>Name</h2>Packed RGB formats&nbsp;--&nbsp;Packed RGB formats</div><div class="REFSECT1"><a name="AEN2499"></a><h2>Description</h2><p>These formats are designed to match the pixel formats of
typical PC graphics frame buffers. They occupy 8, 16, 24 or 32 bits
per pixel. These are all packed-pixel formats, meaning all the data
for a pixel lie next to each other in memory.</p><p>When one of these formats is used, drivers shall report the
colorspace <code class="CONSTANT">V4L2_COLORSPACE_SRGB</code>.</p><div class="TABLE"><a name="RGB-FORMATS"></a><p><b>Table 2-1. Packed RGB Image Formats</b></p><a name="V4L2-PIX-FMT-RGB332"></a><a name="V4L2-PIX-FMT-RGB444"></a><a name="V4L2-PIX-FMT-RGB555"></a><a name="V4L2-PIX-FMT-RGB565"></a><a name="V4L2-PIX-FMT-RGB555X"></a><a name="V4L2-PIX-FMT-RGB565X"></a><a name="V4L2-PIX-FMT-BGR24"></a><a name="V4L2-PIX-FMT-RGB24"></a><a name="V4L2-PIX-FMT-BGR32"></a><a name="V4L2-PIX-FMT-RGB32"></a><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="ID" align="LEFT" width="3%"><col title="FOURCC" width="3%"><col title="BIT" width="3%"><col title="B07" align="CENTER" width="3%"><col title="B06" align="CENTER" width="3%"><col title="B05" align="CENTER" width="3%"><col title="B04" align="CENTER" width="3%"><col title="B03" align="CENTER" width="3%"><col title="B02" align="CENTER" width="3%"><col title="B01" align="CENTER" width="3%"><col title="B00" align="CENTER" width="3%"><col><col title="B17" align="CENTER" width="3%"><col title="B16" align="CENTER" width="3%"><col title="B15" align="CENTER" width="3%"><col title="B14" align="CENTER" width="3%"><col title="B13" align="CENTER" width="3%"><col title="B12" align="CENTER" width="3%"><col title="B11" align="CENTER" width="3%"><col title="B10" align="CENTER" width="3%"><col><col title="B27" align="CENTER" width="3%"><col title="B26" align="CENTER" width="3%"><col title="B25" align="CENTER" width="3%"><col title="B24" align="CENTER" width="3%"><col title="B23" align="CENTER" width="3%"><col title="B22" align="CENTER" width="3%"><col title="B21" align="CENTER" width="3%"><col title="B20" align="CENTER" width="3%"><col><col title="B37" align="CENTER" width="3%"><col title="B36" align="CENTER" width="3%"><col title="B35" align="CENTER" width="3%"><col title="B34" align="CENTER" width="3%"><col title="B33" align="CENTER" width="3%"><col title="B32" align="CENTER" width="3%"><col title="B31" align="CENTER" width="3%"></colgroup><thead><tr><th>Identifier</th><th>Code</th><th>&nbsp;</th><th colspan="8">Byte&nbsp;0 in memory</th><th>&nbsp;</th><th colspan="8">Byte&nbsp;1</th><th>&nbsp;</th><th colspan="8">Byte&nbsp;2</th><th>&nbsp;</th><th colspan="8">Byte&nbsp;3</th></tr><tr><th>&nbsp;</th><th>&nbsp;</th><th>Bit</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th><th>&nbsp;</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th><th>&nbsp;</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th><th>&nbsp;</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_PIX_FMT_RGB332</code></td><td>'RGB1'</td><td>&nbsp;</td><td>b<sub>1</sub></td><td>b<sub>0</sub></td><td>g<sub>2</sub></td><td>g<sub>1</sub></td><td>g<sub>0</sub></td><td>r<sub>2</sub></td><td>r<sub>1</sub></td><td>r<sub>0</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_RGB444</code></td><td>'R444'</td><td>&nbsp;</td><td>g<sub>3</sub></td><td>g<sub>2</sub></td><td>g<sub>1</sub></td><td>g<sub>0</sub></td><td>b<sub>3</sub></td><td>b<sub>2</sub></td><td>b<sub>1</sub></td><td>b<sub>0</sub></td><td>&nbsp;</td><td>a<sub>3</sub></td><td>a<sub>2</sub></td><td>a<sub>1</sub></td><td>a<sub>0</sub></td><td>r<sub>3</sub></td><td>r<sub>2</sub></td><td>r<sub>1</sub></td><td>r<sub>0</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_RGB555</code></td><td>'RGBO'</td><td>&nbsp;</td><td>g<sub>2</sub></td><td>g<sub>1</sub></td><td>g<sub>0</sub></td><td>r<sub>4</sub></td><td>r<sub>3</sub></td><td>r<sub>2</sub></td><td>r<sub>1</sub></td><td>r<sub>0</sub></td><td>&nbsp;</td><td>a</td><td>b<sub>4</sub></td><td>b<sub>3</sub></td><td>b<sub>2</sub></td><td>b<sub>1</sub></td><td>b<sub>0</sub></td><td>g<sub>4</sub></td><td>g<sub>3</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_RGB565</code></td><td>'RGBP'</td><td>&nbsp;</td><td>g<sub>2</sub></td><td>g<sub>1</sub></td><td>g<sub>0</sub></td><td>r<sub>4</sub></td><td>r<sub>3</sub></td><td>r<sub>2</sub></td><td>r<sub>1</sub></td><td>r<sub>0</sub></td><td>&nbsp;</td><td>b<sub>4</sub></td><td>b<sub>3</sub></td><td>b<sub>2</sub></td><td>b<sub>1</sub></td><td>b<sub>0</sub></td><td>g<sub>5</sub></td><td>g<sub>4</sub></td><td>g<sub>3</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_RGB555X</code></td><td>'RGBQ'</td><td>&nbsp;</td><td>a</td><td>b<sub>4</sub></td><td>b<sub>3</sub></td><td>b<sub>2</sub></td><td>b<sub>1</sub></td><td>b<sub>0</sub></td><td>g<sub>4</sub></td><td>g<sub>3</sub></td><td>&nbsp;</td><td>g<sub>2</sub></td><td>g<sub>1</sub></td><td>g<sub>0</sub></td><td>r<sub>4</sub></td><td>r<sub>3</sub></td><td>r<sub>2</sub></td><td>r<sub>1</sub></td><td>r<sub>0</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_RGB565X</code></td><td>'RGBR'</td><td>&nbsp;</td><td>b<sub>4</sub></td><td>b<sub>3</sub></td><td>b<sub>2</sub></td><td>b<sub>1</sub></td><td>b<sub>0</sub></td><td>g<sub>5</sub></td><td>g<sub>4</sub></td><td>g<sub>3</sub></td><td>&nbsp;</td><td>g<sub>2</sub></td><td>g<sub>1</sub></td><td>g<sub>0</sub></td><td>r<sub>4</sub></td><td>r<sub>3</sub></td><td>r<sub>2</sub></td><td>r<sub>1</sub></td><td>r<sub>0</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_BGR24</code></td><td>'BGR3'</td><td>&nbsp;</td><td>b<sub>7</sub></td><td>b<sub>6</sub></td><td>b<sub>5</sub></td><td>b<sub>4</sub></td><td>b<sub>3</sub></td><td>b<sub>2</sub></td><td>b<sub>1</sub></td><td>b<sub>0</sub></td><td>&nbsp;</td><td>g<sub>7</sub></td><td>g<sub>6</sub></td><td>g<sub>5</sub></td><td>g<sub>4</sub></td><td>g<sub>3</sub></td><td>g<sub>2</sub></td><td>g<sub>1</sub></td><td>g<sub>0</sub></td><td>&nbsp;</td><td>r<sub>7</sub></td><td>r<sub>6</sub></td><td>r<sub>5</sub></td><td>r<sub>4</sub></td><td>r<sub>3</sub></td><td>r<sub>2</sub></td><td>r<sub>1</sub></td><td>r<sub>0</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_RGB24</code></td><td>'RGB3'</td><td>&nbsp;</td><td>r<sub>7</sub></td><td>r<sub>6</sub></td><td>r<sub>5</sub></td><td>r<sub>4</sub></td><td>r<sub>3</sub></td><td>r<sub>2</sub></td><td>r<sub>1</sub></td><td>r<sub>0</sub></td><td>&nbsp;</td><td>g<sub>7</sub></td><td>g<sub>6</sub></td><td>g<sub>5</sub></td><td>g<sub>4</sub></td><td>g<sub>3</sub></td><td>g<sub>2</sub></td><td>g<sub>1</sub></td><td>g<sub>0</sub></td><td>&nbsp;</td><td>b<sub>7</sub></td><td>b<sub>6</sub></td><td>b<sub>5</sub></td><td>b<sub>4</sub></td><td>b<sub>3</sub></td><td>b<sub>2</sub></td><td>b<sub>1</sub></td><td>b<sub>0</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_BGR32</code></td><td>'BGR4'</td><td>&nbsp;</td><td>b<sub>7</sub></td><td>b<sub>6</sub></td><td>b<sub>5</sub></td><td>b<sub>4</sub></td><td>b<sub>3</sub></td><td>b<sub>2</sub></td><td>b<sub>1</sub></td><td>b<sub>0</sub></td><td>&nbsp;</td><td>g<sub>7</sub></td><td>g<sub>6</sub></td><td>g<sub>5</sub></td><td>g<sub>4</sub></td><td>g<sub>3</sub></td><td>g<sub>2</sub></td><td>g<sub>1</sub></td><td>g<sub>0</sub></td><td>&nbsp;</td><td>r<sub>7</sub></td><td>r<sub>6</sub></td><td>r<sub>5</sub></td><td>r<sub>4</sub></td><td>r<sub>3</sub></td><td>r<sub>2</sub></td><td>r<sub>1</sub></td><td>r<sub>0</sub></td><td>&nbsp;</td><td>a<sub>7</sub></td><td>a<sub>6</sub></td><td>a<sub>5</sub></td><td>a<sub>4</sub></td><td>a<sub>3</sub></td><td>a<sub>2</sub></td><td>a<sub>1</sub></td><td>a<sub>0</sub></td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_RGB32</code></td><td>'RGB4'</td><td>&nbsp;</td><td>r<sub>7</sub></td><td>r<sub>6</sub></td><td>r<sub>5</sub></td><td>r<sub>4</sub></td><td>r<sub>3</sub></td><td>r<sub>2</sub></td><td>r<sub>1</sub></td><td>r<sub>0</sub></td><td>&nbsp;</td><td>g<sub>7</sub></td><td>g<sub>6</sub></td><td>g<sub>5</sub></td><td>g<sub>4</sub></td><td>g<sub>3</sub></td><td>g<sub>2</sub></td><td>g<sub>1</sub></td><td>g<sub>0</sub></td><td>&nbsp;</td><td>b<sub>7</sub></td><td>b<sub>6</sub></td><td>b<sub>5</sub></td><td>b<sub>4</sub></td><td>b<sub>3</sub></td><td>b<sub>2</sub></td><td>b<sub>1</sub></td><td>b<sub>0</sub></td><td>&nbsp;</td><td>a<sub>7</sub></td><td>a<sub>6</sub></td><td>a<sub>5</sub></td><td>a<sub>4</sub></td><td>a<sub>3</sub></td><td>a<sub>2</sub></td><td>a<sub>1</sub></td><td>a<sub>0</sub></td></tr></tbody></table></div><p>Bit 7 is the most significant bit. The value of a = alpha
bits is undefined when reading from the driver, ignored when writing
to the driver, except when alpha blending has been negotiated for a
<a href="#OVERLAY">Video Overlay</a> or <a href="#OSD">Video Output Overlay</a>.</p><div class="EXAMPLE"><a name="AEN3061"></a><p><b>Example 2-1. <code class="CONSTANT">V4L2_PIX_FMT_BGR24</code> 4 ¡Á 4 pixel
image</b></p><div class="FORMALPARA"><p><b>Byte Order. </b>Each cell is one byte.
              </p><div class="INFORMALTABLE"><p></p><a name="AEN3067"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col align="LEFT" width="2*"><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><tbody valign="TOP"><tr><td>start&nbsp;+&nbsp;0:</td><td>B<sub>00</sub></td><td>G<sub>00</sub></td><td>R<sub>00</sub></td><td>B<sub>01</sub></td><td>G<sub>01</sub></td><td>R<sub>01</sub></td><td>B<sub>02</sub></td><td>G<sub>02</sub></td><td>R<sub>02</sub></td><td>B<sub>03</sub></td><td>G<sub>03</sub></td><td>R<sub>03</sub></td></tr><tr><td>start&nbsp;+&nbsp;12:</td><td>B<sub>10</sub></td><td>G<sub>10</sub></td><td>R<sub>10</sub></td><td>B<sub>11</sub></td><td>G<sub>11</sub></td><td>R<sub>11</sub></td><td>B<sub>12</sub></td><td>G<sub>12</sub></td><td>R<sub>12</sub></td><td>B<sub>13</sub></td><td>G<sub>13</sub></td><td>R<sub>13</sub></td></tr><tr><td>start&nbsp;+&nbsp;24:</td><td>B<sub>20</sub></td><td>G<sub>20</sub></td><td>R<sub>20</sub></td><td>B<sub>21</sub></td><td>G<sub>21</sub></td><td>R<sub>21</sub></td><td>B<sub>22</sub></td><td>G<sub>22</sub></td><td>R<sub>22</sub></td><td>B<sub>23</sub></td><td>G<sub>23</sub></td><td>R<sub>23</sub></td></tr><tr><td>start&nbsp;+&nbsp;36:</td><td>B<sub>30</sub></td><td>G<sub>30</sub></td><td>R<sub>30</sub></td><td>B<sub>31</sub></td><td>G<sub>31</sub></td><td>R<sub>31</sub></td><td>B<sub>32</sub></td><td>G<sub>32</sub></td><td>R<sub>32</sub></td><td>B<sub>33</sub></td><td>G<sub>33</sub></td><td>R<sub>33</sub></td></tr></tbody></table><p></p></div>
            <p></p></div></div><div class="IMPORTANT"><blockquote class="IMPORTANT"><p><b>Important: </b>Drivers may interpret these formats differently.</p></blockquote></div><p>Some RGB formats above are uncommon and were probably
defined in error. Drivers may interpret them as in <a href="#RGB-FORMATS-CORRECTED">Table 2-2</a>.</p><div class="TABLE"><a name="RGB-FORMATS-CORRECTED"></a><p><b>Table 2-2. Packed RGB Image Formats (corrected)</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="ID" align="LEFT" width="3%"><col title="FOURCC" width="3%"><col title="BIT" width="3%"><col title="B07" align="CENTER" width="3%"><col title="B06" align="CENTER" width="3%"><col title="B05" align="CENTER" width="3%"><col title="B04" align="CENTER" width="3%"><col title="B03" align="CENTER" width="3%"><col title="B02" align="CENTER" width="3%"><col title="B01" align="CENTER" width="3%"><col title="B00" align="CENTER" width="3%"><col><col title="B17" align="CENTER" width="3%"><col title="B16" align="CENTER" width="3%"><col title="B15" align="CENTER" width="3%"><col title="B14" align="CENTER" width="3%"><col title="B13" align="CENTER" width="3%"><col title="B12" align="CENTER" width="3%"><col title="B11" align="CENTER" width="3%"><col title="B10" align="CENTER" width="3%"><col><col title="B27" align="CENTER" width="3%"><col title="B26" align="CENTER" width="3%"><col title="B25" align="CENTER" width="3%"><col title="B24" align="CENTER" width="3%"><col title="B23" align="CENTER" width="3%"><col title="B22" align="CENTER" width="3%"><col title="B21" align="CENTER" width="3%"><col title="B20" align="CENTER" width="3%"><col><col title="B37" align="CENTER" width="3%"><col title="B36" align="CENTER" width="3%"><col title="B35" align="CENTER" width="3%"><col title="B34" align="CENTER" width="3%"><col title="B33" align="CENTER" width="3%"><col title="B32" align="CENTER" width="3%"><col title="B31" align="CENTER" width="3%"></colgroup><thead><tr><th>Identifier</th><th>Code</th><th>&nbsp;</th><th colspan="8">Byte&nbsp;0 in memory</th><th>&nbsp;</th><th colspan="8">Byte&nbsp;1</th><th>&nbsp;</th><th colspan="8">Byte&nbsp;2</th><th>&nbsp;</th><th colspan="8">Byte&nbsp;3</th></tr><tr><th>&nbsp;</th><th>&nbsp;</th><th>Bit</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th><th>&nbsp;</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th><th>&nbsp;</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th><th>&nbsp;</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_PIX_FMT_RGB332</code></td><td>'RGB1'</td><td>&nbsp;</td><td>r<sub>2</sub></td><td>r<sub>1</sub></td><td>r<sub>0</sub></td><td>g<sub>2</sub></td><td>g<sub>1</sub></td><td>g<sub>0</sub></td><td>b<sub>1</sub></td><td>b<sub>0</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_RGB444</code></td><td>'R444'</td><td>&nbsp;</td><td>g<sub>3</sub></td><td>g<sub>2</sub></td><td>g<sub>1</sub></td><td>g<sub>0</sub></td><td>b<sub>3</sub></td><td>b<sub>2</sub></td><td>b<sub>1</sub></td><td>b<sub>0</sub></td><td>&nbsp;</td><td>a<sub>3</sub></td><td>a<sub>2</sub></td><td>a<sub>1</sub></td><td>a<sub>0</sub></td><td>r<sub>3</sub></td><td>r<sub>2</sub></td><td>r<sub>1</sub></td><td>r<sub>0</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_RGB555</code></td><td>'RGBO'</td><td>&nbsp;</td><td>g<sub>2</sub></td><td>g<sub>1</sub></td><td>g<sub>0</sub></td><td>b<sub>4</sub></td><td>b<sub>3</sub></td><td>b<sub>2</sub></td><td>b<sub>1</sub></td><td>b<sub>0</sub></td><td>&nbsp;</td><td>a</td><td>r<sub>4</sub></td><td>r<sub>3</sub></td><td>r<sub>2</sub></td><td>r<sub>1</sub></td><td>r<sub>0</sub></td><td>g<sub>4</sub></td><td>g<sub>3</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_RGB565</code></td><td>'RGBP'</td><td>&nbsp;</td><td>g<sub>2</sub></td><td>g<sub>1</sub></td><td>g<sub>0</sub></td><td>b<sub>4</sub></td><td>b<sub>3</sub></td><td>b<sub>2</sub></td><td>b<sub>1</sub></td><td>b<sub>0</sub></td><td>&nbsp;</td><td>r<sub>4</sub></td><td>r<sub>3</sub></td><td>r<sub>2</sub></td><td>r<sub>1</sub></td><td>r<sub>0</sub></td><td>g<sub>5</sub></td><td>g<sub>4</sub></td><td>g<sub>3</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_RGB555X</code></td><td>'RGBQ'</td><td>&nbsp;</td><td>a</td><td>r<sub>4</sub></td><td>r<sub>3</sub></td><td>r<sub>2</sub></td><td>r<sub>1</sub></td><td>r<sub>0</sub></td><td>g<sub>4</sub></td><td>g<sub>3</sub></td><td>&nbsp;</td><td>g<sub>2</sub></td><td>g<sub>1</sub></td><td>g<sub>0</sub></td><td>b<sub>4</sub></td><td>b<sub>3</sub></td><td>b<sub>2</sub></td><td>b<sub>1</sub></td><td>b<sub>0</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_RGB565X</code></td><td>'RGBR'</td><td>&nbsp;</td><td>r<sub>4</sub></td><td>r<sub>3</sub></td><td>r<sub>2</sub></td><td>r<sub>1</sub></td><td>r<sub>0</sub></td><td>g<sub>5</sub></td><td>g<sub>4</sub></td><td>g<sub>3</sub></td><td>&nbsp;</td><td>g<sub>2</sub></td><td>g<sub>1</sub></td><td>g<sub>0</sub></td><td>b<sub>4</sub></td><td>b<sub>3</sub></td><td>b<sub>2</sub></td><td>b<sub>1</sub></td><td>b<sub>0</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_BGR24</code></td><td>'BGR3'</td><td>&nbsp;</td><td>b<sub>7</sub></td><td>b<sub>6</sub></td><td>b<sub>5</sub></td><td>b<sub>4</sub></td><td>b<sub>3</sub></td><td>b<sub>2</sub></td><td>b<sub>1</sub></td><td>b<sub>0</sub></td><td>&nbsp;</td><td>g<sub>7</sub></td><td>g<sub>6</sub></td><td>g<sub>5</sub></td><td>g<sub>4</sub></td><td>g<sub>3</sub></td><td>g<sub>2</sub></td><td>g<sub>1</sub></td><td>g<sub>0</sub></td><td>&nbsp;</td><td>r<sub>7</sub></td><td>r<sub>6</sub></td><td>r<sub>5</sub></td><td>r<sub>4</sub></td><td>r<sub>3</sub></td><td>r<sub>2</sub></td><td>r<sub>1</sub></td><td>r<sub>0</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_RGB24</code></td><td>'RGB3'</td><td>&nbsp;</td><td>r<sub>7</sub></td><td>r<sub>6</sub></td><td>r<sub>5</sub></td><td>r<sub>4</sub></td><td>r<sub>3</sub></td><td>r<sub>2</sub></td><td>r<sub>1</sub></td><td>r<sub>0</sub></td><td>&nbsp;</td><td>g<sub>7</sub></td><td>g<sub>6</sub></td><td>g<sub>5</sub></td><td>g<sub>4</sub></td><td>g<sub>3</sub></td><td>g<sub>2</sub></td><td>g<sub>1</sub></td><td>g<sub>0</sub></td><td>&nbsp;</td><td>b<sub>7</sub></td><td>b<sub>6</sub></td><td>b<sub>5</sub></td><td>b<sub>4</sub></td><td>b<sub>3</sub></td><td>b<sub>2</sub></td><td>b<sub>1</sub></td><td>b<sub>0</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_BGR32</code></td><td>'BGR4'</td><td>&nbsp;</td><td>b<sub>7</sub></td><td>b<sub>6</sub></td><td>b<sub>5</sub></td><td>b<sub>4</sub></td><td>b<sub>3</sub></td><td>b<sub>2</sub></td><td>b<sub>1</sub></td><td>b<sub>0</sub></td><td>&nbsp;</td><td>g<sub>7</sub></td><td>g<sub>6</sub></td><td>g<sub>5</sub></td><td>g<sub>4</sub></td><td>g<sub>3</sub></td><td>g<sub>2</sub></td><td>g<sub>1</sub></td><td>g<sub>0</sub></td><td>&nbsp;</td><td>r<sub>7</sub></td><td>r<sub>6</sub></td><td>r<sub>5</sub></td><td>r<sub>4</sub></td><td>r<sub>3</sub></td><td>r<sub>2</sub></td><td>r<sub>1</sub></td><td>r<sub>0</sub></td><td>&nbsp;</td><td>a<sub>7</sub></td><td>a<sub>6</sub></td><td>a<sub>5</sub></td><td>a<sub>4</sub></td><td>a<sub>3</sub></td><td>a<sub>2</sub></td><td>a<sub>1</sub></td><td>a<sub>0</sub></td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_RGB32</code></td><td>'RGB4'</td><td>&nbsp;</td><td>a<sub>7</sub></td><td>a<sub>6</sub></td><td>a<sub>5</sub></td><td>a<sub>4</sub></td><td>a<sub>3</sub></td><td>a<sub>2</sub></td><td>a<sub>1</sub></td><td>a<sub>0</sub></td><td>&nbsp;</td><td>r<sub>7</sub></td><td>r<sub>6</sub></td><td>r<sub>5</sub></td><td>r<sub>4</sub></td><td>r<sub>3</sub></td><td>r<sub>2</sub></td><td>r<sub>1</sub></td><td>r<sub>0</sub></td><td>&nbsp;</td><td>g<sub>7</sub></td><td>g<sub>6</sub></td><td>g<sub>5</sub></td><td>g<sub>4</sub></td><td>g<sub>3</sub></td><td>g<sub>2</sub></td><td>g<sub>1</sub></td><td>g<sub>0</sub></td><td>&nbsp;</td><td>b<sub>7</sub></td><td>b<sub>6</sub></td><td>b<sub>5</sub></td><td>b<sub>4</sub></td><td>b<sub>3</sub></td><td>b<sub>2</sub></td><td>b<sub>1</sub></td><td>b<sub>0</sub></td></tr></tbody></table></div><p>A test utility to determine which RGB formats a driver
actually supports is available from the LinuxTV v4l-dvb repository.
See <a href="http://linuxtv.org/repo/" target="_top">http://linuxtv.org/repo/</a> for access instructions.</p></div><h1><a name="V4L2-PIX-FMT-SBGGR8"></a>V4L2_PIX_FMT_SBGGR8 ('BA81')</h1><div class="REFNAMEDIV"><a name="AEN3739"></a><h2>Name</h2><code class="CONSTANT">V4L2_PIX_FMT_SBGGR8</code>&nbsp;--&nbsp;Bayer RGB format</div><div class="REFSECT1"><a name="AEN3743"></a><h2>Description</h2><p>This is commonly the native format of digital cameras,
reflecting the arrangement of sensors on the CCD device. Only one red,
green or blue value is given for each pixel. Missing components must
be interpolated from neighbouring pixels. From left to right the first
row consists of a blue and green value, the second row of a green and
red value. This scheme repeats to the right and down for every two
columns and rows.</p><div class="EXAMPLE"><a name="AEN3746"></a><p><b>Example 2-1. <code class="CONSTANT">V4L2_PIX_FMT_SBGGR8</code> 4 ¡Á 4
pixel image</b></p><div class="FORMALPARA"><p><b>Byte Order. </b>Each cell is one byte.
              </p><div class="INFORMALTABLE"><p></p><a name="AEN3752"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col align="LEFT" width="2*"><col><col><col><col></colgroup><tbody valign="TOP"><tr><td>start&nbsp;+&nbsp;0:</td><td>B<sub>00</sub></td><td>G<sub>01</sub></td><td>B<sub>02</sub></td><td>G<sub>03</sub></td></tr><tr><td>start&nbsp;+&nbsp;4:</td><td>G<sub>10</sub></td><td>R<sub>11</sub></td><td>G<sub>12</sub></td><td>R<sub>13</sub></td></tr><tr><td>start&nbsp;+&nbsp;8:</td><td>B<sub>20</sub></td><td>G<sub>21</sub></td><td>B<sub>22</sub></td><td>G<sub>23</sub></td></tr><tr><td>start&nbsp;+&nbsp;12:</td><td>G<sub>30</sub></td><td>R<sub>31</sub></td><td>G<sub>32</sub></td><td>R<sub>33</sub></td></tr></tbody></table><p></p></div>
            <p></p></div></div></div><h1><a name="V4L2-PIX-FMT-SBGGR16"></a>V4L2_PIX_FMT_SBGGR16 ('BA82')</h1><div class="REFNAMEDIV"><a name="AEN3800"></a><h2>Name</h2><code class="CONSTANT">V4L2_PIX_FMT_SBGGR16</code>&nbsp;--&nbsp;Bayer RGB format</div><div class="REFSECT1"><a name="AEN3804"></a><h2>Description</h2><p>This format is similar to <a href="#V4L2-PIX-FMT-SBGGR8"><code class="CONSTANT">V4L2_PIX_FMT_SBGGR8</code></a>, except each pixel has
a depth of 16 bits. The least significant byte is stored at lower
memory addresses (little-endian). Note the actual sampling precision
may be lower than 16 bits, for example 10 bits per pixel with values
in range 0 to 1023.</p><div class="EXAMPLE"><a name="AEN3809"></a><p><b>Example 2-1. <code class="CONSTANT">V4L2_PIX_FMT_SBGGR16</code> 4 ¡Á 4
pixel image</b></p><div class="FORMALPARA"><p><b>Byte Order. </b>Each cell is one byte.
          </p><div class="INFORMALTABLE"><p></p><a name="AEN3815"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col align="LEFT" width="2*"><col><col><col><col></colgroup><tbody valign="TOP"><tr><td>start&nbsp;+&nbsp;0:</td><td>B<sub>00low</sub></td><td>B<sub>00high</sub></td><td>G<sub>01low</sub></td><td>G<sub>01high</sub></td><td>B<sub>02low</sub></td><td>B<sub>02high</sub></td><td>G<sub>03low</sub></td><td>G<sub>03high</sub></td></tr><tr><td>start&nbsp;+&nbsp;8:</td><td>G<sub>10low</sub></td><td>G<sub>10high</sub></td><td>R<sub>11low</sub></td><td>R<sub>11high</sub></td><td>G<sub>12low</sub></td><td>G<sub>12high</sub></td><td>R<sub>13low</sub></td><td>R<sub>13high</sub></td></tr><tr><td>start&nbsp;+&nbsp;16:</td><td>B<sub>20low</sub></td><td>B<sub>20high</sub></td><td>G<sub>21low</sub></td><td>G<sub>21high</sub></td><td>B<sub>22low</sub></td><td>B<sub>22high</sub></td><td>G<sub>23low</sub></td><td>G<sub>23high</sub></td></tr><tr><td>start&nbsp;+&nbsp;24:</td><td>G<sub>30low</sub></td><td>G<sub>30high</sub></td><td>R<sub>31low</sub></td><td>R<sub>31high</sub></td><td>G<sub>32low</sub></td><td>G<sub>32high</sub></td><td>R<sub>33low</sub></td><td>R<sub>33high</sub></td></tr></tbody></table><p></p></div>
        <p></p></div></div></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="YUV-FORMATS">2.5. YUV Formats</a></h2><div class="TOC"><dl><dt><b>Table of Contents</b></dt><dt><a href="#PACKED-YUV">Packed YUV formats</a>&nbsp;--&nbsp;Packed YUV formats</dt><dt><a href="#V4L2-PIX-FMT-GREY">V4L2_PIX_FMT_GREY ('GREY')</a>&nbsp;--&nbsp;Grey-scale image</dt><dt><a href="#V4L2-PIX-FMT-Y16">V4L2_PIX_FMT_Y16 ('Y16 ')</a>&nbsp;--&nbsp;Grey-scale image</dt><dt><a href="#V4L2-PIX-FMT-YUYV">V4L2_PIX_FMT_YUYV ('YUYV')</a>&nbsp;--&nbsp;Packed format with &#189; horizontal chroma
resolution, also known as YUV 4:2:2</dt><dt><a href="#V4L2-PIX-FMT-UYVY">V4L2_PIX_FMT_UYVY ('UYVY')</a>&nbsp;--&nbsp;Variation of
<code class="CONSTANT">V4L2_PIX_FMT_YUYV</code> with different order of samples
in memory</dt><dt><a href="#V4L2-PIX-FMT-Y41P">V4L2_PIX_FMT_Y41P ('Y41P')</a>&nbsp;--&nbsp;Format with &#188; horizontal chroma
resolution, also known as YUV 4:1:1</dt><dt><a href="#AEN4850">V4L2_PIX_FMT_YVU420 ('YV12'), V4L2_PIX_FMT_YUV420 ('YU12')</a>&nbsp;--&nbsp;Planar formats with &#189; horizontal and
vertical chroma resolution, also known as YUV 4:2:0</dt><dt><a href="#AEN5016">V4L2_PIX_FMT_YVU410 ('YVU9'), V4L2_PIX_FMT_YUV410 ('YUV9')</a>&nbsp;--&nbsp;Planar formats with &#188; horizontal and
vertical chroma resolution, also known as YUV 4:1:0</dt><dt><a href="#V4L2-PIX-FMT-YUV422P">V4L2_PIX_FMT_YUV422P ('422P')</a>&nbsp;--&nbsp;Format with &#189; horizontal chroma resolution,
also known as YUV 4:2:2. Planar layout as opposed to
<code class="CONSTANT">V4L2_PIX_FMT_YUYV</code></dt><dt><a href="#V4L2-PIX-FMT-YUV411P">V4L2_PIX_FMT_YUV411P ('411P')</a>&nbsp;--&nbsp;Format with &#188; horizontal chroma resolution,
also known as YUV 4:1:1. Planar layout as opposed to
<code class="CONSTANT">V4L2_PIX_FMT_Y41P</code></dt><dt><a href="#AEN5470">V4L2_PIX_FMT_NV12 ('NV12'), V4L2_PIX_FMT_NV21 ('NV21')</a>&nbsp;--&nbsp;Formats with &#189; horizontal and vertical
chroma resolution, also known as YUV 4:2:0. One luminance and one
chrominance plane with alternating chroma samples as opposed to
<code class="CONSTANT">V4L2_PIX_FMT_YVU420</code></dt></dl></div><p>YUV is the format native to TV broadcast and composite video
signals. It separates the brightness information (Y) from the color
information (U and V or Cb and Cr). The color information consists of
red and blue <span class="emphasis"><i class="EMPHASIS">color difference</i></span> signals, this way
the green component can be reconstructed by subtracting from the
brightness component. See <a href="#COLORSPACES">Section 2.2</a> for conversion
examples. YUV was chosen because early television would only transmit
brightness information. To add color in a way compatible with existing
receivers a new signal carrier was added to transmit the color
difference signals. Secondary in the YUV format the U and V components
usually have lower resolution than the Y component. This is an analog
video compression technique taking advantage of a property of the
human visual system, being more sensitive to brightness
information.</p><h1><a name="PACKED-YUV"></a>Packed YUV formats</h1><div class="REFNAMEDIV"><a name="AEN3900"></a><h2>Name</h2>Packed YUV formats&nbsp;--&nbsp;Packed YUV formats</div><div class="REFSECT1"><a name="AEN3903"></a><h2>Description</h2><p>Similar to the packed RGB formats these formats store
the Y, Cb and Cr component of each pixel in one 16 or 32 bit
word.</p><div class="TABLE"><a name="AEN3906"></a><p><b>Table 2-1. Packed YUV Image Formats</b></p><a name="V4L2-PIX-FMT-YUV444"></a><a name="V4L2-PIX-FMT-YUV555"></a><a name="V4L2-PIX-FMT-YUV565"></a><a name="V4L2-PIX-FMT-YUV32"></a><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="ID" align="LEFT" width="3%"><col title="FOURCC" width="3%"><col title="BIT" width="3%"><col title="B07" align="CENTER" width="3%"><col title="B06" align="CENTER" width="3%"><col title="B05" align="CENTER" width="3%"><col title="B04" align="CENTER" width="3%"><col title="B03" align="CENTER" width="3%"><col title="B02" align="CENTER" width="3%"><col title="B01" align="CENTER" width="3%"><col title="B00" align="CENTER" width="3%"><col><col title="B17" align="CENTER" width="3%"><col title="B16" align="CENTER" width="3%"><col title="B15" align="CENTER" width="3%"><col title="B14" align="CENTER" width="3%"><col title="B13" align="CENTER" width="3%"><col title="B12" align="CENTER" width="3%"><col title="B11" align="CENTER" width="3%"><col title="B10" align="CENTER" width="3%"><col><col title="B27" align="CENTER" width="3%"><col title="B26" align="CENTER" width="3%"><col title="B25" align="CENTER" width="3%"><col title="B24" align="CENTER" width="3%"><col title="B23" align="CENTER" width="3%"><col title="B22" align="CENTER" width="3%"><col title="B21" align="CENTER" width="3%"><col title="B20" align="CENTER" width="3%"><col><col title="B37" align="CENTER" width="3%"><col title="B36" align="CENTER" width="3%"><col title="B35" align="CENTER" width="3%"><col title="B34" align="CENTER" width="3%"><col title="B33" align="CENTER" width="3%"><col title="B32" align="CENTER" width="3%"><col title="B31" align="CENTER" width="3%"></colgroup><thead><tr><th>Identifier</th><th>Code</th><th>&nbsp;</th><th colspan="8">Byte&nbsp;0 in memory</th><th>&nbsp;</th><th colspan="8">Byte&nbsp;1</th><th>&nbsp;</th><th colspan="8">Byte&nbsp;2</th><th>&nbsp;</th><th colspan="8">Byte&nbsp;3</th></tr><tr><th>&nbsp;</th><th>&nbsp;</th><th>Bit</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th><th>&nbsp;</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th><th>&nbsp;</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th><th>&nbsp;</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_PIX_FMT_YUV444</code></td><td>'Y444'</td><td>&nbsp;</td><td>Cb<sub>3</sub></td><td>Cb<sub>2</sub></td><td>Cb<sub>1</sub></td><td>Cb<sub>0</sub></td><td>Cr<sub>3</sub></td><td>Cr<sub>2</sub></td><td>Cr<sub>1</sub></td><td>Cr<sub>0</sub></td><td>&nbsp;</td><td>a<sub>3</sub></td><td>a<sub>2</sub></td><td>a<sub>1</sub></td><td>a<sub>0</sub></td><td>Y'<sub>3</sub></td><td>Y'<sub>2</sub></td><td>Y'<sub>1</sub></td><td>Y'<sub>0</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_YUV555</code></td><td>'YUVO'</td><td>&nbsp;</td><td>Cb<sub>2</sub></td><td>Cb<sub>1</sub></td><td>Cb<sub>0</sub></td><td>Cr<sub>4</sub></td><td>Cr<sub>3</sub></td><td>Cr<sub>2</sub></td><td>Cr<sub>1</sub></td><td>Cr<sub>0</sub></td><td>&nbsp;</td><td>a</td><td>Y'<sub>4</sub></td><td>Y'<sub>3</sub></td><td>Y'<sub>2</sub></td><td>Y'<sub>1</sub></td><td>Y'<sub>0</sub></td><td>Cb<sub>4</sub></td><td>Cb<sub>3</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_YUV565</code></td><td>'YUVP'</td><td>&nbsp;</td><td>Cb<sub>2</sub></td><td>Cb<sub>1</sub></td><td>Cb<sub>0</sub></td><td>Cr<sub>4</sub></td><td>Cr<sub>3</sub></td><td>Cr<sub>2</sub></td><td>Cr<sub>1</sub></td><td>Cr<sub>0</sub></td><td>&nbsp;</td><td>Y'<sub>4</sub></td><td>Y'<sub>3</sub></td><td>Y'<sub>2</sub></td><td>Y'<sub>1</sub></td><td>Y'<sub>0</sub></td><td>Cb<sub>5</sub></td><td>Cb<sub>4</sub></td><td>Cb<sub>3</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_YUV32</code></td><td>'YUV4'</td><td>&nbsp;</td><td>a<sub>7</sub></td><td>a<sub>6</sub></td><td>a<sub>5</sub></td><td>a<sub>4</sub></td><td>a<sub>3</sub></td><td>a<sub>2</sub></td><td>a<sub>1</sub></td><td>a<sub>0</sub></td><td>&nbsp;</td><td>Y'<sub>7</sub></td><td>Y'<sub>6</sub></td><td>Y'<sub>5</sub></td><td>Y'<sub>4</sub></td><td>Y'<sub>3</sub></td><td>Y'<sub>2</sub></td><td>Y'<sub>1</sub></td><td>Y'<sub>0</sub></td><td>&nbsp;</td><td>Cb<sub>7</sub></td><td>Cb<sub>6</sub></td><td>Cb<sub>5</sub></td><td>Cb<sub>4</sub></td><td>Cb<sub>3</sub></td><td>Cb<sub>2</sub></td><td>Cb<sub>1</sub></td><td>Cb<sub>0</sub></td><td>&nbsp;</td><td>Cr<sub>7</sub></td><td>Cr<sub>6</sub></td><td>Cr<sub>5</sub></td><td>Cr<sub>4</sub></td><td>Cr<sub>3</sub></td><td>Cr<sub>2</sub></td><td>Cr<sub>1</sub></td><td>Cr<sub>0</sub></td></tr></tbody></table></div><p>Bit 7 is the most significant bit. The value of a = alpha
bits is undefined when reading from the driver, ignored when writing
to the driver, except when alpha blending has been negotiated for a
<a href="#OVERLAY">Video Overlay</a> or <a href="#OSD">Video Output Overlay</a>.</p></div><h1><a name="V4L2-PIX-FMT-GREY"></a>V4L2_PIX_FMT_GREY ('GREY')</h1><div class="REFNAMEDIV"><a name="AEN4189"></a><h2>Name</h2><code class="CONSTANT">V4L2_PIX_FMT_GREY</code>&nbsp;--&nbsp;Grey-scale image</div><div class="REFSECT1"><a name="AEN4193"></a><h2>Description</h2><p>This is a grey-scale image. It is really a degenerate
Y'CbCr format which simply contains no Cb or Cr data.</p><div class="EXAMPLE"><a name="AEN4196"></a><p><b>Example 2-1. <code class="CONSTANT">V4L2_PIX_FMT_GREY</code> 4 ¡Á 4
pixel image</b></p><div class="FORMALPARA"><p><b>Byte Order. </b>Each cell is one byte.
                </p><div class="INFORMALTABLE"><p></p><a name="AEN4202"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col align="LEFT" width="2*"><col><col><col><col></colgroup><tbody valign="TOP"><tr><td>start&nbsp;+&nbsp;0:</td><td>Y'<sub>00</sub></td><td>Y'<sub>01</sub></td><td>Y'<sub>02</sub></td><td>Y'<sub>03</sub></td></tr><tr><td>start&nbsp;+&nbsp;4:</td><td>Y'<sub>10</sub></td><td>Y'<sub>11</sub></td><td>Y'<sub>12</sub></td><td>Y'<sub>13</sub></td></tr><tr><td>start&nbsp;+&nbsp;8:</td><td>Y'<sub>20</sub></td><td>Y'<sub>21</sub></td><td>Y'<sub>22</sub></td><td>Y'<sub>23</sub></td></tr><tr><td>start&nbsp;+&nbsp;12:</td><td>Y'<sub>30</sub></td><td>Y'<sub>31</sub></td><td>Y'<sub>32</sub></td><td>Y'<sub>33</sub></td></tr></tbody></table><p></p></div>
              <p></p></div></div></div><h1><a name="V4L2-PIX-FMT-Y16"></a>V4L2_PIX_FMT_Y16 ('Y16 ')</h1><div class="REFNAMEDIV"><a name="AEN4250"></a><h2>Name</h2><code class="CONSTANT">V4L2_PIX_FMT_Y16</code>&nbsp;--&nbsp;Grey-scale image</div><div class="REFSECT1"><a name="AEN4254"></a><h2>Description</h2><p>This is a grey-scale image with a depth of 16 bits per
pixel. The least significant byte is stored at lower memory addresses
(little-endian). Note the actual sampling precision may be lower than
16 bits, for example 10 bits per pixel with values in range 0 to
1023.</p><div class="EXAMPLE"><a name="AEN4257"></a><p><b>Example 2-1. <code class="CONSTANT">V4L2_PIX_FMT_Y16</code> 4 ¡Á 4
pixel image</b></p><div class="FORMALPARA"><p><b>Byte Order. </b>Each cell is one byte.
          </p><div class="INFORMALTABLE"><p></p><a name="AEN4263"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col align="LEFT" width="2*"><col><col><col><col><col><col><col><col></colgroup><tbody valign="TOP"><tr><td>start&nbsp;+&nbsp;0:</td><td>Y'<sub>00low</sub></td><td>Y'<sub>00high</sub></td><td>Y'<sub>01low</sub></td><td>Y'<sub>01high</sub></td><td>Y'<sub>02low</sub></td><td>Y'<sub>02high</sub></td><td>Y'<sub>03low</sub></td><td>Y'<sub>03high</sub></td></tr><tr><td>start&nbsp;+&nbsp;8:</td><td>Y'<sub>10low</sub></td><td>Y'<sub>10high</sub></td><td>Y'<sub>11low</sub></td><td>Y'<sub>11high</sub></td><td>Y'<sub>12low</sub></td><td>Y'<sub>12high</sub></td><td>Y'<sub>13low</sub></td><td>Y'<sub>13high</sub></td></tr><tr><td>start&nbsp;+&nbsp;16:</td><td>Y'<sub>20low</sub></td><td>Y'<sub>20high</sub></td><td>Y'<sub>21low</sub></td><td>Y'<sub>21high</sub></td><td>Y'<sub>22low</sub></td><td>Y'<sub>22high</sub></td><td>Y'<sub>23low</sub></td><td>Y'<sub>23high</sub></td></tr><tr><td>start&nbsp;+&nbsp;24:</td><td>Y'<sub>30low</sub></td><td>Y'<sub>30high</sub></td><td>Y'<sub>31low</sub></td><td>Y'<sub>31high</sub></td><td>Y'<sub>32low</sub></td><td>Y'<sub>32high</sub></td><td>Y'<sub>33low</sub></td><td>Y'<sub>33high</sub></td></tr></tbody></table><p></p></div>
        <p></p></div></div></div><h1><a name="V4L2-PIX-FMT-YUYV"></a>V4L2_PIX_FMT_YUYV ('YUYV')</h1><div class="REFNAMEDIV"><a name="AEN4343"></a><h2>Name</h2><code class="CONSTANT">V4L2_PIX_FMT_YUYV</code>&nbsp;--&nbsp;Packed format with &#189; horizontal chroma
resolution, also known as YUV 4:2:2</div><div class="REFSECT1"><a name="AEN4347"></a><h2>Description</h2><p>In this format each four bytes is two pixels. Each four
bytes is two Y's, a Cb and a Cr. Each Y goes to one of the pixels, and
the Cb and Cr belong to both pixels. As you can see, the Cr and Cb
components have half the horizontal resolution of the Y component.
<code class="CONSTANT">V4L2_PIX_FMT_YUYV </code> is known in the Windows
environment as YUY2.</p><div class="EXAMPLE"><a name="AEN4351"></a><p><b>Example 2-1. <code class="CONSTANT">V4L2_PIX_FMT_YUYV</code> 4 ¡Á 4
pixel image</b></p><div class="FORMALPARA"><p><b>Byte Order. </b>Each cell is one byte.
                </p><div class="INFORMALTABLE"><p></p><a name="AEN4357"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col align="LEFT" width="2*"><col><col><col><col><col><col><col><col></colgroup><tbody valign="TOP"><tr><td>start&nbsp;+&nbsp;0:</td><td>Y'<sub>00</sub></td><td>Cb<sub>00</sub></td><td>Y'<sub>01</sub></td><td>Cr<sub>00</sub></td><td>Y'<sub>02</sub></td><td>Cb<sub>01</sub></td><td>Y'<sub>03</sub></td><td>Cr<sub>01</sub></td></tr><tr><td>start&nbsp;+&nbsp;8:</td><td>Y'<sub>10</sub></td><td>Cb<sub>10</sub></td><td>Y'<sub>11</sub></td><td>Cr<sub>10</sub></td><td>Y'<sub>12</sub></td><td>Cb<sub>11</sub></td><td>Y'<sub>13</sub></td><td>Cr<sub>11</sub></td></tr><tr><td>start&nbsp;+&nbsp;16:</td><td>Y'<sub>20</sub></td><td>Cb<sub>20</sub></td><td>Y'<sub>21</sub></td><td>Cr<sub>20</sub></td><td>Y'<sub>22</sub></td><td>Cb<sub>21</sub></td><td>Y'<sub>23</sub></td><td>Cr<sub>21</sub></td></tr><tr><td>start&nbsp;+&nbsp;24:</td><td>Y'<sub>30</sub></td><td>Cb<sub>30</sub></td><td>Y'<sub>31</sub></td><td>Cr<sub>30</sub></td><td>Y'<sub>32</sub></td><td>Cb<sub>31</sub></td><td>Y'<sub>33</sub></td><td>Cr<sub>31</sub></td></tr></tbody></table><p></p></div>
              <p></p></div><div class="FORMALPARA"><p><b>Color Sample Location. </b>                </p><div class="INFORMALTABLE"><p></p><a name="AEN4436"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="TOP"><tr><td>&nbsp;</td><td>0</td><td>&nbsp;</td><td>1</td><td>&nbsp;</td><td>2</td><td>&nbsp;</td><td>3</td></tr><tr><td>0</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td></tr><tr><td>1</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td></tr><tr><td>2</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td></tr><tr><td>3</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td></tr></tbody></table><p></p></div>
              <p></p></div></div></div><h1><a name="V4L2-PIX-FMT-UYVY"></a>V4L2_PIX_FMT_UYVY ('UYVY')</h1><div class="REFNAMEDIV"><a name="AEN4488"></a><h2>Name</h2><code class="CONSTANT">V4L2_PIX_FMT_UYVY</code>&nbsp;--&nbsp;Variation of
<code class="CONSTANT">V4L2_PIX_FMT_YUYV</code> with different order of samples
in memory</div><div class="REFSECT1"><a name="AEN4493"></a><h2>Description</h2><p>In this format each four bytes is two pixels. Each four
bytes is two Y's, a Cb and a Cr. Each Y goes to one of the pixels, and
the Cb and Cr belong to both pixels. As you can see, the Cr and Cb
components have half the horizontal resolution of the Y
component.</p><div class="EXAMPLE"><a name="AEN4496"></a><p><b>Example 2-1. <code class="CONSTANT">V4L2_PIX_FMT_UYVY</code> 4 ¡Á 4
pixel image</b></p><div class="FORMALPARA"><p><b>Byte Order. </b>Each cell is one byte.
                </p><div class="INFORMALTABLE"><p></p><a name="AEN4502"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col align="LEFT" width="2*"><col><col><col><col><col><col><col><col></colgroup><tbody valign="TOP"><tr><td>start&nbsp;+&nbsp;0:</td><td>Cb<sub>00</sub></td><td>Y'<sub>00</sub></td><td>Cr<sub>00</sub></td><td>Y'<sub>01</sub></td><td>Cb<sub>01</sub></td><td>Y'<sub>02</sub></td><td>Cr<sub>01</sub></td><td>Y'<sub>03</sub></td></tr><tr><td>start&nbsp;+&nbsp;8:</td><td>Cb<sub>10</sub></td><td>Y'<sub>10</sub></td><td>Cr<sub>10</sub></td><td>Y'<sub>11</sub></td><td>Cb<sub>11</sub></td><td>Y'<sub>12</sub></td><td>Cr<sub>11</sub></td><td>Y'<sub>13</sub></td></tr><tr><td>start&nbsp;+&nbsp;16:</td><td>Cb<sub>20</sub></td><td>Y'<sub>20</sub></td><td>Cr<sub>20</sub></td><td>Y'<sub>21</sub></td><td>Cb<sub>21</sub></td><td>Y'<sub>22</sub></td><td>Cr<sub>21</sub></td><td>Y'<sub>23</sub></td></tr><tr><td>start&nbsp;+&nbsp;24:</td><td>Cb<sub>30</sub></td><td>Y'<sub>30</sub></td><td>Cr<sub>30</sub></td><td>Y'<sub>31</sub></td><td>Cb<sub>31</sub></td><td>Y'<sub>32</sub></td><td>Cr<sub>31</sub></td><td>Y'<sub>33</sub></td></tr></tbody></table><p></p></div>
              <p></p></div><div class="FORMALPARA"><p><b>Color Sample Location. </b>                </p><div class="INFORMALTABLE"><p></p><a name="AEN4581"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="TOP"><tr><td>&nbsp;</td><td>0</td><td>&nbsp;</td><td>1</td><td>&nbsp;</td><td>2</td><td>&nbsp;</td><td>3</td></tr><tr><td>0</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td></tr><tr><td>1</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td></tr><tr><td>2</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td></tr><tr><td>3</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td></tr></tbody></table><p></p></div>
              <p></p></div></div></div><h1><a name="V4L2-PIX-FMT-Y41P"></a>V4L2_PIX_FMT_Y41P ('Y41P')</h1><div class="REFNAMEDIV"><a name="AEN4633"></a><h2>Name</h2><code class="CONSTANT">V4L2_PIX_FMT_Y41P</code>&nbsp;--&nbsp;Format with &#188; horizontal chroma
resolution, also known as YUV 4:1:1</div><div class="REFSECT1"><a name="AEN4637"></a><h2>Description</h2><p>In this format each 12 bytes is eight pixels. In the
twelve bytes are two CbCr pairs and eight Y's. The first CbCr pair
goes with the first four Y's, and the second CbCr pair goes with the
other four Y's. The Cb and Cr components have one fourth the
horizontal resolution of the Y component.</p><p>Do not confuse this format with <a href="#V4L2-PIX-FMT-YUV411P"><code class="CONSTANT">V4L2_PIX_FMT_YUV411P</code></a>. 
Y41P is derived from "YUV 4:1:1 <span class="emphasis"><i class="EMPHASIS">packed</i></span>", while
YUV411P stands for "YUV 4:1:1 <span class="emphasis"><i class="EMPHASIS">planar</i></span>".</p><div class="EXAMPLE"><a name="AEN4645"></a><p><b>Example 2-1. <code class="CONSTANT">V4L2_PIX_FMT_Y41P</code> 8 ¡Á 4
pixel image</b></p><div class="FORMALPARA"><p><b>Byte Order. </b>Each cell is one byte.
                </p><div class="INFORMALTABLE"><p></p><a name="AEN4651"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col align="LEFT" width="2*"><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><tbody valign="TOP"><tr><td>start&nbsp;+&nbsp;0:</td><td>Cb<sub>00</sub></td><td>Y'<sub>00</sub></td><td>Cr<sub>00</sub></td><td>Y'<sub>01</sub></td><td>Cb<sub>01</sub></td><td>Y'<sub>02</sub></td><td>Cr<sub>01</sub></td><td>Y'<sub>03</sub></td><td>Y'<sub>04</sub></td><td>Y'<sub>05</sub></td><td>Y'<sub>06</sub></td><td>Y'<sub>07</sub></td></tr><tr><td>start&nbsp;+&nbsp;12:</td><td>Cb<sub>10</sub></td><td>Y'<sub>10</sub></td><td>Cr<sub>10</sub></td><td>Y'<sub>11</sub></td><td>Cb<sub>11</sub></td><td>Y'<sub>12</sub></td><td>Cr<sub>11</sub></td><td>Y'<sub>13</sub></td><td>Y'<sub>14</sub></td><td>Y'<sub>15</sub></td><td>Y'<sub>16</sub></td><td>Y'<sub>17</sub></td></tr><tr><td>start&nbsp;+&nbsp;24:</td><td>Cb<sub>20</sub></td><td>Y'<sub>20</sub></td><td>Cr<sub>20</sub></td><td>Y'<sub>21</sub></td><td>Cb<sub>21</sub></td><td>Y'<sub>22</sub></td><td>Cr<sub>21</sub></td><td>Y'<sub>23</sub></td><td>Y'<sub>24</sub></td><td>Y'<sub>25</sub></td><td>Y'<sub>26</sub></td><td>Y'<sub>27</sub></td></tr><tr><td>start&nbsp;+&nbsp;36:</td><td>Cb<sub>30</sub></td><td>Y'<sub>30</sub></td><td>Cr<sub>30</sub></td><td>Y'<sub>31</sub></td><td>Cb<sub>31</sub></td><td>Y'<sub>32</sub></td><td>Cr<sub>31</sub></td><td>Y'<sub>33</sub></td><td>Y'<sub>34</sub></td><td>Y'<sub>35</sub></td><td>Y'<sub>36</sub></td><td>Y'<sub>37</sub></td></tr></tbody></table><p></p></div><p></p></div><div class="FORMALPARA"><p><b>Color Sample Location. </b>                </p><div class="INFORMALTABLE"><p></p><a name="AEN4762"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><tbody valign="TOP"><tr><td>&nbsp;</td><td>0</td><td>&nbsp;</td><td>1</td><td>&nbsp;</td><td>2</td><td>&nbsp;</td><td>3</td><td>&nbsp;</td><td>4</td><td>&nbsp;</td><td>5</td><td>&nbsp;</td><td>6</td><td>&nbsp;</td><td>7</td></tr><tr><td>0</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td></tr><tr><td>1</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td></tr><tr><td>2</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td></tr><tr><td>3</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td></tr></tbody></table><p></p></div>
              <p></p></div></div></div><h1><a name="AEN4850"></a>V4L2_PIX_FMT_YVU420 ('YV12'), V4L2_PIX_FMT_YUV420 ('YU12')</h1><div class="REFNAMEDIV"><a name="AEN4854"></a><h2>Name</h2><code class="CONSTANT">V4L2_PIX_FMT_YVU420</code>, <code class="CONSTANT">V4L2_PIX_FMT_YUV420</code>&nbsp;--&nbsp;Planar formats with &#189; horizontal and
vertical chroma resolution, also known as YUV 4:2:0</div><div class="REFSECT1"><a name="AEN4860"></a><h2>Description</h2><p>These are planar formats, as opposed to a packed format.
The three components are separated into three sub- images or planes.
The Y plane is first. The Y plane has one byte per pixel. For
<code class="CONSTANT">V4L2_PIX_FMT_YVU420</code>, the Cr plane immediately
follows the Y plane in memory. The Cr plane is half the width and half
the height of the Y plane (and of the image). Each Cr belongs to four
pixels, a two-by-two square of the image. For example,
Cr<sub>0</sub> belongs to Y'<sub>00</sub>,
Y'<sub>01</sub>, Y'<sub>10</sub>, and
Y'<sub>11</sub>. Following the Cr plane is the Cb plane,
just like the Cr plane. <code class="CONSTANT">V4L2_PIX_FMT_YUV420</code> is
the same except the Cb plane comes first, then the Cr plane.</p><p>If the Y plane has pad bytes after each row, then the Cr
and Cb planes have half as many pad bytes after their rows. In other
words, two Cx rows (including padding) is exactly as long as one Y row
(including padding).</p><div class="EXAMPLE"><a name="AEN4871"></a><p><b>Example 2-1. <code class="CONSTANT">V4L2_PIX_FMT_YVU420</code> 4 ¡Á 4
pixel image</b></p><div class="FORMALPARA"><p><b>Byte Order. </b>Each cell is one byte.
                </p><div class="INFORMALTABLE"><p></p><a name="AEN4877"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col align="LEFT" width="2*"><col><col><col><col></colgroup><tbody valign="TOP"><tr><td>start&nbsp;+&nbsp;0:</td><td>Y'<sub>00</sub></td><td>Y'<sub>01</sub></td><td>Y'<sub>02</sub></td><td>Y'<sub>03</sub></td></tr><tr><td>start&nbsp;+&nbsp;4:</td><td>Y'<sub>10</sub></td><td>Y'<sub>11</sub></td><td>Y'<sub>12</sub></td><td>Y'<sub>13</sub></td></tr><tr><td>start&nbsp;+&nbsp;8:</td><td>Y'<sub>20</sub></td><td>Y'<sub>21</sub></td><td>Y'<sub>22</sub></td><td>Y'<sub>23</sub></td></tr><tr><td>start&nbsp;+&nbsp;12:</td><td>Y'<sub>30</sub></td><td>Y'<sub>31</sub></td><td>Y'<sub>32</sub></td><td>Y'<sub>33</sub></td></tr><tr><td>start&nbsp;+&nbsp;16:</td><td>Cr<sub>00</sub></td><td>Cr<sub>01</sub></td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>start&nbsp;+&nbsp;18:</td><td>Cr<sub>10</sub></td><td>Cr<sub>11</sub></td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>start&nbsp;+&nbsp;20:</td><td>Cb<sub>00</sub></td><td>Cb<sub>01</sub></td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>start&nbsp;+&nbsp;22:</td><td>Cb<sub>10</sub></td><td>Cb<sub>11</sub></td><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table><p></p></div>
              <p></p></div><div class="FORMALPARA"><p><b>Color Sample Location. </b>                </p><div class="INFORMALTABLE"><p></p><a name="AEN4948"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="TOP"><tr><td>&nbsp;</td><td>0</td><td>&nbsp;</td><td>1</td><td>&nbsp;</td><td>2</td><td>&nbsp;</td><td>3</td></tr><tr><td>0</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>C</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>C</td><td>&nbsp;</td></tr><tr><td>1</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>2</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>C</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>C</td><td>&nbsp;</td></tr><tr><td>3</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td></tr></tbody></table><p></p></div>
              <p></p></div></div></div><h1><a name="AEN5016"></a>V4L2_PIX_FMT_YVU410 ('YVU9'), V4L2_PIX_FMT_YUV410 ('YUV9')</h1><div class="REFNAMEDIV"><a name="AEN5020"></a><h2>Name</h2><code class="CONSTANT">V4L2_PIX_FMT_YVU410</code>, <code class="CONSTANT">V4L2_PIX_FMT_YUV410</code>&nbsp;--&nbsp;Planar formats with &#188; horizontal and
vertical chroma resolution, also known as YUV 4:1:0</div><div class="REFSECT1"><a name="AEN5026"></a><h2>Description</h2><p>These are planar formats, as opposed to a packed format.
The three components are separated into three sub-images or planes.
The Y plane is first. The Y plane has one byte per pixel. For
<code class="CONSTANT">V4L2_PIX_FMT_YVU410</code>, the Cr plane immediately
follows the Y plane in memory. The Cr plane is &#188; the width and
&#188; the height of the Y plane (and of the image). Each Cr belongs
to 16 pixels, a four-by-four square of the image. Following the Cr
plane is the Cb plane, just like the Cr plane.
<code class="CONSTANT">V4L2_PIX_FMT_YUV410</code> is the same, except the Cb
plane comes first, then the Cr plane.</p><p>If the Y plane has pad bytes after each row, then the Cr
and Cb planes have &#188; as many pad bytes after their rows. In
other words, four Cx rows (including padding) are exactly as long as
one Y row (including padding).</p><div class="EXAMPLE"><a name="AEN5032"></a><p><b>Example 2-1. <code class="CONSTANT">V4L2_PIX_FMT_YVU410</code> 4 ¡Á 4
pixel image</b></p><div class="FORMALPARA"><p><b>Byte Order. </b>Each cell is one byte.
                </p><div class="INFORMALTABLE"><p></p><a name="AEN5038"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col align="LEFT" width="2*"><col><col><col><col></colgroup><tbody valign="TOP"><tr><td>start&nbsp;+&nbsp;0:</td><td>Y'<sub>00</sub></td><td>Y'<sub>01</sub></td><td>Y'<sub>02</sub></td><td>Y'<sub>03</sub></td></tr><tr><td>start&nbsp;+&nbsp;4:</td><td>Y'<sub>10</sub></td><td>Y'<sub>11</sub></td><td>Y'<sub>12</sub></td><td>Y'<sub>13</sub></td></tr><tr><td>start&nbsp;+&nbsp;8:</td><td>Y'<sub>20</sub></td><td>Y'<sub>21</sub></td><td>Y'<sub>22</sub></td><td>Y'<sub>23</sub></td></tr><tr><td>start&nbsp;+&nbsp;12:</td><td>Y'<sub>30</sub></td><td>Y'<sub>31</sub></td><td>Y'<sub>32</sub></td><td>Y'<sub>33</sub></td></tr><tr><td>start&nbsp;+&nbsp;16:</td><td>Cr<sub>00</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>start&nbsp;+&nbsp;17:</td><td>Cb<sub>00</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table><p></p></div>
              <p></p></div><div class="FORMALPARA"><p><b>Color Sample Location. </b>                </p><div class="INFORMALTABLE"><p></p><a name="AEN5093"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="TOP"><tr><td>&nbsp;</td><td>0</td><td>&nbsp;</td><td>1</td><td>&nbsp;</td><td>2</td><td>&nbsp;</td><td>3</td></tr><tr><td>0</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>1</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>C</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>2</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>3</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td></tr></tbody></table><p></p></div>
              <p></p></div></div></div><h1><a name="V4L2-PIX-FMT-YUV422P"></a>V4L2_PIX_FMT_YUV422P ('422P')</h1><div class="REFNAMEDIV"><a name="AEN5158"></a><h2>Name</h2><code class="CONSTANT">V4L2_PIX_FMT_YUV422P</code>&nbsp;--&nbsp;Format with &#189; horizontal chroma resolution,
also known as YUV 4:2:2. Planar layout as opposed to
<code class="CONSTANT">V4L2_PIX_FMT_YUYV</code></div><div class="REFSECT1"><a name="AEN5163"></a><h2>Description</h2><p>This format is not commonly used. This is a planar
version of the YUYV format. The three components are separated into
three sub-images or planes. The Y plane is first. The Y plane has one
byte per pixel. The Cb plane immediately follows the Y plane in
memory. The Cb plane is half the width of the Y plane (and of the
image). Each Cb belongs to two pixels. For example,
Cb<sub>0</sub> belongs to Y'<sub>00</sub>,
Y'<sub>01</sub>. Following the Cb plane is the Cr plane,
just like the Cb plane.</p><p>If the Y plane has pad bytes after each row, then the Cr
and Cb planes have half as many pad bytes after their rows. In other
words, two Cx rows (including padding) is exactly as long as one Y row
(including padding).</p><div class="EXAMPLE"><a name="AEN5170"></a><p><b>Example 2-1. <code class="CONSTANT">V4L2_PIX_FMT_YUV422P</code> 4 ¡Á 4
pixel image</b></p><div class="FORMALPARA"><p><b>Byte Order. </b>Each cell is one byte.
                </p><div class="INFORMALTABLE"><p></p><a name="AEN5176"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col align="LEFT" width="2*"><col><col><col><col></colgroup><tbody valign="TOP"><tr><td>start&nbsp;+&nbsp;0:</td><td>Y'<sub>00</sub></td><td>Y'<sub>01</sub></td><td>Y'<sub>02</sub></td><td>Y'<sub>03</sub></td></tr><tr><td>start&nbsp;+&nbsp;4:</td><td>Y'<sub>10</sub></td><td>Y'<sub>11</sub></td><td>Y'<sub>12</sub></td><td>Y'<sub>13</sub></td></tr><tr><td>start&nbsp;+&nbsp;8:</td><td>Y'<sub>20</sub></td><td>Y'<sub>21</sub></td><td>Y'<sub>22</sub></td><td>Y'<sub>23</sub></td></tr><tr><td>start&nbsp;+&nbsp;12:</td><td>Y'<sub>30</sub></td><td>Y'<sub>31</sub></td><td>Y'<sub>32</sub></td><td>Y'<sub>33</sub></td></tr><tr><td>start&nbsp;+&nbsp;16:</td><td>Cb<sub>00</sub></td><td>Cb<sub>01</sub></td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>start&nbsp;+&nbsp;18:</td><td>Cb<sub>10</sub></td><td>Cb<sub>11</sub></td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>start&nbsp;+&nbsp;20:</td><td>Cb<sub>20</sub></td><td>Cb<sub>21</sub></td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>start&nbsp;+&nbsp;22:</td><td>Cb<sub>30</sub></td><td>Cb<sub>31</sub></td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>start&nbsp;+&nbsp;24:</td><td>Cr<sub>00</sub></td><td>Cr<sub>01</sub></td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>start&nbsp;+&nbsp;26:</td><td>Cr<sub>10</sub></td><td>Cr<sub>11</sub></td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>start&nbsp;+&nbsp;28:</td><td>Cr<sub>20</sub></td><td>Cr<sub>21</sub></td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>start&nbsp;+&nbsp;30:</td><td>Cr<sub>30</sub></td><td>Cr<sub>31</sub></td><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table><p></p></div>
              <p></p></div><div class="FORMALPARA"><p><b>Color Sample Location. </b>                </p><div class="INFORMALTABLE"><p></p><a name="AEN5271"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="TOP"><tr><td>&nbsp;</td><td>0</td><td>&nbsp;</td><td>1</td><td>&nbsp;</td><td>2</td><td>&nbsp;</td><td>3</td></tr><tr><td>0</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td></tr><tr><td>1</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td></tr><tr><td>2</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td></tr><tr><td>3</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td></tr></tbody></table><p></p></div>
              <p></p></div></div></div><h1><a name="V4L2-PIX-FMT-YUV411P"></a>V4L2_PIX_FMT_YUV411P ('411P')</h1><div class="REFNAMEDIV"><a name="AEN5323"></a><h2>Name</h2><code class="CONSTANT">V4L2_PIX_FMT_YUV411P</code>&nbsp;--&nbsp;Format with &#188; horizontal chroma resolution,
also known as YUV 4:1:1. Planar layout as opposed to
<code class="CONSTANT">V4L2_PIX_FMT_Y41P</code></div><div class="REFSECT1"><a name="AEN5328"></a><h2>Description</h2><p>This format is not commonly used. This is a planar
format similar to the 4:2:2 planar format except with half as many
chroma. The three components are separated into three sub-images or
planes. The Y plane is first. The Y plane has one byte per pixel. The
Cb plane immediately follows the Y plane in memory. The Cb plane is
&#188; the width of the Y plane (and of the image). Each Cb belongs
to 4 pixels all on the same row. For example,
Cb<sub>0</sub> belongs to Y'<sub>00</sub>,
Y'<sub>01</sub>, Y'<sub>02</sub> and
Y'<sub>03</sub>. Following the Cb plane is the Cr plane,
just like the Cb plane.</p><p>If the Y plane has pad bytes after each row, then the Cr
and Cb planes have &#188; as many pad bytes after their rows. In
other words, four C x rows (including padding) is exactly as long as
one Y row (including padding).</p><div class="EXAMPLE"><a name="AEN5337"></a><p><b>Example 2-1. <code class="CONSTANT">V4L2_PIX_FMT_YUV411P</code> 4 ¡Á 4
pixel image</b></p><div class="FORMALPARA"><p><b>Byte Order. </b>Each cell is one byte.
                </p><div class="INFORMALTABLE"><p></p><a name="AEN5343"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col align="LEFT" width="2*"><col><col><col><col></colgroup><tbody valign="TOP"><tr><td>start&nbsp;+&nbsp;0:</td><td>Y'<sub>00</sub></td><td>Y'<sub>01</sub></td><td>Y'<sub>02</sub></td><td>Y'<sub>03</sub></td></tr><tr><td>start&nbsp;+&nbsp;4:</td><td>Y'<sub>10</sub></td><td>Y'<sub>11</sub></td><td>Y'<sub>12</sub></td><td>Y'<sub>13</sub></td></tr><tr><td>start&nbsp;+&nbsp;8:</td><td>Y'<sub>20</sub></td><td>Y'<sub>21</sub></td><td>Y'<sub>22</sub></td><td>Y'<sub>23</sub></td></tr><tr><td>start&nbsp;+&nbsp;12:</td><td>Y'<sub>30</sub></td><td>Y'<sub>31</sub></td><td>Y'<sub>32</sub></td><td>Y'<sub>33</sub></td></tr><tr><td>start&nbsp;+&nbsp;16:</td><td>Cb<sub>00</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>start&nbsp;+&nbsp;17:</td><td>Cb<sub>10</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>start&nbsp;+&nbsp;18:</td><td>Cb<sub>20</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>start&nbsp;+&nbsp;19:</td><td>Cb<sub>30</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>start&nbsp;+&nbsp;20:</td><td>Cr<sub>00</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>start&nbsp;+&nbsp;21:</td><td>Cr<sub>10</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>start&nbsp;+&nbsp;22:</td><td>Cr<sub>20</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>start&nbsp;+&nbsp;23:</td><td>Cr<sub>30</sub></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table><p></p></div>
              <p></p></div><div class="FORMALPARA"><p><b>Color Sample Location. </b>                </p><div class="INFORMALTABLE"><p></p><a name="AEN5422"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="TOP"><tr><td>&nbsp;</td><td>0</td><td>&nbsp;</td><td>1</td><td>&nbsp;</td><td>2</td><td>&nbsp;</td><td>3</td></tr><tr><td>0</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td></tr><tr><td>1</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td></tr><tr><td>2</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td></tr><tr><td>3</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>C</td><td>Y</td><td>&nbsp;</td><td>Y</td></tr></tbody></table><p></p></div>
              <p></p></div></div></div><h1><a name="AEN5470"></a>V4L2_PIX_FMT_NV12 ('NV12'), V4L2_PIX_FMT_NV21 ('NV21')</h1><div class="REFNAMEDIV"><a name="AEN5474"></a><h2>Name</h2><code class="CONSTANT">V4L2_PIX_FMT_NV12</code>, <code class="CONSTANT">V4L2_PIX_FMT_NV21</code>&nbsp;--&nbsp;Formats with &#189; horizontal and vertical
chroma resolution, also known as YUV 4:2:0. One luminance and one
chrominance plane with alternating chroma samples as opposed to
<code class="CONSTANT">V4L2_PIX_FMT_YVU420</code></div><div class="REFSECT1"><a name="AEN5481"></a><h2>Description</h2><p>These are two-plane versions of the YUV 4:2:0 format.
The three components are separated into two sub-images or planes. The
Y plane is first. The Y plane has one byte per pixel. For
<code class="CONSTANT">V4L2_PIX_FMT_NV12</code>, a combined CbCr plane
immediately follows the Y plane in memory.  The CbCr plane is the same
width, in bytes, as the Y plane (and of the image), but is half as
tall in pixels. Each CbCr pair belongs to four pixels. For example,
Cb<sub>0</sub>/Cr<sub>0</sub> belongs to
Y'<sub>00</sub>, Y'<sub>01</sub>,
Y'<sub>10</sub>, Y'<sub>11</sub>.
<code class="CONSTANT">V4L2_PIX_FMT_NV21</code> is the same except the Cb and
Cr bytes are swapped, the CrCb plane starts with a Cr byte.</p><p>If the Y plane has pad bytes after each row, then the
CbCr plane has as many pad bytes after its rows.</p><div class="EXAMPLE"><a name="AEN5493"></a><p><b>Example 2-1. <code class="CONSTANT">V4L2_PIX_FMT_NV12</code> 4 ¡Á 4
pixel image</b></p><div class="FORMALPARA"><p><b>Byte Order. </b>Each cell is one byte.
                </p><div class="INFORMALTABLE"><p></p><a name="AEN5499"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col align="LEFT" width="2*"><col><col><col><col></colgroup><tbody valign="TOP"><tr><td>start&nbsp;+&nbsp;0:</td><td>Y'<sub>00</sub></td><td>Y'<sub>01</sub></td><td>Y'<sub>02</sub></td><td>Y'<sub>03</sub></td></tr><tr><td>start&nbsp;+&nbsp;4:</td><td>Y'<sub>10</sub></td><td>Y'<sub>11</sub></td><td>Y'<sub>12</sub></td><td>Y'<sub>13</sub></td></tr><tr><td>start&nbsp;+&nbsp;8:</td><td>Y'<sub>20</sub></td><td>Y'<sub>21</sub></td><td>Y'<sub>22</sub></td><td>Y'<sub>23</sub></td></tr><tr><td>start&nbsp;+&nbsp;12:</td><td>Y'<sub>30</sub></td><td>Y'<sub>31</sub></td><td>Y'<sub>32</sub></td><td>Y'<sub>33</sub></td></tr><tr><td>start&nbsp;+&nbsp;16:</td><td>Cb<sub>00</sub></td><td>Cr<sub>00</sub></td><td>Cb<sub>01</sub></td><td>Cr<sub>01</sub></td></tr><tr><td>start&nbsp;+&nbsp;20:</td><td>Cb<sub>10</sub></td><td>Cr<sub>10</sub></td><td>Cb<sub>11</sub></td><td>Cr<sub>11</sub></td></tr></tbody></table><p></p></div>
              <p></p></div><div class="FORMALPARA"><p><b>Color Sample Location. </b>                </p><div class="INFORMALTABLE"><p></p><a name="AEN5566"></a><table frame="void" class="CALSTABLE" border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="TOP"><tr><td>&nbsp;</td><td>0</td><td>&nbsp;</td><td>1</td><td>&nbsp;</td><td>2</td><td>&nbsp;</td><td>3</td></tr><tr><td>0</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>C</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>C</td><td>&nbsp;</td></tr><tr><td>1</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>2</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>C</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>C</td><td>&nbsp;</td></tr><tr><td>3</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td><td>&nbsp;</td><td>Y</td></tr></tbody></table><p></p></div>
              <p></p></div></div></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="AEN5634">2.6. Compressed Formats</a></h2><div class="TABLE"><a name="COMPRESSED-FORMATS"></a><p><b>Table 2-7. Compressed Image Formats</b></p><a name="V4L2-PIX-FMT-JPEG"></a><a name="V4L2-PIX-FMT-MPEG"></a><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><thead><tr><th>Identifier</th><th>Code</th><th>Details</th></tr></thead><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_PIX_FMT_JPEG</code></td><td>'JPEG'</td><td>TBD. See also <a href="#VIDIOC-G-JPEGCOMP"><code class="CONSTANT">VIDIOC_G_JPEGCOMP</code></a>,
            <a href="#VIDIOC-G-JPEGCOMP"><code class="CONSTANT">VIDIOC_S_JPEGCOMP</code></a>.</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_MPEG</code></td><td>'MPEG'</td><td>MPEG stream. The actual format is determined by
extended control <code class="CONSTANT">V4L2_CID_MPEG_STREAM_TYPE</code>, see
<a href="#MPEG-CONTROL-ID">Table 1-2</a>.</td></tr></tbody></table></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="PIXFMT-RESERVED">2.7. Reserved Format Identifiers</a></h2><p>These formats are not defined by this specification, they
are just listed for reference and to avoid naming conflicts. If you
want to register your own format, send an e-mail to the V4L mailing
list <a href="https://listman.redhat.com/mailman/listinfo/video4linux-list" target="_top">https://listman.redhat.com/mailman/listinfo/video4linux-list</a> for inclusion in the <tt class="FILENAME">videodev.h</tt>
file. If you want to share your format with other developers add a
link to your documentation and send a copy to the maintainer of this
document, Michael Schimek <code class="EMAIL">&lt;<a href="mailto:mschimek@gmx.at">mschimek@gmx.at</a>&gt;</code>, for
inclusion in this section. If you think your format should be listed
in a standard format section please make a proposal on the V4L mailing
list.</p><div class="TABLE"><a name="RESERVED-FORMATS"></a><p><b>Table 2-8. Reserved Image Formats</b></p><a name="V4L2-PIX-FMT-DV"></a><a name="V4L2-PIX-FMT-ET61X251"></a><a name="V4L2-PIX-FMT-HI240"></a><a name="V4L2-PIX-FMT-HM12"></a><a name="V4L2-PIX-FMT-MJPEG"></a><a name="V4L2-PIX-FMT-PWC1"></a><a name="V4L2-PIX-FMT-PWC2"></a><a name="V4L2-PIX-FMT-SN9C10X"></a><a name="V4L2-PIX-FMT-WNVA"></a><a name="V4L2-PIX-FMT-YYUV"></a><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><thead><tr><th>Identifier</th><th>Code</th><th>Details</th></tr></thead><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_PIX_FMT_DV</code></td><td>'dvsd'</td><td>unknown</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_ET61X251</code></td><td>'E625'</td><td>Compressed format of the ET61X251 driver.</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_HI240</code></td><td>'HI24'</td><td><p>8 bit RGB format used by the BTTV driver,
<a href="http://bytesex.org/bttv/" target="_top">http://bytesex.org/bttv/</a></p></td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_HM12</code></td><td>'HM12'</td><td><p>YUV 4:2:0 format used by the
IVTV driver, <a href="http://www.ivtvdriver.org/" target="_top">http://www.ivtvdriver.org/</a></p><p>The format is documented in the
kernel sources in the file <tt class="FILENAME">Documentation/video4linux/cx2341x/README.hm12</tt></p></td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_MJPEG</code></td><td>'MJPG'</td><td>Compressed format used by the Zoran driver</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_PWC1</code></td><td>'PWC1'</td><td>Compressed format of the PWC driver.</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_PWC2</code></td><td>'PWC2'</td><td>Compressed format of the PWC driver.</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_SN9C10X</code></td><td>'S910'</td><td>Compressed format of the SN9C102 driver.</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_WNVA</code></td><td>'WNVA'</td><td><p>Used by the Winnov Videum driver, <a href="http://www.thedirks.org/winnov/" target="_top">http://www.thedirks.org/winnov/</a></p></td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_YYUV</code></td><td>'YYUV'</td><td>unknown</td></tr></tbody></table></div></div></div><div class="CHAPTER"><hr><h1><a name="IO"></a>Chapter 3. Input/Output</h1><p>The V4L2 API defines several different methods to read from or
write to a device. All drivers exchanging data with applications must
support at least one of them.</p><p>The classic I/O method using the <code class="FUNCTION">read()</code>
and <code class="FUNCTION">write()</code> function is automatically selected
after opening a V4L2 device. When the driver does not support this
method attempts to read or write will fail at any time.</p><p>Other methods must be negotiated. To select the streaming I/O
method with memory mapped or user buffers applications call the
<a href="#VIDIOC-REQBUFS"><code class="CONSTANT">VIDIOC_REQBUFS</code></a> ioctl. The asynchronous I/O method is not defined
yet.</p><p>Video overlay can be considered another I/O method, although
the application does not directly receive the image data. It is
selected by initiating video overlay with the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl.
For more information see <a href="#OVERLAY">Section 4.2</a>.</p><p>Generally exactly one I/O method, including overlay, is
associated with each file descriptor. The only exceptions are
applications not exchanging data with a driver ("panel applications",
see <a href="#OPEN">Section 1.1</a>) and drivers permitting simultaneous video capturing
and overlay using the same file descriptor, for compatibility with V4L
and earlier versions of V4L2.</p><p><code class="CONSTANT">VIDIOC_S_FMT</code> and
<code class="CONSTANT">VIDIOC_REQBUFS</code> would permit this to some degree,
but for simplicity drivers need not support switching the I/O method
(after first switching away from read/write) other than by closing
and reopening the device.</p><p>The following sections describe the various I/O methods in
more detail.</p><div class="SECTION"><hr><h2 class="SECTION"><a name="RW">3.1. Read/Write</a></h2><p>Input and output devices support the
<code class="FUNCTION">read()</code> and <code class="FUNCTION">write()</code> function,
respectively, when the <code class="CONSTANT">V4L2_CAP_READWRITE</code> flag in
the <code class="STRUCTFIELD">capabilities</code> field of struct&nbsp;<a href="#V4L2-CAPABILITY">v4l2_capability</a>
returned by the <a href="#VIDIOC-QUERYCAP"><code class="CONSTANT">VIDIOC_QUERYCAP</code></a> ioctl is set.</p><p>Drivers may need the CPU to copy the data, but they may also
support DMA to or from user memory, so this I/O method is not
necessarily less efficient than other methods merely exchanging buffer
pointers. It is considered inferior though because no meta-information
like frame counters or timestamps are passed. This information is
necessary to recognize frame dropping and to synchronize with other
data streams. However this is also the simplest I/O method, requiring
little or no setup to exchange data. It permits command line stunts
like this (the <span class="APPLICATION">vidctrl</span> tool is
fictitious):</p><div class="INFORMALEXAMPLE"><p></p><a name="AEN5773"></a><pre class="SCREEN">&gt; vidctrl /dev/video --input=0 --format=YUYV --size=352x288
&gt; dd if=/dev/video of=myimage.422 bs=202752 count=1</pre><p></p></div><p>To read from the device applications use the
<a href="#FUNC-READ"><code class="FUNCTION">read()</code></a> function, to write the <a href="#FUNC-WRITE"><code class="FUNCTION">write()</code></a> function.
Drivers must implement one I/O method if they
exchange data with applications, but it need not be this.<a name="AEN5780" href="#FTN.AEN5780"><span class="footnote">[12]</span></a> When reading or writing is supported, the driver
must also support the <a href="#FUNC-SELECT"><code class="FUNCTION">select()</code></a> and <a href="#FUNC-POLL"><code class="FUNCTION">poll()</code></a>
function.<a name="AEN5786" href="#FTN.AEN5786"><span class="footnote">[13]</span></a></p></div><div class="SECTION"><hr><h2 class="SECTION"><a name="MMAP">3.2. Streaming I/O (Memory Mapping)</a></h2><p>Input and output devices support this I/O method when the
<code class="CONSTANT">V4L2_CAP_STREAMING</code> flag in the
<code class="STRUCTFIELD">capabilities</code> field of struct&nbsp;<a href="#V4L2-CAPABILITY">v4l2_capability</a>
returned by the <a href="#VIDIOC-QUERYCAP"><code class="CONSTANT">VIDIOC_QUERYCAP</code></a> ioctl is set. There are two
streaming methods, to determine if the memory mapping flavor is
supported applications must call the <a href="#VIDIOC-REQBUFS"><code class="CONSTANT">VIDIOC_REQBUFS</code></a> ioctl.</p><p>Streaming is an I/O method where only pointers to buffers
are exchanged between application and driver, the data itself is not
copied. Memory mapping is primarily intended to map buffers in device
memory into the application's address space. Device memory can be for
example the video memory on a graphics card with a video capture
add-on. However, being the most efficient I/O method available for a
long time, many other drivers support streaming as well, allocating
buffers in DMA-able main memory.</p><p>A driver can support many sets of buffers. Each set is
identified by a unique buffer type value. The sets are independent and
each set can hold a different type of data. To access different sets
at the same time different file descriptors must be used.<a name="AEN5803" href="#FTN.AEN5803"><span class="footnote">[14]</span></a></p><p>To allocate device buffers applications call the
<a href="#VIDIOC-REQBUFS"><code class="CONSTANT">VIDIOC_REQBUFS</code></a> ioctl with the desired number of buffers and buffer
type, for example <code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_CAPTURE</code>.
This ioctl can also be used to change the number of buffers or to free
the allocated memory, provided none of the buffers are still
mapped.</p><p>Before applications can access the buffers they must map
them into their address space with the <a href="#FUNC-MMAP"><code class="FUNCTION">mmap()</code></a> function. The
location of the buffers in device memory can be determined with the
<a href="#VIDIOC-QUERYBUF"><code class="CONSTANT">VIDIOC_QUERYBUF</code></a> ioctl. The <code class="STRUCTFIELD">m.offset</code> and
<code class="STRUCTFIELD">length</code> returned in a struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a> are
passed as sixth and second parameter to the
<code class="FUNCTION">mmap()</code> function. The offset and length values
must not be modified. Remember the buffers are allocated in physical
memory, as opposed to virtual memory which can be swapped out to disk.
Applications should free the buffers as soon as possible with the
<a href="#FUNC-MUNMAP"><code class="FUNCTION">munmap()</code></a> function.</p><div class="EXAMPLE"><a name="AEN5823"></a><p><b>Example 3-1. Mapping buffers</b></p><pre class="PROGRAMLISTING">struct&nbsp;<a href="#V4L2-REQUESTBUFFERS">v4l2_requestbuffers</a> reqbuf;
struct {
        void *start;
        size_t length;
} *buffers;
unsigned int i;

memset (&amp;reqbuf, 0, sizeof (reqbuf));
reqbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
reqbuf.memory = V4L2_MEMORY_MMAP;
reqbuf.count = 20;

if (-1 == ioctl (fd, <a href="#VIDIOC-REQBUFS"><code class="CONSTANT">VIDIOC_REQBUFS</code></a>, &amp;reqbuf)) {
        if (errno == EINVAL)
                printf ("Video capturing or mmap-streaming is not supported\n");
        else
                perror ("VIDIOC_REQBUFS");

        exit (EXIT_FAILURE);
}

/* We want at least five buffers. */

if (reqbuf.count &lt; 5) {
        /* You may need to free the buffers here. */
        printf ("Not enough buffer memory\n");
        exit (EXIT_FAILURE);
}

buffers = calloc (reqbuf.count, sizeof (*buffers));
assert (buffers != NULL);

for (i = 0; i &lt; reqbuf.count; i++) {
        struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a> buffer;

        memset (&amp;buffer, 0, sizeof (buffer));
        buffer.type = reqbuf.type;
	buffer.memory = V4L2_MEMORY_MMAP;
        buffer.index = i;

        if (-1 == ioctl (fd, <a href="#VIDIOC-QUERYBUF"><code class="CONSTANT">VIDIOC_QUERYBUF</code></a>, &amp;buffer)) {
                perror ("VIDIOC_QUERYBUF");
                exit (EXIT_FAILURE);
        }

        buffers[i].length = buffer.length; /* remember for munmap() */

        buffers[i].start = mmap (NULL, buffer.length,
                                 PROT_READ | PROT_WRITE, /* recommended */
                                 MAP_SHARED,             /* recommended */
                                 fd, buffer.m.offset);

        if (MAP_FAILED == buffers[i].start) {
                /* If you do not exit here you should unmap() and free()
                   the buffers mapped so far. */
                perror ("mmap");
                exit (EXIT_FAILURE);
        }
}

/* Cleanup. */

for (i = 0; i &lt; reqbuf.count; i++)
        munmap (buffers[i].start, buffers[i].length);
      </pre></div><p>Conceptually streaming drivers maintain two buffer queues, an incoming
and an outgoing queue. They separate the synchronous capture or output
operation locked to a video clock from the application which is
subject to random disk or network delays and preemption by
other processes, thereby reducing the probability of data loss.
The queues are organized as FIFOs, buffers will be
output in the order enqueued in the incoming FIFO, and were
captured in the order dequeued from the outgoing FIFO.</p><p>The driver may require a minimum number of buffers enqueued
at all times to function, apart of this no limit exists on the number
of buffers applications can enqueue in advance, or dequeue and
process. They can also enqueue in a different order than buffers have
been dequeued, and the driver can <span class="emphasis"><i class="EMPHASIS">fill</i></span> enqueued
<span class="emphasis"><i class="EMPHASIS">empty</i></span> buffers in any order. <a name="AEN5836" href="#FTN.AEN5836"><span class="footnote">[15]</span></a> The index number of a buffer (struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a>
<code class="STRUCTFIELD">index</code>) plays no role here, it only
identifies the buffer.</p><p>Initially all mapped buffers are in dequeued state,
inaccessible by the driver. For capturing applications it is customary
to first enqueue all mapped buffers, then to start capturing and enter
the read loop. Here the application waits until a filled buffer can be
dequeued, and re-enqueues the buffer when the data is no longer
needed. Output applications fill and enqueue buffers, when enough
buffers are stacked up the output is started with
<code class="CONSTANT">VIDIOC_STREAMON</code>. In the write loop, when
the application runs out of free buffers, it must wait until an empty
buffer can be dequeued and reused.</p><p>To enqueue and dequeue a buffer applications use the
<a href="#VIDIOC-QBUF"><code class="CONSTANT">VIDIOC_QBUF</code></a> and <a href="#VIDIOC-QBUF"><code class="CONSTANT">VIDIOC_DQBUF</code></a> ioctl. The status of a buffer being
mapped, enqueued, full or empty can be determined at any time using the
<a href="#VIDIOC-QUERYBUF"><code class="CONSTANT">VIDIOC_QUERYBUF</code></a> ioctl. Two methods exist to suspend execution of the
application until one or more buffers can be dequeued. By default
<code class="CONSTANT">VIDIOC_DQBUF</code> blocks when no buffer is in the
outgoing queue. When the <code class="CONSTANT">O_NONBLOCK</code> flag was
given to the <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a> function, <code class="CONSTANT">VIDIOC_DQBUF</code>
returns immediately with an <span class="ERRORCODE">EAGAIN</span> error code when no buffer is available. The
<a href="#FUNC-SELECT"><code class="FUNCTION">select()</code></a> or <a href="#FUNC-POLL"><code class="FUNCTION">poll()</code></a> function are always available.</p><p>To start and stop capturing or output applications call the
<a href="#VIDIOC-STREAMON"><code class="CONSTANT">VIDIOC_STREAMON</code></a> and <a href="#VIDIOC-STREAMON"><code class="CONSTANT">VIDIOC_STREAMOFF</code></a> ioctl. Note
<code class="CONSTANT">VIDIOC_STREAMOFF</code> removes all buffers from both
queues as a side effect. Since there is no notion of doing anything
"now" on a multitasking system, if an application needs to synchronize
with another event it should examine the struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a>
<code class="STRUCTFIELD">timestamp</code> of captured buffers, or set the
field before enqueuing buffers for output.</p><p>Drivers implementing memory mapping I/O must
support the <code class="CONSTANT">VIDIOC_REQBUFS</code>,
<code class="CONSTANT">VIDIOC_QUERYBUF</code>,
<code class="CONSTANT">VIDIOC_QBUF</code>, <code class="CONSTANT">VIDIOC_DQBUF</code>,
<code class="CONSTANT">VIDIOC_STREAMON</code> and
<code class="CONSTANT">VIDIOC_STREAMOFF</code> ioctl, the
<code class="FUNCTION">mmap()</code>, <code class="FUNCTION">munmap()</code>,
<code class="FUNCTION">select()</code> and <code class="FUNCTION">poll()</code>
function.<a name="AEN5878" href="#FTN.AEN5878"><span class="footnote">[16]</span></a></p><p>[capture example]</p></div><div class="SECTION"><hr><h2 class="SECTION"><a name="USERP">3.3. Streaming I/O (User Pointers)</a></h2><p>Input and output devices support this I/O method when the
<code class="CONSTANT">V4L2_CAP_STREAMING</code> flag in the
<code class="STRUCTFIELD">capabilities</code> field of struct&nbsp;<a href="#V4L2-CAPABILITY">v4l2_capability</a>
returned by the <a href="#VIDIOC-QUERYCAP"><code class="CONSTANT">VIDIOC_QUERYCAP</code></a> ioctl is set. If the particular user
pointer method (not only memory mapping) is supported must be
determined by calling the <a href="#VIDIOC-REQBUFS"><code class="CONSTANT">VIDIOC_REQBUFS</code></a> ioctl.</p><p>This I/O method combines advantages of the read/write and
memory mapping methods. Buffers are allocated by the application
itself, and can reside for example in virtual or shared memory. Only
pointers to data are exchanged, these pointers and meta-information
are passed in struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a>. The driver must be switched
into user pointer I/O mode by calling the <a href="#VIDIOC-REQBUFS"><code class="CONSTANT">VIDIOC_REQBUFS</code></a> with the
desired buffer type. No buffers are allocated beforehands,
consequently they are not indexed and cannot be queried like mapped
buffers with the <code class="CONSTANT">VIDIOC_QUERYBUF</code> ioctl.</p><div class="EXAMPLE"><a name="AEN5899"></a><p><b>Example 3-2. Initiating streaming I/O with user pointers</b></p><pre class="PROGRAMLISTING">struct&nbsp;<a href="#V4L2-REQUESTBUFFERS">v4l2_requestbuffers</a> reqbuf;

memset (&amp;reqbuf, 0, sizeof (reqbuf));
reqbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
reqbuf.memory = V4L2_MEMORY_USERPTR;

if (ioctl (fd, <a href="#VIDIOC-REQBUFS"><code class="CONSTANT">VIDIOC_REQBUFS</code></a>, &amp;reqbuf) == -1) {
        if (errno == EINVAL)
                printf ("Video capturing or user pointer streaming is not supported\n");
        else
                perror ("VIDIOC_REQBUFS");

        exit (EXIT_FAILURE);
}
      </pre></div><p>Buffer addresses and sizes are passed on the fly with the
<a href="#VIDIOC-QBUF"><code class="CONSTANT">VIDIOC_QBUF</code></a> ioctl. Although buffers are commonly cycled,
applications can pass different addresses and sizes at each
<code class="CONSTANT">VIDIOC_QBUF</code> call. If required by the hardware the
driver swaps memory pages within physical memory to create a
continuous area of memory. This happens transparently to the
application in the virtual memory subsystem of the kernel. When buffer
pages have been swapped out to disk they are brought back and finally
locked in physical memory for DMA.<a name="AEN5909" href="#FTN.AEN5909"><span class="footnote">[17]</span></a></p><p>Filled or displayed buffers are dequeued with the
<a href="#VIDIOC-QBUF"><code class="CONSTANT">VIDIOC_DQBUF</code></a> ioctl. The driver can unlock the memory pages at any
time between the completion of the DMA and this ioctl. The memory is
also unlocked when <a href="#VIDIOC-STREAMON"><code class="CONSTANT">VIDIOC_STREAMOFF</code></a> is called, <a href="#VIDIOC-REQBUFS"><code class="CONSTANT">VIDIOC_REQBUFS</code></a>, or
when the device is closed. Applications must take care not to free
buffers without dequeuing. For once, the buffers remain locked until
further, wasting physical memory. Second the driver will not be
notified when the memory is returned to the application's free list
and subsequently reused for other purposes, possibly completing the
requested DMA and overwriting valuable data.</p><p>For capturing applications it is customary to enqueue a
number of empty buffers, to start capturing and enter the read loop.
Here the application waits until a filled buffer can be dequeued, and
re-enqueues the buffer when the data is no longer needed. Output
applications fill and enqueue buffers, when enough buffers are stacked
up output is started. In the write loop, when the application
runs out of free buffers it must wait until an empty buffer can be
dequeued and reused. Two methods exist to suspend execution of the
application until one or more buffers can be dequeued. By default
<code class="CONSTANT">VIDIOC_DQBUF</code> blocks when no buffer is in the
outgoing queue. When the <code class="CONSTANT">O_NONBLOCK</code> flag was
given to the <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a> function, <code class="CONSTANT">VIDIOC_DQBUF</code>
returns immediately with an <span class="ERRORCODE">EAGAIN</span> error code when no buffer is available. The
<a href="#FUNC-SELECT"><code class="FUNCTION">select()</code></a> or <a href="#FUNC-POLL"><code class="FUNCTION">poll()</code></a> function are always available.</p><p>To start and stop capturing or output applications call the
<a href="#VIDIOC-STREAMON"><code class="CONSTANT">VIDIOC_STREAMON</code></a> and <a href="#VIDIOC-STREAMON"><code class="CONSTANT">VIDIOC_STREAMOFF</code></a> ioctl. Note
<code class="CONSTANT">VIDIOC_STREAMOFF</code> removes all buffers from both
queues and unlocks all buffers as a side effect. Since there is no
notion of doing anything "now" on a multitasking system, if an
application needs to synchronize with another event it should examine
the struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a> <code class="STRUCTFIELD">timestamp</code> of captured
buffers, or set the field before enqueuing buffers for output.</p><p>Drivers implementing user pointer I/O must
support the <code class="CONSTANT">VIDIOC_REQBUFS</code>,
<code class="CONSTANT">VIDIOC_QBUF</code>, <code class="CONSTANT">VIDIOC_DQBUF</code>,
<code class="CONSTANT">VIDIOC_STREAMON</code> and
<code class="CONSTANT">VIDIOC_STREAMOFF</code> ioctl, the
<code class="FUNCTION">select()</code> and <code class="FUNCTION">poll()</code> function.<a name="AEN5945" href="#FTN.AEN5945"><span class="footnote">[18]</span></a></p></div><div class="SECTION"><hr><h2 class="SECTION"><a name="ASYNC">3.4. Asynchronous I/O</a></h2><p>This method is not defined yet.</p></div><div class="SECTION"><hr><h2 class="SECTION"><a name="BUFFER">3.5. Buffers</a></h2><p>A buffer contains data exchanged by application and
driver using one of the Streaming I/O methods. Only pointers to
buffers are exchanged, the data itself is not copied. These pointers,
together with meta-information like timestamps or field parity, are
stored in a struct <code class="STRUCTNAME">v4l2_buffer</code>, argument to
the <a href="#VIDIOC-QUERYBUF"><code class="CONSTANT">VIDIOC_QUERYBUF</code></a>, <a href="#VIDIOC-QBUF"><code class="CONSTANT">VIDIOC_QBUF</code></a> and <a href="#VIDIOC-QBUF"><code class="CONSTANT">VIDIOC_DQBUF</code></a> ioctl.</p><p>Nominally timestamps refer to the first data byte transmitted.
In practice however the wide range of hardware covered by the V4L2 API
limits timestamp accuracy. Often an interrupt routine will
sample the system clock shortly after the field or frame was stored
completely in memory. So applications must expect a constant
difference up to one field or frame period plus a small (few scan
lines) random error. The delay and error can be much
larger due to compression or transmission over an external bus when
the frames are not properly stamped by the sender. This is frequently
the case with USB cameras. Here timestamps refer to the instant the
field or frame was received by the driver, not the capture time. These
devices identify by not enumerating any video standards, see <a href="#STANDARD">Section 1.7</a>.</p><p>Similar limitations apply to output timestamps. Typically
the video hardware locks to a clock controlling the video timing, the
horizontal and vertical synchronization pulses. At some point in the
line sequence, possibly the vertical blanking, an interrupt routine
samples the system clock, compares against the timestamp and programs
the hardware to repeat the previous field or frame, or to display the
buffer contents.</p><p>Apart of limitations of the video device and natural
inaccuracies of all clocks, it should be noted system time itself is
not perfectly stable. It can be affected by power saving cycles,
warped to insert leap seconds, or even turned back or forth by the
system administrator affecting long term measurements. <a name="AEN5967" href="#FTN.AEN5967"><span class="footnote">[19]</span></a></p><div class="TABLE"><a name="V4L2-BUFFER"></a><p><b>Table 3-1. struct <code class="STRUCTNAME">v4l2_buffer</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="20%"><col title="C2" width="20%"><col title="C3" width="20%"><col title="C4" width="40%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">index</code></td><td>&nbsp;</td><td>Number of the buffer, set by the application. This
field is only used for <a href="#MMAP">memory mapping</a> I/O
and can range from zero to the number of buffers allocated
with the <a href="#VIDIOC-REQBUFS"><code class="CONSTANT">VIDIOC_REQBUFS</code></a> ioctl (struct&nbsp;<a href="#V4L2-REQUESTBUFFERS">v4l2_requestbuffers</a> <code class="STRUCTFIELD">count</code>) minus one.</td></tr><tr><td>enum&nbsp;<a href="#V4L2-BUF-TYPE">v4l2_buf_type</a></td><td><code class="STRUCTFIELD">type</code></td><td>&nbsp;</td><td>Type of the buffer, same as struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a>
<code class="STRUCTFIELD">type</code> or struct&nbsp;<a href="#V4L2-REQUESTBUFFERS">v4l2_requestbuffers</a>
<code class="STRUCTFIELD">type</code>, set by the application.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">bytesused</code></td><td>&nbsp;</td><td>The number of bytes occupied by the data in the
buffer. It depends on the negotiated data format and may change with
each buffer for compressed variable size data like JPEG images.
Drivers must set this field when <code class="STRUCTFIELD">type</code>
refers to an input stream, applications when an output stream.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">flags</code></td><td>&nbsp;</td><td>Flags set by the application or driver, see <a href="#BUFFER-FLAGS">Table 3-3</a>.</td></tr><tr><td>enum&nbsp;<a href="#V4L2-FIELD">v4l2_field</a></td><td><code class="STRUCTFIELD">field</code></td><td>&nbsp;</td><td>Indicates the field order of the image in the
buffer, see <a href="#V4L2-FIELD">Table 3-8</a>. This field is not used when
the buffer contains VBI data. Drivers must set it when
<code class="STRUCTFIELD">type</code> refers to an input stream,
applications when an output stream.</td></tr><tr><td>struct timeval</td><td><code class="STRUCTFIELD">timestamp</code></td><td>&nbsp;</td><td><p>For input streams this is the
system time (as returned by the <code class="FUNCTION">gettimeofday()</code>
function) when the first data byte was captured. For output streams
the data will not be displayed before this time, secondary to the
nominal frame rate determined by the current video standard in
enqueued order. Applications can for example zero this field to
display frames as soon as possible. The driver stores the time at
which the first data byte was actually sent out in the
<code class="STRUCTFIELD">timestamp</code> field. This permits
applications to monitor the drift between the video and system
clock.</p></td></tr><tr><td>struct&nbsp;<a href="#V4L2-TIMECODE">v4l2_timecode</a></td><td><code class="STRUCTFIELD">timecode</code></td><td>&nbsp;</td><td>When <code class="STRUCTFIELD">type</code> is
<code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_CAPTURE</code> and the
<code class="CONSTANT">V4L2_BUF_FLAG_TIMECODE</code> flag is set in
<code class="STRUCTFIELD">flags</code>, this structure contains a frame
timecode. In <a href="#V4L2-FIELD">V4L2_FIELD_ALTERNATE</a>
mode the top and bottom field contain the same timecode.
Timecodes are intended to help video editing and are typically recorded on
video tapes, but also embedded in compressed formats like MPEG. This
field is independent of the <code class="STRUCTFIELD">timestamp</code> and
<code class="STRUCTFIELD">sequence</code> fields.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">sequence</code></td><td>&nbsp;</td><td>Set by the driver, counting the frames in the
sequence.</td></tr><tr><td colspan="4"><p>In <a href="#V4L2-FIELD">V4L2_FIELD_ALTERNATE</a> mode the top and
bottom field have the same sequence number. The count starts at zero
and includes dropped or repeated frames. A dropped frame was received
by an input device but could not be stored due to lack of free buffer
space. A repeated frame was displayed again by an output device
because the application did not pass new data in
time.</p><p>Note this may count the frames received
e.g. over USB, without taking into account the frames dropped by the
remote hardware due to limited compression throughput or bus
bandwidth. These devices identify by not enumerating any video
standards, see <a href="#STANDARD">Section 1.7</a>.</p></td></tr><tr><td>enum&nbsp;<a href="#V4L2-MEMORY">v4l2_memory</a></td><td><code class="STRUCTFIELD">memory</code></td><td>&nbsp;</td><td>This field must be set by applications and/or drivers
in accordance with the selected I/O method.</td></tr><tr><td>union</td><td><code class="STRUCTFIELD">m</code></td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td>__u32</td><td><code class="STRUCTFIELD">offset</code></td><td>When <code class="STRUCTFIELD">memory</code> is
<code class="CONSTANT">V4L2_MEMORY_MMAP</code> this is the offset of the buffer
from the start of the device memory. The value is returned by the
driver and apart of serving as parameter to the <a href="#FUNC-MMAP"><code class="FUNCTION">mmap()</code></a> function
not useful for applications. See <a href="#MMAP">Section 3.2</a> for details.</td></tr><tr><td>&nbsp;</td><td>unsigned long</td><td><code class="STRUCTFIELD">userptr</code></td><td>When <code class="STRUCTFIELD">memory</code> is
<code class="CONSTANT">V4L2_MEMORY_USERPTR</code> this is a pointer to the
buffer (casted to unsigned long type) in virtual memory, set by the
application. See <a href="#USERP">Section 3.3</a> for details.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">length</code></td><td>&nbsp;</td><td>Size of the buffer (not the payload) in bytes.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">input</code></td><td>&nbsp;</td><td>Some video capture drivers support rapid and
synchronous video input changes, a function useful for example in
video surveillance applications. For this purpose applications set the
<code class="CONSTANT">V4L2_BUF_FLAG_INPUT</code> flag, and this field to the
number of a video input as in struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a> field
<code class="STRUCTFIELD">index</code>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code></td><td>&nbsp;</td><td>A place holder for future extensions and custom
(driver defined) buffer types
<code class="CONSTANT">V4L2_BUF_TYPE_PRIVATE</code> and higher.</td></tr></tbody></table></div><div class="TABLE"><a name="V4L2-BUF-TYPE"></a><p><b>Table 3-2. enum v4l2_buf_type</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_CAPTURE</code></td><td>1</td><td>Buffer of a video capture stream, see <a href="#CAPTURE">Section 4.1</a>.</td></tr><tr><td><code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_OUTPUT</code></td><td>2</td><td>Buffer of a video output stream, see <a href="#OUTPUT">Section 4.3</a>.</td></tr><tr><td><code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_OVERLAY</code></td><td>3</td><td>Buffer for video overlay, see <a href="#OVERLAY">Section 4.2</a>.</td></tr><tr><td><code class="CONSTANT">V4L2_BUF_TYPE_VBI_CAPTURE</code></td><td>4</td><td>Buffer of a raw VBI capture stream, see <a href="#RAW-VBI">Section 4.7</a>.</td></tr><tr><td><code class="CONSTANT">V4L2_BUF_TYPE_VBI_OUTPUT</code></td><td>5</td><td>Buffer of a raw VBI output stream, see <a href="#RAW-VBI">Section 4.7</a>.</td></tr><tr><td><code class="CONSTANT">V4L2_BUF_TYPE_SLICED_VBI_CAPTURE</code></td><td>6</td><td>Buffer of a sliced VBI capture stream, see <a href="#SLICED">Section 4.8</a>.</td></tr><tr><td><code class="CONSTANT">V4L2_BUF_TYPE_SLICED_VBI_OUTPUT</code></td><td>7</td><td>Buffer of a sliced VBI output stream, see <a href="#SLICED">Section 4.8</a>.</td></tr><tr><td><code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY</code></td><td>8</td><td>Buffer for video output overlay (OSD), see <a href="#OSD">Section 4.4</a>. Status: <a href="#EXPERIMENTAL">Experimental</a>.</td></tr><tr><td><code class="CONSTANT">V4L2_BUF_TYPE_PRIVATE</code></td><td>0x80</td><td>This and higher values are reserved for custom
(driver defined) buffer types.</td></tr></tbody></table></div><div class="TABLE"><a name="BUFFER-FLAGS"></a><p><b>Table 3-3. Buffer Flags</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_BUF_FLAG_MAPPED</code></td><td>0x0001</td><td>The buffer resides in device memory and has been mapped
into the application's address space, see <a href="#MMAP">Section 3.2</a> for details.
Drivers set or clear this flag when the
<a href="#VIDIOC-QUERYBUF">VIDIOC_QUERYBUF</a>, <a href="#VIDIOC-QBUF">VIDIOC_QBUF</a> or <a href="#VIDIOC-QBUF">VIDIOC_DQBUF</a> ioctl is called. Set by the driver.</td></tr><tr><td><code class="CONSTANT">V4L2_BUF_FLAG_QUEUED</code></td><td>0x0002</td><td>Internally drivers maintain two buffer queues, an
incoming and outgoing queue. When this flag is set, the buffer is
currently on the incoming queue. It automatically moves to the
outgoing queue after the buffer has been filled (capture devices) or
displayed (output devices). Drivers set or clear this flag when the
<code class="CONSTANT">VIDIOC_QUERYBUF</code> ioctl is called. After
(successful) calling the <code class="CONSTANT">VIDIOC_QBUF </code>ioctl it is
always set and after <code class="CONSTANT">VIDIOC_DQBUF</code> always
cleared.</td></tr><tr><td><code class="CONSTANT">V4L2_BUF_FLAG_DONE</code></td><td>0x0004</td><td>When this flag is set, the buffer is currently on
the outgoing queue, ready to be dequeued from the driver. Drivers set
or clear this flag when the <code class="CONSTANT">VIDIOC_QUERYBUF</code> ioctl
is called. After calling the <code class="CONSTANT">VIDIOC_QBUF</code> or
<code class="CONSTANT">VIDIOC_DQBUF</code> it is always cleared. Of course a
buffer cannot be on both queues at the same time, the
<code class="CONSTANT">V4L2_BUF_FLAG_QUEUED</code> and
<code class="CONSTANT">V4L2_BUF_FLAG_DONE</code> flag are mutually exclusive.
They can be both cleared however, then the buffer is in "dequeued"
state, in the application domain to say so.</td></tr><tr><td><code class="CONSTANT">V4L2_BUF_FLAG_KEYFRAME</code></td><td>0x0008</td><td>Drivers set or clear this flag when calling the
<code class="CONSTANT">VIDIOC_DQBUF</code> ioctl. It may be set by video
capture devices when the buffer contains a compressed image which is a
key frame (or field), i.&nbsp;e. can be decompressed on its own.</td></tr><tr><td><code class="CONSTANT">V4L2_BUF_FLAG_PFRAME</code></td><td>0x0010</td><td>Similar to <code class="CONSTANT">V4L2_BUF_FLAG_KEYFRAME</code>
this flags predicted frames or fields which contain only differences to a
previous key frame.</td></tr><tr><td><code class="CONSTANT">V4L2_BUF_FLAG_BFRAME</code></td><td>0x0020</td><td>Similar to <code class="CONSTANT">V4L2_BUF_FLAG_PFRAME</code>
        this is a bidirectional predicted frame or field. [ooc tbd]</td></tr><tr><td><code class="CONSTANT">V4L2_BUF_FLAG_TIMECODE</code></td><td>0x0100</td><td>The <code class="STRUCTFIELD">timecode</code> field is valid.
Drivers set or clear this flag when the <code class="CONSTANT">VIDIOC_DQBUF</code>
ioctl is called.</td></tr><tr><td><code class="CONSTANT">V4L2_BUF_FLAG_INPUT</code></td><td>0x0200</td><td>The <code class="STRUCTFIELD">input</code> field is valid.
Applications set or clear this flag before calling the
<code class="CONSTANT">VIDIOC_QBUF</code> ioctl.</td></tr></tbody></table></div><div class="TABLE"><a name="V4L2-MEMORY"></a><p><b>Table 3-4. enum v4l2_memory</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_MEMORY_MMAP</code></td><td>1</td><td>The buffer is used for <a href="#MMAP">memory
mapping</a> I/O.</td></tr><tr><td><code class="CONSTANT">V4L2_MEMORY_USERPTR</code></td><td>2</td><td>The buffer is used for <a href="#USERP">user
pointer</a> I/O.</td></tr><tr><td><code class="CONSTANT">V4L2_MEMORY_OVERLAY</code></td><td>3</td><td>[to do]</td></tr></tbody></table></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN6266">3.5.1. Timecodes</a></h3><p>The <code class="STRUCTNAME">v4l2_timecode</code> structure is
designed to hold a <a href="#SMPTE12M"><abbr class="ABBREV">SMPTE&nbsp;12M</abbr></a> or similar timecode.
(struct <code class="STRUCTNAME">timeval</code> timestamps are stored in
struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a> field <code class="STRUCTFIELD">timestamp</code>.)</p><div class="TABLE"><a name="V4L2-TIMECODE"></a><p><b>Table 3-5. struct <code class="STRUCTNAME">v4l2_timecode</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">type</code></td><td>Frame rate the timecodes are based on, see <a href="#TIMECODE-TYPE">Table 3-6</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">flags</code></td><td>Timecode flags, see <a href="#TIMECODE-FLAGS">Table 3-7</a>.</td></tr><tr><td>__u8</td><td><code class="STRUCTFIELD">frames</code></td><td>Frame count, 0 ... 23/24/29/49/59, depending on the
            type of timecode.</td></tr><tr><td>__u8</td><td><code class="STRUCTFIELD">seconds</code></td><td>Seconds count, 0 ... 59. This is a binary, not BCD number.</td></tr><tr><td>__u8</td><td><code class="STRUCTFIELD">minutes</code></td><td>Minutes count, 0 ... 59. This is a binary, not BCD number.</td></tr><tr><td>__u8</td><td><code class="STRUCTFIELD">hours</code></td><td>Hours count, 0 ... 29. This is a binary, not BCD number.</td></tr><tr><td>__u8</td><td><code class="STRUCTFIELD">userbits</code>[4]</td><td>The "user group" bits from the timecode.</td></tr></tbody></table></div><div class="TABLE"><a name="TIMECODE-TYPE"></a><p><b>Table 3-6. Timecode Types</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_TC_TYPE_24FPS</code></td><td>1</td><td>24 frames per second, i.&nbsp;e. film.</td></tr><tr><td><code class="CONSTANT">V4L2_TC_TYPE_25FPS</code></td><td>2</td><td>25 frames per second, i.&nbsp;e. PAL or SECAM video.</td></tr><tr><td><code class="CONSTANT">V4L2_TC_TYPE_30FPS</code></td><td>3</td><td>30 frames per second, i.&nbsp;e. NTSC video.</td></tr><tr><td><code class="CONSTANT">V4L2_TC_TYPE_50FPS</code></td><td>4</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_TC_TYPE_60FPS</code></td><td>5</td><td>&nbsp;</td></tr></tbody></table></div><div class="TABLE"><a name="TIMECODE-FLAGS"></a><p><b>Table 3-7. Timecode Flags</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_TC_FLAG_DROPFRAME</code></td><td>0x0001</td><td>Indicates "drop frame" semantics for counting frames
in 29.97 fps material. When set, frame numbers 0 and 1 at the start of
each minute, except minutes 0, 10, 20, 30, 40, 50 are omitted from the
count.</td></tr><tr><td><code class="CONSTANT">V4L2_TC_FLAG_COLORFRAME</code></td><td>0x0002</td><td>The "color frame" flag.</td></tr><tr><td><code class="CONSTANT">V4L2_TC_USERBITS_field</code></td><td>0x000C</td><td>Field mask for the "binary group flags".</td></tr><tr><td><code class="CONSTANT">V4L2_TC_USERBITS_USERDEFINED</code></td><td>0x0000</td><td>Unspecified format.</td></tr><tr><td><code class="CONSTANT">V4L2_TC_USERBITS_8BITCHARS</code></td><td>0x0008</td><td>8-bit ISO characters.</td></tr></tbody></table></div></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="FIELD-ORDER">3.6. Field Order</a></h2><p>We have to distinguish between progressive and interlaced
video. Progressive video transmits all lines of a video image
sequentially. Interlaced video divides an image into two fields,
containing only the odd and even lines of the image, respectively.
Alternating the so called odd and even field are transmitted, and due
to a small delay between fields a cathode ray TV displays the lines
interleaved, yielding the original frame. This curious technique was
invented because at refresh rates similar to film the image would
fade out too quickly. Transmitting fields reduces the flicker without
the necessity of doubling the frame rate and with it the bandwidth
required for each channel.</p><p>It is important to understand a video camera does not expose
one frame at a time, merely transmitting the frames separated into
fields. The fields are in fact captured at two different instances in
time. An object on screen may well move between one field and the
next. For applications analysing motion it is of paramount importance
to recognize which field of a frame is older, the <span class="emphasis"><i class="EMPHASIS">temporal
order</i></span>.</p><p>When the driver provides or accepts images field by field
rather than interleaved, it is also important applications understand
how the fields combine to frames. We distinguish between top and
bottom fields, the <span class="emphasis"><i class="EMPHASIS">spatial order</i></span>: The first line
of the top field is the first line of an interlaced frame, the first
line of the bottom field is the second line of that frame.</p><p>However because fields were captured one after the other,
arguing whether a frame commences with the top or bottom field is
pointless. Any two successive top and bottom, or bottom and top fields
yield a valid frame. Only when the source was progressive to begin
with, e.&nbsp;g. when transferring film to video, two fields may come from
the same frame, creating a natural order.</p><p>Counter to intuition the top field is not necessarily the
older field. Whether the older field contains the top or bottom lines
is a convention determined by the video standard. Hence the
distinction between temporal and spatial order of fields. The diagrams
below should make this clearer.</p><p>All video capture and output devices must report the current
field order. Some drivers may permit the selection of a different
order, to this end applications initialize the
<code class="STRUCTFIELD">field</code> field of struct&nbsp;<a href="#V4L2-PIX-FORMAT">v4l2_pix_format</a> before
calling the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl. If this is not desired it should
have the value <code class="CONSTANT">V4L2_FIELD_ANY</code> (0).</p><div class="TABLE"><a name="V4L2-FIELD"></a><p><b>Table 3-8. enum v4l2_field</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_FIELD_ANY</code></td><td>0</td><td>Applications request this field order when any
one of the <code class="CONSTANT">V4L2_FIELD_NONE</code>,
<code class="CONSTANT">V4L2_FIELD_TOP</code>,
<code class="CONSTANT">V4L2_FIELD_BOTTOM</code>, or
<code class="CONSTANT">V4L2_FIELD_INTERLACED</code> formats is acceptable.
Drivers choose depending on hardware capabilities or e.&nbsp;g. the
requested image size, and return the actual field order. struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a>
<code class="STRUCTFIELD">field</code> can never be
<code class="CONSTANT">V4L2_FIELD_ANY</code>.</td></tr><tr><td><code class="CONSTANT">V4L2_FIELD_NONE</code></td><td>1</td><td>Images are in progressive format, not interlaced.
The driver may also indicate this order when it cannot distinguish
between <code class="CONSTANT">V4L2_FIELD_TOP</code> and
<code class="CONSTANT">V4L2_FIELD_BOTTOM</code>.</td></tr><tr><td><code class="CONSTANT">V4L2_FIELD_TOP</code></td><td>2</td><td>Images consist of the top field only.</td></tr><tr><td><code class="CONSTANT">V4L2_FIELD_BOTTOM</code></td><td>3</td><td>Images consist of the bottom field only.
Applications may wish to prevent a device from capturing interlaced
images because they will have "comb" or "feathering" artefacts around
moving objects.</td></tr><tr><td><code class="CONSTANT">V4L2_FIELD_INTERLACED</code></td><td>4</td><td>Images contain both fields, interleaved line by
line. The temporal order of the fields (whether the top or bottom
field is first transmitted) depends on the current video standard.
M/NTSC transmits the bottom field first, all other standards the top
field first.</td></tr><tr><td><code class="CONSTANT">V4L2_FIELD_SEQ_TB</code></td><td>5</td><td>Images contain both fields, the top field lines
are stored first in memory, immediately followed by the bottom field
lines. Fields are always stored in temporal order, the older one first
in memory. Image sizes refer to the frame, not fields.</td></tr><tr><td><code class="CONSTANT">V4L2_FIELD_SEQ_BT</code></td><td>6</td><td>Images contain both fields, the bottom field
lines are stored first in memory, immediately followed by the top
field lines. Fields are always stored in temporal order, the older one
first in memory. Image sizes refer to the frame, not fields.</td></tr><tr><td><code class="CONSTANT">V4L2_FIELD_ALTERNATE</code></td><td>7</td><td>The two fields of a frame are passed in separate
buffers, in temporal order, i.&nbsp;e. the older one first. To indicate the field
parity (whether the current field is a top or bottom field) the driver
or application, depending on data direction, must set struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a>
<code class="STRUCTFIELD">field</code> to
<code class="CONSTANT">V4L2_FIELD_TOP</code> or
<code class="CONSTANT">V4L2_FIELD_BOTTOM</code>. Any two successive fields pair
to build a frame. If fields are successive, without any dropped fields
between them (fields can drop individually), can be determined from
the struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a> <code class="STRUCTFIELD">sequence</code> field. Image
sizes refer to the frame, not fields. This format cannot be selected
when using the read/write I/O method.</td></tr><tr><td><code class="CONSTANT">V4L2_FIELD_INTERLACED_TB</code></td><td>8</td><td>Images contain both fields, interleaved line by
line, top field first. The top field is transmitted first.</td></tr><tr><td><code class="CONSTANT">V4L2_FIELD_INTERLACED_BT</code></td><td>9</td><td>Images contain both fields, interleaved line by
line, top field first. The bottom field is transmitted first.</td></tr></tbody></table></div><div class="FIGURE"><a name="FIELDSEQ-TB"></a><p><b>Figure 3-1. Field Order, Top Field First Transmitted</b></p><div class="MEDIAOBJECT"><p><img src="v4l2_files/fieldseq_tb.gif"></p></div></div><div class="FIGURE"><a name="FIELDSEQ-BT"></a><p><b>Figure 3-2. Field Order, Bottom Field First Transmitted</b></p><div class="MEDIAOBJECT"><p><img src="v4l2_files/fieldseq_bt.gif"></p></div></div></div></div><div class="CHAPTER"><hr><h1><a name="DEVICES"></a>Chapter 4. Interfaces</h1><div class="SECTION"><h2 class="SECTION"><a name="CAPTURE">4.1. Video Capture Interface</a></h2><p>Video capture devices sample an analog video signal and store
the digitized images in memory. Today nearly all devices can capture
at full 25 or 30 frames/second. With this interface applications can
control the capture process and move images from the driver into user
space.</p><p>Conventionally V4L2 video capture devices are accessed through
character device special files named <tt class="FILENAME">/dev/video</tt>
and <tt class="FILENAME">/dev/video0</tt> to
<tt class="FILENAME">/dev/video63</tt> with major number 81 and minor
numbers 0 to 63. <tt class="FILENAME">/dev/video</tt> is typically a
symbolic link to the preferred video device. Note the same device
files are used for video output devices.</p><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN6498">4.1.1. Querying Capabilities</a></h3><p>Devices supporting the video capture interface set the
<code class="CONSTANT">V4L2_CAP_VIDEO_CAPTURE</code> flag in the
<code class="STRUCTFIELD">capabilities</code> field of struct&nbsp;<a href="#V4L2-CAPABILITY">v4l2_capability</a>
returned by the <a href="#VIDIOC-QUERYCAP"><code class="CONSTANT">VIDIOC_QUERYCAP</code></a> ioctl. As secondary device functions
they may also support the <a href="#OVERLAY">video overlay</a>
(<code class="CONSTANT">V4L2_CAP_VIDEO_OVERLAY</code>) and the <a href="#RAW-VBI">raw VBI capture</a>
(<code class="CONSTANT">V4L2_CAP_VBI_CAPTURE</code>) interface. At least one of
the read/write or streaming I/O methods must be supported. Tuners and
audio inputs are optional.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN6510">4.1.2. Supplemental Functions</a></h3><p>Video capture devices shall support <a href="#AUDIO">audio input</a>, <a href="#TUNER">tuner</a>, <a href="#CONTROL">controls</a>,
<a href="#CROP">cropping and scaling</a> and <a href="#STREAMING-PAR">streaming parameter</a> ioctls as needed.
The <a href="#VIDEO">video input</a> and <a href="#STANDARD">video standard</a> ioctls must be supported by
all video capture devices.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN6520">4.1.3. Image Format Negotiation</a></h3><p>The result of a capture operation is determined by
cropping and image format parameters. The former select an area of the
video picture to capture, the latter how images are stored in memory,
i.&nbsp;e. in RGB or YUV format, the number of bits per pixel or width and
height. Together they also define how images are scaled in the
process.</p><p>As usual these parameters are <span class="emphasis"><i class="EMPHASIS">not</i></span> reset
at <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a> time to permit Unix tool chains, programming a device
and then reading from it as if it was a plain file. Well written V4L2
applications ensure they really get what they want, including cropping
and scaling.</p><p>Cropping initialization at minimum requires to reset the
parameters to defaults. An example is given in <a href="#CROP">Section 1.11</a>.</p><p>To query the current image format applications set the
<code class="STRUCTFIELD">type</code> field of a struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a> to
<code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_CAPTURE</code> and call the
<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_G_FMT</code></a> ioctl with a pointer to this structure. Drivers fill
the struct&nbsp;<a href="#V4L2-PIX-FORMAT">v4l2_pix_format</a> <code class="STRUCTFIELD">pix</code> member of the
<code class="STRUCTFIELD">fmt</code> union.</p><p>To request different parameters applications set the
<code class="STRUCTFIELD">type</code> field of a struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a> as above and
initialize all fields of the struct&nbsp;<a href="#V4L2-PIX-FORMAT">v4l2_pix_format</a>
<code class="STRUCTFIELD">vbi</code> member of the
<code class="STRUCTFIELD">fmt</code> union, or better just modify the
results of <code class="CONSTANT">VIDIOC_G_FMT</code>, and call the
<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl with a pointer to this structure. Drivers may
adjust the parameters and finally return the actual parameters as
<code class="CONSTANT">VIDIOC_G_FMT</code> does.</p><p>Like <code class="CONSTANT">VIDIOC_S_FMT</code> the
<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_TRY_FMT</code></a> ioctl can be used to learn about hardware limitations
without disabling I/O or possibly time consuming hardware
preparations.</p><p>The contents of struct&nbsp;<a href="#V4L2-PIX-FORMAT">v4l2_pix_format</a> are discussed in <a href="#PIXFMT">Chapter 2</a>. See also the specification of the
<code class="CONSTANT">VIDIOC_G_FMT</code>, <code class="CONSTANT">VIDIOC_S_FMT</code>
and <code class="CONSTANT">VIDIOC_TRY_FMT</code> ioctls for details. Video
capture devices must implement both the
<code class="CONSTANT">VIDIOC_G_FMT</code> and
<code class="CONSTANT">VIDIOC_S_FMT</code> ioctl, even if
<code class="CONSTANT">VIDIOC_S_FMT</code> ignores all requests and always
returns default parameters as <code class="CONSTANT">VIDIOC_G_FMT</code> does.
<code class="CONSTANT">VIDIOC_TRY_FMT</code> is optional.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN6563">4.1.4. Reading Images</a></h3><p>A video capture device may support the <a href="#RW">read() function</a> and/or streaming (<a href="#MMAP">memory mapping</a> or <a href="#USERP">user pointer</a>) I/O. See <a href="#IO">Chapter 3</a> for details.</p></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="OVERLAY">4.2. Video Overlay Interface</a></h2><font color="RED">Also known as Framebuffer Overlay or Previewing</font><p>Video overlay devices have the ability to genlock (TV-)video
into the (VGA-)video signal of a graphics card, or to store captured
images directly in video memory of a graphics card, typically with
clipping. This can be considerable more efficient than capturing
images and displaying them by other means. In the old days when only
nuclear power plants needed cooling towers this used to be the only
way to put live video into a window.</p><p>Video overlay devices are accessed through the same character
special files as <a href="#CAPTURE">video capture</a> devices.
Note the default function of a <tt class="FILENAME">/dev/video</tt> device
is video capturing. The overlay function is only available after
calling the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl.</p><p>The driver may support simultaneous overlay and capturing
using the read/write and streaming I/O methods. If so, operation at
the nominal frame rate of the video standard is not guaranteed. Frames
may be directed away from overlay to capture, or one field may be used
for overlay and the other for capture if the capture parameters permit
this.</p><p>Applications should use different file descriptors for
capturing and overlay. This must be supported by all drivers capable
of simultaneous capturing and overlay. Optionally these drivers may
also permit capturing and overlay with a single file descriptor for
compatibility with V4L and earlier versions of V4L2.<a name="AEN6581" href="#FTN.AEN6581"><span class="footnote">[20]</span></a></p><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN6587">4.2.1. Querying Capabilities</a></h3><p>Devices supporting the video overlay interface set the
<code class="CONSTANT">V4L2_CAP_VIDEO_OVERLAY</code> flag in the
<code class="STRUCTFIELD">capabilities</code> field of struct&nbsp;<a href="#V4L2-CAPABILITY">v4l2_capability</a>
returned by the <a href="#VIDIOC-QUERYCAP"><code class="CONSTANT">VIDIOC_QUERYCAP</code></a> ioctl. The overlay I/O method specified
below must be supported. Tuners and audio inputs are optional.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN6595">4.2.2. Supplemental Functions</a></h3><p>Video overlay devices shall support <a href="#AUDIO">audio input</a>, <a href="#TUNER">tuner</a>, <a href="#CONTROL">controls</a>,
<a href="#CROP">cropping and scaling</a> and <a href="#STREAMING-PAR">streaming parameter</a> ioctls as needed.
The <a href="#VIDEO">video input</a> and <a href="#STANDARD">video standard</a> ioctls must be supported by
all video overlay devices.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN6605">4.2.3. Setup</a></h3><p>Before overlay can commence applications must program the
driver with frame buffer parameters, namely the address and size of
the frame buffer and the image format, for example RGB 5:6:5. The
<a href="#VIDIOC-G-FBUF"><code class="CONSTANT">VIDIOC_G_FBUF</code></a> and <a href="#VIDIOC-G-FBUF"><code class="CONSTANT">VIDIOC_S_FBUF</code></a> ioctls are available to get
and set these parameters, respectively. The
<code class="CONSTANT">VIDIOC_S_FBUF</code> ioctl is privileged because it
allows to set up DMA into physical memory, bypassing the memory
protection mechanisms of the kernel. Only the superuser can change the
frame buffer address and size. Users are not supposed to run TV
applications as root or with SUID bit set. A small helper application
with suitable privileges should query the graphics system and program
the V4L2 driver at the appropriate time.</p><p>Some devices add the video overlay to the output signal
of the graphics card. In this case the frame buffer is not modified by
the video device, and the frame buffer address and pixel format are
not needed by the driver. The <code class="CONSTANT">VIDIOC_S_FBUF</code> ioctl
is not privileged. An application can check for this type of device by
calling the <code class="CONSTANT">VIDIOC_G_FBUF</code> ioctl.</p><p>A driver may support any (or none) of five clipping/blending
methods:</p><p></p><ol type="1"><li><p>Chroma-keying displays the overlaid image only where
pixels in the primary graphics surface assume a certain color.</p></li><li><p>A bitmap can be specified where each bit corresponds
to a pixel in the overlaid image. When the bit is set, the
corresponding video pixel is displayed, otherwise a pixel of the
graphics surface.</p></li><li><p>A list of clipping rectangles can be specified. In
these regions <span class="emphasis"><i class="EMPHASIS">no</i></span> video is displayed, so the
graphics surface can be seen here.</p></li><li><p>The framebuffer has an alpha channel that can be used
to clip or blend the framebuffer with the video.</p></li><li><p>A global alpha value can be specified to blend the
framebuffer contents with video images.</p></li></ol><p></p><p>When simultaneous capturing and overlay is supported and
the hardware prohibits different image and frame buffer formats, the
format requested first takes precedence. The attempt to capture
(<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a>) or overlay (<a href="#VIDIOC-G-FBUF"><code class="CONSTANT">VIDIOC_S_FBUF</code></a>) may fail with an
<span class="ERRORCODE">EBUSY</span> error code or return accordingly modified parameters..</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN6635">4.2.4. Overlay Window</a></h3><p>The overlaid image is determined by cropping and overlay
window parameters. The former select an area of the video picture to
capture, the latter how images are overlaid and clipped. Cropping
initialization at minimum requires to reset the parameters to
defaults. An example is given in <a href="#CROP">Section 1.11</a>.</p><p>The overlay window is described by a struct&nbsp;<a href="#V4L2-WINDOW">v4l2_window</a>. It
defines the size of the image, its position over the graphics surface
and the clipping to be applied. To get the current parameters
applications set the <code class="STRUCTFIELD">type</code> field of a
struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a> to <code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_OVERLAY</code> and
call the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_G_FMT</code></a> ioctl. The driver fills the
<code class="STRUCTNAME">v4l2_window</code> substructure named
<code class="STRUCTFIELD">win</code>. It is not possible to retrieve a
previously programmed clipping list or bitmap.</p><p>To program the overlay window applications set the
<code class="STRUCTFIELD">type</code> field of a struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a> to
<code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_OVERLAY</code>, initialize the
<code class="STRUCTFIELD">win</code> substructure and call the
<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl. The driver adjusts the parameters against
hardware limits and returns the actual parameters as
<code class="CONSTANT">VIDIOC_G_FMT</code> does. Like
<code class="CONSTANT">VIDIOC_S_FMT</code>, the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_TRY_FMT</code></a> ioctl can be
used to learn about driver capabilities without actually changing
driver state. Unlike <code class="CONSTANT">VIDIOC_S_FMT</code> this also works
after the overlay has been enabled.</p><p>The scaling factor of the overlaid image is implied by the
width and height given in struct&nbsp;<a href="#V4L2-WINDOW">v4l2_window</a> and the size of the cropping
rectangle. For more information see <a href="#CROP">Section 1.11</a>.</p><p>When simultaneous capturing and overlay is supported and
the hardware prohibits different image and window sizes, the size
requested first takes precedence. The attempt to capture or overlay as
well (<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a>) may fail with an <span class="ERRORCODE">EBUSY</span> error code or return accordingly
modified parameters.</p><div class="TABLE"><a name="V4L2-WINDOW"></a><p><b>Table 4-1. struct <code class="STRUCTNAME">v4l2_window</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>struct&nbsp;<a href="#V4L2-RECT">v4l2_rect</a></td><td><code class="STRUCTFIELD">w</code></td><td>Size and position of the window relative to the
top, left corner of the frame buffer defined with <a href="#VIDIOC-G-FBUF"><code class="CONSTANT">VIDIOC_S_FBUF</code></a>. The
window can extend the frame buffer width and height, the
<code class="STRUCTFIELD">x</code> and <code class="STRUCTFIELD">y</code>
coordinates can be negative, and it can lie completely outside the
frame buffer. The driver clips the window accordingly, or if that is
not possible, modifies its size and/or position.</td></tr><tr><td>enum&nbsp;<a href="#V4L2-FIELD">v4l2_field</a></td><td><code class="STRUCTFIELD">field</code></td><td>Applications set this field to determine which
video field shall be overlaid, typically one of
<code class="CONSTANT">V4L2_FIELD_ANY</code> (0),
<code class="CONSTANT">V4L2_FIELD_TOP</code>,
<code class="CONSTANT">V4L2_FIELD_BOTTOM</code> or
<code class="CONSTANT">V4L2_FIELD_INTERLACED</code>. Drivers may have to choose
a different field order and return the actual setting here.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">chromakey</code></td><td>When chroma-keying has been negotiated with
<a href="#VIDIOC-G-FBUF"><code class="CONSTANT">VIDIOC_S_FBUF</code></a> applications set this field to the desired pixel value
for the chroma key. The format is the same as the pixel format of the
framebuffer (struct&nbsp;<a href="#V4L2-FRAMEBUFFER">v4l2_framebuffer</a>
<code class="STRUCTFIELD">fmt.pixelformat</code> field), with bytes in host
order. E.&nbsp;g. for <a href="#V4L2-PIX-FMT-BGR32"><code class="CONSTANT">V4L2_PIX_FMT_BGR24</code></a> 
the value should be 0xRRGGBB on a little endian, 0xBBGGRR on a big
endian host.</td></tr><tr><td>struct&nbsp;<a href="#V4L2-CLIP">v4l2_clip</a> *</td><td><code class="STRUCTFIELD">clips</code></td><td>When chroma-keying has <span class="emphasis"><i class="EMPHASIS">not</i></span>
been negotiated and <a href="#VIDIOC-G-FBUF"><code class="CONSTANT">VIDIOC_G_FBUF</code></a> indicated this capability,
applications can set this field to point to an array of
clipping rectangles.</td></tr><tr><td colspan="3">Like the window coordinates
<code class="STRUCTFIELD">w</code>, clipping rectangles are defined relative
to the top, left corner of the frame buffer. However clipping
rectangles must not extend the frame buffer width and height, and they
must not overlap. If possible applications should merge adjacent
rectangles. Whether this must create x-y or y-x bands, or the order of
rectangles, is not defined. When clip lists are not supported the
driver ignores this field. Its contents after calling <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a>
are undefined.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">clipcount</code></td><td>When the application set the
<code class="STRUCTFIELD">clips</code> field, this field must contain the
number of clipping rectangles in the list. When clip lists are not
supported the driver ignores this field, its contents after calling
<code class="CONSTANT">VIDIOC_S_FMT</code> are undefined. When clip lists are
supported but no clipping is desired this field must be set to
zero.</td></tr><tr><td>void *</td><td><code class="STRUCTFIELD">bitmap</code></td><td>When chroma-keying has
<span class="emphasis"><i class="EMPHASIS">not</i></span> been negotiated and <a href="#VIDIOC-G-FBUF"><code class="CONSTANT">VIDIOC_G_FBUF</code></a> indicated
this capability, applications can set this field to point to a
clipping bit mask.</td></tr><tr><td colspan="3"><p>It must be of the same size
as the window, <code class="STRUCTFIELD">w.width</code> and
<code class="STRUCTFIELD">w.height</code>. Each bit corresponds to a pixel
in the overlaid image, which is displayed only when the bit is
<span class="emphasis"><i class="EMPHASIS">set</i></span>. Pixel coordinates translate to bits like:
</p><pre class="PROGRAMLISTING">((__u8 *) <code class="STRUCTFIELD">bitmap</code>)[<code class="STRUCTFIELD">w.width</code> * y + x / 8] &amp; (1 &lt;&lt; (x &amp; 7))</pre><p></p><p>where <code class="STRUCTFIELD">0</code> ¡Ü x &lt;
<code class="STRUCTFIELD">w.width</code> and <code class="STRUCTFIELD">0</code> ¡Ü
y &lt;<code class="STRUCTFIELD">w.height</code>.<sup>a</sup></p><p>When a clipping
bit mask is not supported the driver ignores this field, its contents
after calling <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> are undefined. When a bit mask is supported
but no clipping is desired this field must be set to
<code class="CONSTANT">NULL</code>.</p><p>Applications need not create a
clip list or bit mask. When they pass both, or despite negotiating
chroma-keying, the results are undefined. Regardless of the chosen
method, the clipping abilities of the hardware may be limited in
quantity or quality. The results when these limits are exceeded are
undefined.<sup>b</sup></p></td></tr><tr><td>__u8</td><td><code class="STRUCTFIELD">global_alpha</code></td><td><p>The global alpha value used to blend the
framebuffer with video images, if global alpha blending has been
negotiated (<code class="CONSTANT">V4L2_FBUF_FLAG_GLOBAL_ALPHA</code>, see
<a href="#VIDIOC-G-FBUF"><code class="CONSTANT">VIDIOC_S_FBUF</code></a>, <a href="#FRAMEBUFFER-FLAGS">Table 3</a>).</p><p>Note
this field was added in Linux 2.6.23, extending the structure. However
the <a href="#VIDIOC-G-FMT">VIDIOC_G/S/TRY_FMT</a> ioctls,
which take a pointer to a <a href="#V4L2-FORMAT">v4l2_format</a> parent structure with padding
bytes at the end, are not affected.</p></td></tr></tbody><tbody><tr><td colspan="3">Notes:<br><a name="FTN.AEN6750">a. </a>Should we require
              <code class="STRUCTFIELD">w.width</code> to be a multiple of
              eight?<br><a name="FTN.AEN6758">b. </a>When the image is written into frame buffer
memory it will be undesirable if the driver clips out less pixels
than expected, because the application and graphics system are not
aware these regions need to be refreshed. The driver should clip out
more pixels or not write the image at all.<br></td></tr></tbody></table></div><div class="TABLE"><a name="V4L2-CLIP"></a><p><b>Table 4-2. struct <code class="STRUCTNAME">v4l2_clip</code><a name="AEN6776" href="#FTN.AEN6776"><span class="footnote">[21]</span></a></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>struct&nbsp;<a href="#V4L2-RECT">v4l2_rect</a></td><td><code class="STRUCTFIELD">c</code></td><td>Coordinates of the clipping rectangle, relative to
the top, left corner of the frame buffer. Only window pixels
<span class="emphasis"><i class="EMPHASIS">outside</i></span> all clipping rectangles are
displayed.</td></tr><tr><td>struct&nbsp;<a href="#V4L2-CLIP">v4l2_clip</a> *</td><td><code class="STRUCTFIELD">next</code></td><td>Pointer to the next clipping rectangle, NULL when
this is the last rectangle. Drivers ignore this field, it cannot be
used to pass a linked list of clipping rectangles.</td></tr></tbody></table></div><div class="TABLE"><a name="V4L2-RECT"></a><p><b>Table 4-3. struct <code class="STRUCTNAME">v4l2_rect</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__s32</td><td><code class="STRUCTFIELD">left</code></td><td>Horizontal offset of the top, left corner of the
rectangle, in pixels.</td></tr><tr><td>__s32</td><td><code class="STRUCTFIELD">top</code></td><td>Vertical offset of the top, left corner of the
rectangle, in pixels. Offsets increase to the right and down.</td></tr><tr><td>__s32</td><td><code class="STRUCTFIELD">width</code></td><td>Width of the rectangle, in pixels.</td></tr><tr><td>__s32</td><td><code class="STRUCTFIELD">height</code></td><td>Height of the rectangle, in pixels. Width and
height cannot be negative, the fields are signed for hysterical
reasons. </td></tr></tbody></table></div></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN6826">4.2.5. Enabling Overlay</a></h3><p>To start or stop the frame buffer overlay applications call
the <a href="#VIDIOC-OVERLAY"><code class="CONSTANT">VIDIOC_OVERLAY</code></a> ioctl.</p></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="OUTPUT">4.3. Video Output Interface</a></h2><p>Video output devices encode stills or image sequences as
analog video signal. With this interface applications can
control the encoding process and move images from user space to
the driver.</p><p>Conventionally V4L2 video output devices are accessed through
character device special files named <tt class="FILENAME">/dev/video</tt>
and <tt class="FILENAME">/dev/video0</tt> to
<tt class="FILENAME">/dev/video63</tt> with major number 81 and minor
numbers 0 to 63. <tt class="FILENAME">/dev/video</tt> is typically a
symbolic link to the preferred video device. Note the same device
files are used for video capture devices.</p><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN6839">4.3.1. Querying Capabilities</a></h3><p>Devices supporting the video output interface set the
<code class="CONSTANT">V4L2_CAP_VIDEO_OUTPUT</code> flag in the
<code class="STRUCTFIELD">capabilities</code> field of struct&nbsp;<a href="#V4L2-CAPABILITY">v4l2_capability</a>
returned by the <a href="#VIDIOC-QUERYCAP"><code class="CONSTANT">VIDIOC_QUERYCAP</code></a> ioctl. As secondary device functions
they may also support the <a href="#RAW-VBI">raw VBI
output</a> (<code class="CONSTANT">V4L2_CAP_VBI_OUTPUT</code>) interface. At
least one of the read/write or streaming I/O methods must be
supported. Modulators and audio outputs are optional.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN6849">4.3.2. Supplemental Functions</a></h3><p>Video output devices shall support <a href="#AUDIO">audio output</a>, <a href="#TUNER">modulator</a>, <a href="#CONTROL">controls</a>,
<a href="#CROP">cropping and scaling</a> and <a href="#STREAMING-PAR">streaming parameter</a> ioctls as needed.
The <a href="#VIDEO">video output</a> and <a href="#STANDARD">video standard</a> ioctls must be supported by
all video output devices.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN6859">4.3.3. Image Format Negotiation</a></h3><p>The output is determined by cropping and image format
parameters. The former select an area of the video picture where the
image will appear, the latter how images are stored in memory, i.&nbsp;e. in
RGB or YUV format, the number of bits per pixel or width and height.
Together they also define how images are scaled in the process.</p><p>As usual these parameters are <span class="emphasis"><i class="EMPHASIS">not</i></span> reset
at <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a> time to permit Unix tool chains, programming a device
and then writing to it as if it was a plain file. Well written V4L2
applications ensure they really get what they want, including cropping
and scaling.</p><p>Cropping initialization at minimum requires to reset the
parameters to defaults. An example is given in <a href="#CROP">Section 1.11</a>.</p><p>To query the current image format applications set the
<code class="STRUCTFIELD">type</code> field of a struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a> to
<code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_OUTPUT</code> and call the
<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_G_FMT</code></a> ioctl with a pointer to this structure. Drivers fill
the struct&nbsp;<a href="#V4L2-PIX-FORMAT">v4l2_pix_format</a> <code class="STRUCTFIELD">pix</code> member of the
<code class="STRUCTFIELD">fmt</code> union.</p><p>To request different parameters applications set the
<code class="STRUCTFIELD">type</code> field of a struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a> as above and
initialize all fields of the struct&nbsp;<a href="#V4L2-PIX-FORMAT">v4l2_pix_format</a>
<code class="STRUCTFIELD">vbi</code> member of the
<code class="STRUCTFIELD">fmt</code> union, or better just modify the
results of <code class="CONSTANT">VIDIOC_G_FMT</code>, and call the
<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl with a pointer to this structure. Drivers may
adjust the parameters and finally return the actual parameters as
<code class="CONSTANT">VIDIOC_G_FMT</code> does.</p><p>Like <code class="CONSTANT">VIDIOC_S_FMT</code> the
<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_TRY_FMT</code></a> ioctl can be used to learn about hardware limitations
without disabling I/O or possibly time consuming hardware
preparations.</p><p>The contents of struct&nbsp;<a href="#V4L2-PIX-FORMAT">v4l2_pix_format</a> are discussed in <a href="#PIXFMT">Chapter 2</a>. See also the specification of the
<code class="CONSTANT">VIDIOC_G_FMT</code>, <code class="CONSTANT">VIDIOC_S_FMT</code>
and <code class="CONSTANT">VIDIOC_TRY_FMT</code> ioctls for details. Video
output devices must implement both the
<code class="CONSTANT">VIDIOC_G_FMT</code> and
<code class="CONSTANT">VIDIOC_S_FMT</code> ioctl, even if
<code class="CONSTANT">VIDIOC_S_FMT</code> ignores all requests and always
returns default parameters as <code class="CONSTANT">VIDIOC_G_FMT</code> does.
<code class="CONSTANT">VIDIOC_TRY_FMT</code> is optional.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN6902">4.3.4. Writing Images</a></h3><p>A video output device may support the <a href="#RW">write() function</a> and/or streaming (<a href="#MMAP">memory mapping</a> or <a href="#USERP">user pointer</a>) I/O. See <a href="#IO">Chapter 3</a> for details.</p></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="OSD">4.4. Video Output Overlay Interface</a></h2><font color="RED">Also known as On-Screen Display (OSD)</font><div class="NOTE"><blockquote class="NOTE"><p><b>Experimental: </b>This is an <a href="#EXPERIMENTAL">experimental</a>
interface and may change in the future.</p></blockquote></div><p>Some video output devices can overlay a framebuffer image onto
the outgoing video signal. Applications can set up such an overlay
using this interface, which borrows structures and ioctls of the <a href="#OVERLAY">Video Overlay</a> interface.</p><p>The OSD function is accessible through the same character
special file as the <a href="#CAPTURE">Video Output</a> function.
Note the default function of such a <tt class="FILENAME">/dev/video</tt> device
is video capturing or output. The OSD function is only available after
calling the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl.</p><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN6923">4.4.1. Querying Capabilities</a></h3><p>Devices supporting the <i class="WORDASWORD">Video Output
Overlay</i> interface set the
<code class="CONSTANT">V4L2_CAP_VIDEO_OUTPUT_OVERLAY</code> flag in the
<code class="STRUCTFIELD">capabilities</code> field of struct&nbsp;<a href="#V4L2-CAPABILITY">v4l2_capability</a>
returned by the <a href="#VIDIOC-QUERYCAP"><code class="CONSTANT">VIDIOC_QUERYCAP</code></a> ioctl.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN6932">4.4.2. Framebuffer</a></h3><p>Contrary to the <i class="WORDASWORD">Video Overlay</i>
interface the framebuffer is normally implemented on the TV card and
not the graphics card. On Linux it is accessible as a framebuffer
device (<tt class="FILENAME">/dev/fbN</tt>). Given a V4L2 device,
applications can find the corresponding framebuffer device by calling
the <a href="#VIDIOC-G-FBUF"><code class="CONSTANT">VIDIOC_G_FBUF</code></a> ioctl. It returns, amongst other information, the
physical address of the framebuffer in the
<code class="STRUCTFIELD">base</code> field of struct&nbsp;<a href="#V4L2-FRAMEBUFFER">v4l2_framebuffer</a>. The
framebuffer device ioctl <code class="CONSTANT">FBIOGET_FSCREENINFO</code>
returns the same address in the <code class="STRUCTFIELD">smem_start</code>
field of struct <code class="STRUCTNAME">fb_fix_screeninfo</code>. The
<code class="CONSTANT">FBIOGET_FSCREENINFO</code> ioctl and struct
<code class="STRUCTNAME">fb_fix_screeninfo</code> are defined in the
<tt class="FILENAME">linux/fb.h</tt> header file.</p><p>The width and height of the framebuffer depends on the
current video standard. A V4L2 driver may reject attempts to change
the video standard (or any other ioctl which would imply a framebuffer
size change) with an <span class="ERRORCODE">EBUSY</span> error code until all applications closed the
framebuffer device.</p><div class="EXAMPLE"><a name="AEN6949"></a><p><b>Example 4-1. Finding a framebuffer device for OSD</b></p><pre class="PROGRAMLISTING">#include &lt;linux/fb.h&gt;

struct&nbsp;<a href="#V4L2-FRAMEBUFFER">v4l2_framebuffer</a> fbuf;
unsigned int i;
int fb_fd;

if (-1 == ioctl (fd, VIDIOC_G_FBUF, &amp;fbuf)) {
        perror ("VIDIOC_G_FBUF");
        exit (EXIT_FAILURE);
}

for (i = 0; i &lt; 30; ++i) {
        char dev_name[16];
        struct fb_fix_screeninfo si;

        snprintf (dev_name, sizeof (dev_name), "/dev/fb%u", i);

        fb_fd = open (dev_name, O_RDWR);
        if (-1 == fb_fd) {
                switch (errno) {
                case ENOENT: /* no such file */
                case ENXIO:  /* no driver */
                        continue;

                default:
                        perror ("open");
                        exit (EXIT_FAILURE);
                }
        }

        if (0 == ioctl (fb_fd, FBIOGET_FSCREENINFO, &amp;si)) {
                if (si.smem_start == (unsigned long) fbuf.base)
                        break;
        } else {
                /* Apparently not a framebuffer device. */
        }

        close (fb_fd);
        fb_fd = -1;
}

/* fb_fd is the file descriptor of the framebuffer device
   for the video output overlay, or -1 if no device was found. */</pre></div></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN6953">4.4.3. Overlay Window and Scaling</a></h3><p>The overlay is controlled by source and target rectangles.
The source rectangle selects a subsection of the framebuffer image to
be overlaid, the target rectangle an area in the outgoing video signal
where the image will appear. Drivers may or may not support scaling,
and arbitrary sizes and positions of these rectangles. Further drivers
may support any (or none) of the clipping/blending methods defined for
the <a href="#OVERLAY">Video Overlay</a> interface.</p><p>A struct&nbsp;<a href="#V4L2-WINDOW">v4l2_window</a> defines the size of the source rectangle,
its position in the framebuffer and the clipping/blending method to be
used for the overlay. To get the current parameters applications set
the <code class="STRUCTFIELD">type</code> field of a struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a> to
<code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY</code> and call the
<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_G_FMT</code></a> ioctl. The driver fills the
<code class="STRUCTNAME">v4l2_window</code> substructure named
<code class="STRUCTFIELD">win</code>. It is not possible to retrieve a
previously programmed clipping list or bitmap.</p><p>To program the source rectangle applications set the
<code class="STRUCTFIELD">type</code> field of a struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a> to
<code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY</code>, initialize
the <code class="STRUCTFIELD">win</code> substructure and call the
<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl. The driver adjusts the parameters against
hardware limits and returns the actual parameters as
<code class="CONSTANT">VIDIOC_G_FMT</code> does. Like
<code class="CONSTANT">VIDIOC_S_FMT</code>, the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_TRY_FMT</code></a> ioctl can be
used to learn about driver capabilities without actually changing
driver state. Unlike <code class="CONSTANT">VIDIOC_S_FMT</code> this also works
after the overlay has been enabled.</p><p>A struct&nbsp;<a href="#V4L2-CROP">v4l2_crop</a> defines the size and position of the target
rectangle. The scaling factor of the overlay is implied by the width
and height given in struct&nbsp;<a href="#V4L2-WINDOW">v4l2_window</a> and struct&nbsp;<a href="#V4L2-CROP">v4l2_crop</a>. The cropping API
applies to <i class="WORDASWORD">Video Output</i> and <i class="WORDASWORD">Video
Output Overlay</i> devices in the same way as to
<i class="WORDASWORD">Video Capture</i> and <i class="WORDASWORD">Video
Overlay</i> devices, merely reversing the direction of the
data flow. For more information see <a href="#CROP">Section 1.11</a>.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN6987">4.4.4. Enabling Overlay</a></h3><p>There is no V4L2 ioctl to enable or disable the overlay,
however the framebuffer interface of the driver may support the
<code class="CONSTANT">FBIOBLANK</code> ioctl.</p></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="CODEC">4.5. Codec Interface</a></h2><div class="NOTE"><blockquote class="NOTE"><p><b>Suspended: </b>This interface has been be suspended from the V4L2 API
implemented in Linux 2.6 until we have more experience with codec
device interfaces.</p></blockquote></div><p>A V4L2 codec can compress, decompress, transform, or otherwise
convert video data from one format into another format, in memory.
Applications send data to be converted to the driver through a
<a href="#FUNC-WRITE"><code class="FUNCTION">write()</code></a> call, and receive the converted data through a
<a href="#FUNC-READ"><code class="FUNCTION">read()</code></a> call. For efficiency a driver may also support streaming
I/O.</p><p>[to do]</p></div><div class="SECTION"><hr><h2 class="SECTION"><a name="EFFECT">4.6. Effect Devices Interface</a></h2><div class="NOTE"><blockquote class="NOTE"><p><b>Suspended: </b>This interface has been be suspended from the V4L2 API
implemented in Linux 2.6 until we have more experience with effect
device interfaces.</p></blockquote></div><p>A V4L2 video effect device can do image effects, filtering, or
combine two or more images or image streams. For example video
transitions or wipes. Applications send data to be processed and
receive the result data either with <a href="#FUNC-READ"><code class="FUNCTION">read()</code></a> and <a href="#FUNC-WRITE"><code class="FUNCTION">write()</code></a>
functions, or through the streaming I/O mechanism.</p><p>[to do]</p></div><div class="SECTION"><hr><h2 class="SECTION"><a name="RAW-VBI">4.7. Raw VBI Data Interface</a></h2><p>VBI is an abbreviation of Vertical Blanking Interval, a gap
in the sequence of lines of an analog video signal. During VBI
no picture information is transmitted, allowing some time while the
electron beam of a cathode ray tube TV returns to the top of the
screen. Using an oscilloscope you will find here the vertical
synchronization pulses and short data packages ASK
modulated<a name="AEN7016" href="#FTN.AEN7016"><span class="footnote">[22]</span></a>
onto the video signal. These are transmissions of services such as
Teletext or Closed Caption.</p><p>Subject of this interface type is raw VBI data, as sampled off
a video signal, or to be added to a signal for output.
The data format is similar to uncompressed video images, a number of
lines times a number of samples per line, we call this a VBI image.</p><p>Conventionally V4L2 VBI devices are accessed through character
device special files named <tt class="FILENAME">/dev/vbi</tt> and
<tt class="FILENAME">/dev/vbi0</tt> to <tt class="FILENAME">/dev/vbi31</tt> with
major number 81 and minor numbers 224 to 255.
<tt class="FILENAME">/dev/vbi</tt> is typically a symbolic link to the
preferred VBI device. This convention applies to both input and output
devices.</p><p>To address the problems of finding related video and VBI
devices VBI capturing and output is also available as device function
under <tt class="FILENAME">/dev/video</tt>. To capture or output raw VBI
data with these devices applications must call the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a>
ioctl. Accessed as <tt class="FILENAME">/dev/vbi</tt>, raw VBI capturing
or output is the default device function.</p><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN7029">4.7.1. Querying Capabilities</a></h3><p>Devices supporting the raw VBI capturing or output API set
the <code class="CONSTANT">V4L2_CAP_VBI_CAPTURE</code> or
<code class="CONSTANT">V4L2_CAP_VBI_OUTPUT</code> flags, respectively, in the
<code class="STRUCTFIELD">capabilities</code> field of struct&nbsp;<a href="#V4L2-CAPABILITY">v4l2_capability</a>
returned by the <a href="#VIDIOC-QUERYCAP"><code class="CONSTANT">VIDIOC_QUERYCAP</code></a> ioctl. At least one of the
read/write, streaming or asynchronous I/O methods must be
supported. VBI devices may or may not have a tuner or modulator.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN7038">4.7.2. Supplemental Functions</a></h3><p>VBI devices shall support <a href="#VIDEO">video
input or output</a>, <a href="#TUNER">tuner or
modulator</a>, and <a href="#CONTROL">controls</a> ioctls
as needed. The <a href="#STANDARD">video standard</a> ioctls provide
information vital to program a VBI device, therefore must be
supported.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN7045">4.7.3. Raw VBI Format Negotiation</a></h3><p>Raw VBI sampling abilities can vary, in particular the
sampling frequency. To properly interpret the data V4L2 specifies an
ioctl to query the sampling parameters. Moreover, to allow for some
flexibility applications can also suggest different parameters.</p><p>As usual these parameters are <span class="emphasis"><i class="EMPHASIS">not</i></span>
reset at <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a> time to permit Unix tool chains, programming a
device and then reading from it as if it was a plain file. Well
written V4L2 applications should always ensure they really get what
they want, requesting reasonable parameters and then checking if the
actual parameters are suitable.</p><p>To query the current raw VBI capture parameters
applications set the <code class="STRUCTFIELD">type</code> field of a
struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a> to <code class="CONSTANT">V4L2_BUF_TYPE_VBI_CAPTURE</code> or
<code class="CONSTANT">V4L2_BUF_TYPE_VBI_OUTPUT</code>, and call the
<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_G_FMT</code></a> ioctl with a pointer to this structure. Drivers fill
the struct&nbsp;<a href="#V4L2-VBI-FORMAT">v4l2_vbi_format</a> <code class="STRUCTFIELD">vbi</code> member of the
<code class="STRUCTFIELD">fmt</code> union.</p><p>To request different parameters applications set the
<code class="STRUCTFIELD">type</code> field of a struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a> as above and
initialize all fields of the struct&nbsp;<a href="#V4L2-VBI-FORMAT">v4l2_vbi_format</a>
<code class="STRUCTFIELD">vbi</code> member of the
<code class="STRUCTFIELD">fmt</code> union, or better just modify the
results of <code class="CONSTANT">VIDIOC_G_FMT</code>, and call the
<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl with a pointer to this structure. Drivers return
an <span class="ERRORCODE">EINVAL</span> error code only when the given parameters are ambiguous, otherwise
they modify the parameters according to the hardware capabilites and
return the actual parameters. When the driver allocates resources at
this point, it may return an <span class="ERRORCODE">EBUSY</span> error code to indicate the returned
parameters are valid but the required resources are currently not
available. That may happen for instance when the video and VBI areas
to capture would overlap, or when the driver supports multiple opens
and another process already requested VBI capturing or output. Anyway,
applications must expect other resource allocation points which may
return <span class="ERRORCODE">EBUSY</span>, at the <a href="#VIDIOC-STREAMON"><code class="CONSTANT">VIDIOC_STREAMON</code></a> ioctl
and the first read(), write() and select() call.</p><p>VBI devices must implement both the
<code class="CONSTANT">VIDIOC_G_FMT</code> and
<code class="CONSTANT">VIDIOC_S_FMT</code> ioctl, even if
<code class="CONSTANT">VIDIOC_S_FMT</code> ignores all requests and always
returns default parameters as <code class="CONSTANT">VIDIOC_G_FMT</code> does.
<code class="CONSTANT">VIDIOC_TRY_FMT</code> is optional.</p><div class="TABLE"><a name="V4L2-VBI-FORMAT"></a><p><b>Table 4-4. struct <code class="STRUCTNAME">v4l2_vbi_format</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">sampling_rate</code></td><td>Samples per second, i.&nbsp;e. unit 1 Hz.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">offset</code></td><td><p>Horizontal offset of the VBI image,
relative to the leading edge of the line synchronization pulse and
counted in samples: The first sample in the VBI image will be located
<code class="STRUCTFIELD">offset</code> /
<code class="STRUCTFIELD">sampling_rate</code> seconds following the leading
edge. See also <a href="#VBI-HSYNC">Figure 4-1</a>.</p></td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">samples_per_line</code></td><td>&nbsp;</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">sample_format</code></td><td><p>Defines the sample format as in <a href="#PIXFMT">Chapter 2</a>, a four-character-code.<sup>a</sup> Usually this is
<code class="CONSTANT">V4L2_PIX_FMT_GREY</code>, i.&nbsp;e. each sample
consists of 8 bits with lower values oriented towards the black level.
Do not assume any other correlation of values with the signal level.
For example, the MSB does not necessarily indicate if the signal is
'high' or 'low' because 128 may not be the mean value of the
signal. Drivers shall not convert the sample format by software.</p></td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">start</code>[2]</td><td>This is the scanning system line number
associated with the first line of the VBI image, of the first and the
second field respectively. See <a href="#VBI-525">Figure 4-2</a> and
<a href="#VBI-625">Figure 4-3</a> for valid values. VBI input drivers can
return start values 0 if the hardware cannot reliable identify
scanning lines, VBI acquisition may not require this
information.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">count</code>[2]</td><td>The number of lines in the first and second
field image, respectively.</td></tr><tr><td colspan="3"><p>Drivers should be as
flexibility as possible. For example, it may be possible to extend or
move the VBI capture window down to the picture area, implementing a
'full field mode' to capture data service transmissions embedded in
the picture.</p><p>An application can set the first or second
<code class="STRUCTFIELD">count</code> value to zero if no data is required
from the respective field; <code class="STRUCTFIELD">count</code>[1] if the
scanning system is progressive, i.&nbsp;e. not interlaced. The
corresponding start value shall be ignored by the application and
driver. Anyway, drivers may not support single field capturing and
return both count values non-zero.</p><p>Both
<code class="STRUCTFIELD">count</code> values set to zero, or line numbers
outside the bounds depicted in <a href="#VBI-525">Figure 4-2</a> and <a href="#VBI-625">Figure 4-3</a>, or a field image covering
lines of two fields, are invalid and shall not be returned by the
driver.</p><p>To initialize the <code class="STRUCTFIELD">start</code>
and <code class="STRUCTFIELD">count</code> fields, applications must first
determine the current video standard selection. The <a href="#V4L2-STD-ID">v4l2_std_id</a> or
the <code class="STRUCTFIELD">framelines</code> field of struct&nbsp;<a href="#V4L2-STANDARD">v4l2_standard</a> can
be evaluated for this purpose.</p></td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">flags</code></td><td>See <a href="#VBIFMT-FLAGS">Table 4-5</a> below. Currently
only drivers set flags, applications must set this field to
zero.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code>[2]</td><td>This array is reserved for future extensions.
Drivers and applications must set it to zero.</td></tr></tbody><tbody><tr><td colspan="3">Notes:<br><a name="FTN.AEN7117">a. </a>A few devices may be unable to
sample VBI data at all but can extend the video capture window to the
VBI region.<br></td></tr></tbody></table></div><div class="TABLE"><a name="VBIFMT-FLAGS"></a><p><b>Table 4-5. Raw VBI Format Flags</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_VBI_UNSYNC</code></td><td>0x0001</td><td><p>This flag indicates hardware which does not
properly distinguish between fields. Normally the VBI image stores the
first field (lower scanning line numbers) first in memory. This may be
a top or bottom field depending on the video standard. When this flag
is set the first or second field may be stored first, however the
fields are still in correct temporal order with the older field first
in memory.<sup>a</sup></p></td></tr><tr><td><code class="CONSTANT">V4L2_VBI_INTERLACED</code></td><td>0x0002</td><td>By default the two field images will be passed
sequentially; all lines of the first field followed by all lines of
the second field (compare <a href="#FIELD-ORDER">Section 3.6</a>
<code class="CONSTANT">V4L2_FIELD_SEQ_TB</code> and
<code class="CONSTANT">V4L2_FIELD_SEQ_BT</code>, whether the top or bottom
field is first in memory depends on the video standard). When this
flag is set, the two fields are interlaced (cf.
<code class="CONSTANT">V4L2_FIELD_INTERLACED</code>). The first line of the
first field followed by the first line of the second field, then the
two second lines, and so on. Such a layout may be necessary when the
hardware has been programmed to capture or output interlaced video
images and is unable to separate the fields for VBI capturing at
the same time. For simplicity setting this flag implies that both
<code class="STRUCTFIELD">count</code> values are equal and non-zero.</td></tr></tbody><tbody><tr><td colspan="3">Notes:<br><a name="FTN.AEN7173">a. </a>Most VBI services transmit on both fields, but
some have different semantics depending on the field number. These
cannot be reliable decoded or encoded when
<code class="CONSTANT">V4L2_VBI_UNSYNC</code> is set.<br></td></tr></tbody></table></div><div class="FIGURE"><a name="VBI-HSYNC"></a><p><b>Figure 4-1. Line synchronization</b></p><div class="MEDIAOBJECT"><p><img src="v4l2_files/vbi_hsync.gif"></p></div></div><div class="FIGURE"><a name="VBI-525"></a><p><b>Figure 4-2. ITU-R 525 line numbering (M/NTSC and M/PAL)</b></p><div class="MEDIAOBJECT"><p><img src="v4l2_files/vbi_525.gif"></p><div class="CAPTION"><p>(1) For the purpose of this specification field 2
starts in line 264 and not 263.5 because half line capturing is not
supported.</p></div><p></p></div></div><div class="FIGURE"><a name="VBI-625"></a><p><b>Figure 4-3. ITU-R 625 line numbering</b></p><div class="MEDIAOBJECT"><p><img src="v4l2_files/vbi_625.gif"></p><div class="CAPTION"><p>(1) For the purpose of this specification field 2
starts in line 314 and not 313.5 because half line capturing is not
supported.</p></div><p></p></div></div><p>Remember the VBI image format depends on the selected
video standard, therefore the application must choose a new standard or
query the current standard first. Attempts to read or write data ahead
of format negotiation, or after switching the video standard which may
invalidate the negotiated VBI parameters, should be refused by the
driver. A format change during active I/O is not permitted.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN7218">4.7.4. Reading and writing VBI images</a></h3><p>To assure synchronization with the field number and easier
implementation, the smallest unit of data passed at a time is one
frame, consisting of two fields of VBI images immediately following in
memory.</p><p>The total size of a frame computes as follows:</p><pre class="PROGRAMLISTING">(<code class="STRUCTFIELD">count</code>[0] + <code class="STRUCTFIELD">count</code>[1]) *
<code class="STRUCTFIELD">samples_per_line</code> * sample size in bytes</pre><p>The sample size is most likely always one byte,
applications must check the <code class="STRUCTFIELD">sample_format</code>
field though, to function properly with other drivers.</p><p>A VBI device may support <a href="#RW">read/write</a> and/or streaming (<a href="#MMAP">memory mapping</a> or <a href="#USERP">user pointer</a>) I/O. The latter bears the
possibility of synchronizing video and
VBI data by using buffer timestamps.</p><p>Remember the <a href="#VIDIOC-STREAMON"><code class="CONSTANT">VIDIOC_STREAMON</code></a> ioctl and the first read(),
write() and select() call can be resource allocation points returning
an <span class="ERRORCODE">EBUSY</span> error code if the required hardware resources are temporarily
unavailable, for example the device is already in use by another
process.</p></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="SLICED">4.8. Sliced VBI Data Interface</a></h2><p>VBI stands for Vertical Blanking Interval, a gap in the
sequence of lines of an analog video signal. During VBI no picture
information is transmitted, allowing some time while the electron beam
of a cathode ray tube TV returns to the top of the screen.</p><p>Sliced VBI devices use hardware to demodulate data transmitted
in the VBI. V4L2 drivers shall <span class="emphasis"><i class="EMPHASIS">not</i></span> do this by
software, see also the <a href="#RAW-VBI">raw VBI
interface</a>. The data is passed as short packets of fixed size,
covering one scan line each. The number of packets per video frame is
variable.</p><p>Sliced VBI capture and output devices are accessed through the
same character special files as raw VBI devices. When a driver
supports both interfaces, the default function of a
<tt class="FILENAME">/dev/vbi</tt> device is <span class="emphasis"><i class="EMPHASIS">raw</i></span> VBI
capturing or output, and the sliced VBI function is only available
after calling the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl as defined below. Likewise a
<tt class="FILENAME">/dev/video</tt> device may support the sliced VBI API,
however the default function here is video capturing or output.
Different file descriptors must be used to pass raw and sliced VBI
data simultaneously, if this is supported by the driver.</p><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN7248">4.8.1. Querying Capabilities</a></h3><p>Devices supporting the sliced VBI capturing or output API
set the <code class="CONSTANT">V4L2_CAP_SLICED_VBI_CAPTURE</code> or
<code class="CONSTANT">V4L2_CAP_SLICED_VBI_OUTPUT</code> flag respectively, in
the <code class="STRUCTFIELD">capabilities</code> field of struct&nbsp;<a href="#V4L2-CAPABILITY">v4l2_capability</a>
returned by the <a href="#VIDIOC-QUERYCAP"><code class="CONSTANT">VIDIOC_QUERYCAP</code></a> ioctl. At least one of the
read/write, streaming or asynchronous <a href="#IO">I/O
methods</a> must be supported. Sliced VBI devices may have a tuner
or modulator.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN7258">4.8.2. Supplemental Functions</a></h3><p>Sliced VBI devices shall support <a href="#VIDEO">video
input or output</a> and <a href="#TUNER">tuner or
modulator</a> ioctls if they have these capabilities, and they may
support <a href="#CONTROL">control</a> ioctls. The <a href="#STANDARD">video standard</a> ioctls provide information
vital to program a sliced VBI device, therefore must be
supported.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN7265">4.8.3. Sliced VBI Format Negotiation</a></h3><p>To find out which data services are supported by the
hardware applications can call the <a href="#VIDIOC-G-SLICED-VBI-CAP"><code class="CONSTANT">VIDIOC_G_SLICED_VBI_CAP</code></a> ioctl.
All drivers implementing the sliced VBI interface must support this
ioctl. The results may differ from those of the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl
when the number of VBI lines the hardware can capture or output per
frame, or the number of services it can identify on a given line are
limited. For example on PAL line 16 the hardware may be able to look
for a VPS or Teletext signal, but not both at the same time.</p><p>To determine the currently selected services applications
set the <code class="STRUCTFIELD">type </code> field of struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a> to
<code class="CONSTANT"> V4L2_BUF_TYPE_SLICED_VBI_CAPTURE</code> or <code class="CONSTANT">V4L2_BUF_TYPE_SLICED_VBI_OUTPUT</code>, and the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_G_FMT</code></a>
ioctl fills the <code class="STRUCTFIELD">fmt.sliced</code> member, a
struct&nbsp;<a href="#V4L2-SLICED-VBI-FORMAT">v4l2_sliced_vbi_format</a>.</p><p>Applications can request different parameters by
initializing or modifying the <code class="STRUCTFIELD">fmt.sliced</code>
member and calling the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl with a pointer to the
<code class="STRUCTNAME">v4l2_format</code> structure.</p><p>The sliced VBI API is more complicated than the raw VBI API
because the hardware must be told which VBI service to expect on each
scan line. Not all services may be supported by the hardware on all
lines (this is especially true for VBI output where Teletext is often
unsupported and other services can only be inserted in one specific
line). In many cases, however, it is sufficient to just set the
<code class="STRUCTFIELD">service_set</code> field to the required services
and let the driver fill the <code class="STRUCTFIELD">service_lines</code>
array according to hardware capabilities. Only if more precise control
is needed should the programmer set the
<code class="STRUCTFIELD">service_lines</code> array explicitly.</p><p>The <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl returns an <span class="ERRORCODE">EINVAL</span> error code only when the
given parameters are ambiguous, otherwise it modifies the parameters
according to hardware capabilities. When the driver allocates
resources at this point, it may return an <span class="ERRORCODE">EBUSY</span> error code if the required
resources are temporarily unavailable. Other resource allocation
points which may return <span class="ERRORCODE">EBUSY</span> can be the
<a href="#VIDIOC-STREAMON"><code class="CONSTANT">VIDIOC_STREAMON</code></a> ioctl and the first <a href="#FUNC-READ"><code class="FUNCTION">read()</code></a>, <a href="#FUNC-WRITE"><code class="FUNCTION">write()</code></a> and
<a href="#FUNC-SELECT"><code class="FUNCTION">select()</code></a> call.</p><div class="TABLE"><a name="V4L2-SLICED-VBI-FORMAT"></a><p><b>Table 4-6. struct
<code class="STRUCTNAME">v4l2_sliced_vbi_format</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="17%"><col title="C4" width="17%"><col title="C5" width="17%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">service_set</code></td><td colspan="3"><p>If
<code class="STRUCTFIELD">service_set</code> is non-zero when passed with
<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> or <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_TRY_FMT</code></a>, the
<code class="STRUCTFIELD">service_lines</code> array will be filled by the
driver according to the services specified in this field. For example,
if <code class="STRUCTFIELD">service_set</code> is initialized with
<code class="CONSTANT">V4L2_SLICED_TELETEXT_B | V4L2_SLICED_WSS_625</code>, a
driver for the cx25840 video decoder sets lines 7-22 of both
fields<sup>a</sup> to <code class="CONSTANT">V4L2_SLICED_TELETEXT_B</code>
and line 23 of the first field to
<code class="CONSTANT">V4L2_SLICED_WSS_625</code>. If
<code class="STRUCTFIELD">service_set</code> is set to zero, then the values
of <code class="STRUCTFIELD">service_lines</code> will be used instead.</p><p>On return the driver sets this field to the union of all
elements of the returned <code class="STRUCTFIELD">service_lines</code>
array. It may contain less services than requested, perhaps just one,
if the hardware cannot handle more services simultaneously. It may be
empty (zero) if none of the requested services are supported by the
hardware.</p></td></tr><tr><td>__u16</td><td><code class="STRUCTFIELD">service_lines</code>[2][24]</td><td colspan="3"><p>Applications initialize this
array with sets of data services the driver shall look for or insert
on the respective scan line. Subject to hardware capabilities drivers
return the requested set, a subset, which may be just a single
service, or an empty set. When the hardware cannot handle multiple
services on the same line the driver shall choose one. No assumptions
can be made on which service the driver chooses.</p><p>Data
services are defined in <a href="#VBI-SERVICES2">Table 4-7</a>. Array indices
map to ITU-R line numbers (see also <a href="#VBI-525">Figure 4-2</a> and <a href="#VBI-625">Figure 4-3</a>) as follows: </p></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>Element</td><td>525 line systems</td><td>625 line systems</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td><code class="STRUCTFIELD">service_lines</code>[0][1]</td><td align="CENTER">1</td><td align="CENTER">1</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td><code class="STRUCTFIELD">service_lines</code>[0][23]</td><td align="CENTER">23</td><td align="CENTER">23</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td><code class="STRUCTFIELD">service_lines</code>[1][1]</td><td align="CENTER">264</td><td align="CENTER">314</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td><code class="STRUCTFIELD">service_lines</code>[1][23]</td><td align="CENTER">286</td><td align="CENTER">336</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td colspan="3">Drivers must set
<code class="STRUCTFIELD">service_lines</code>[0][0] and
<code class="STRUCTFIELD">service_lines</code>[1][0] to zero.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">io_size</code></td><td colspan="3">Maximum number of bytes passed by
one <a href="#FUNC-READ"><code class="FUNCTION">read()</code></a> or <a href="#FUNC-WRITE"><code class="FUNCTION">write()</code></a> call, and the buffer size in bytes for
the <a href="#VIDIOC-QBUF"><code class="CONSTANT">VIDIOC_QBUF</code></a> and <a href="#VIDIOC-QBUF"><code class="CONSTANT">VIDIOC_DQBUF</code></a> ioctl. Drivers set this field to
the size of struct&nbsp;<a href="#V4L2-SLICED-VBI-DATA">v4l2_sliced_vbi_data</a> times the number of non-zero
elements in the returned <code class="STRUCTFIELD">service_lines</code>
array (that is the number of lines potentially carrying data).</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code>[2]</td><td colspan="3">This array is reserved for future
extensions. Applications and drivers must set it to zero.</td></tr></tbody><tbody><tr><td colspan="5">Notes:<br><a name="FTN.AEN7329">a. </a>According to <a href="#ETS300706">ETS&nbsp;300&nbsp;706</a> lines 6-22 of the
first field and lines 5-22 of the second field may carry Teletext
data.<br></td></tr></tbody></table></div><div class="TABLE"><a name="VBI-SERVICES2"></a><p><b>Table 4-7. Sliced VBI services</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="12%"><col title="C3" width="12%"><col title="C4" width="25%"><col title="C5" width="25%"></colgroup><thead><tr><th>Symbol</th><th>Value</th><th>Reference</th><th>Lines, usually</th><th>Payload</th></tr></thead><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_SLICED_TELETEXT_B</code>
(Teletext System B)</td><td>0x0001</td><td><a href="#ETS300706"><abbr class="ABBREV">ETS&nbsp;300&nbsp;706</abbr></a>, <a href="#ITU653"><abbr class="ABBREV">ITU&nbsp;BT.653</abbr></a></td><td>PAL/SECAM line 7-22, 320-335 (second field 7-22)</td><td>Last 42 of the 45 byte Teletext packet, that is
without clock run-in and framing code, lsb first transmitted.</td></tr><tr><td><code class="CONSTANT">V4L2_SLICED_VPS</code></td><td>0x0400</td><td><a href="#ETS300231"><abbr class="ABBREV">ETS&nbsp;300&nbsp;231</abbr></a></td><td>PAL line 16</td><td>Byte number 3 to 15 according to Figure 9 of
ETS&nbsp;300&nbsp;231, lsb first transmitted.</td></tr><tr><td><code class="CONSTANT">V4L2_SLICED_CAPTION_525</code></td><td>0x1000</td><td><a href="#EIA608"><abbr class="ABBREV">EIA&nbsp;608-B</abbr></a></td><td>NTSC line 21, 284 (second field 21)</td><td>Two bytes in transmission order, including parity
bit, lsb first transmitted.</td></tr><tr><td><code class="CONSTANT">V4L2_SLICED_WSS_625</code></td><td>0x4000</td><td><a href="#ITU1119"><abbr class="ABBREV">ITU&nbsp;BT.1119</abbr></a>, <a href="#EN300294"><abbr class="ABBREV">EN&nbsp;300&nbsp;294</abbr></a></td><td>PAL/SECAM line 23</td><td><pre class="SCREEN">Byte         0                 1
      msb         lsb  msb           lsb
 Bit  7 6 5 4 3 2 1 0  x x 13 12 11 10 9</pre></td></tr><tr><td><code class="CONSTANT">V4L2_SLICED_VBI_525</code></td><td>0x1000</td><td colspan="3">Set of services applicable to 525
line systems.</td></tr><tr><td><code class="CONSTANT">V4L2_SLICED_VBI_625</code></td><td>0x4401</td><td colspan="3">Set of services applicable to 625
line systems.</td></tr></tbody></table></div><p>Drivers may return an <span class="ERRORCODE">EINVAL</span> error code when applications attempt to
read or write data without prior format negotiation, after switching
the video standard (which may invalidate the negotiated VBI
parameters) and after switching the video input (which may change the
video standard as a side effect). The <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl may return
an <span class="ERRORCODE">EBUSY</span> error code when applications attempt to change the format while i/o is
in progress (between a <a href="#VIDIOC-STREAMON"><code class="CONSTANT">VIDIOC_STREAMON</code></a> and <a href="#VIDIOC-STREAMON"><code class="CONSTANT">VIDIOC_STREAMOFF</code></a> call,
and after the first <a href="#FUNC-READ"><code class="FUNCTION">read()</code></a> or <a href="#FUNC-WRITE"><code class="FUNCTION">write()</code></a> call).</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN7483">4.8.4. Reading and writing sliced VBI data</a></h3><p>A single <a href="#FUNC-READ"><code class="FUNCTION">read()</code></a> or <a href="#FUNC-WRITE"><code class="FUNCTION">write()</code></a> call must pass all data
belonging to one video frame. That is an array of
<code class="STRUCTNAME">v4l2_sliced_vbi_data</code> structures with one or
more elements and a total size not exceeding
<code class="STRUCTFIELD">io_size</code> bytes. Likewise in streaming I/O
mode one buffer of <code class="STRUCTFIELD">io_size</code> bytes must
contain data of one video frame. The <code class="STRUCTFIELD">id</code> of
unused <code class="STRUCTNAME">v4l2_sliced_vbi_data</code> elements must be
zero.</p><div class="TABLE"><a name="V4L2-SLICED-VBI-DATA"></a><p><b>Table 4-8. struct
<code class="STRUCTNAME">v4l2_sliced_vbi_data</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">id</code></td><td>A flag from <a href="#VBI-SERVICES">Table 2</a>
identifying the type of data in this packet. Only a single bit must be
set. When the <code class="STRUCTFIELD">id</code> of a captured packet is
zero, the packet is empty and the contents of other fields are
undefined. Applications shall ignore empty packets. When the
<code class="STRUCTFIELD">id</code> of a packet for output is zero the
contents of the <code class="STRUCTFIELD">data</code> field are undefined
and the driver must no longer insert data on the requested
<code class="STRUCTFIELD">field</code> and
<code class="STRUCTFIELD">line</code>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">field</code></td><td>The video field number this data has been captured
from, or shall be inserted at. <code class="CONSTANT">0</code> for the first
field, <code class="CONSTANT">1</code> for the second field.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">line</code></td><td>The field (as opposed to frame) line number this
data has been captured from, or shall be inserted at. See <a href="#VBI-525">Figure 4-2</a> and <a href="#VBI-625">Figure 4-3</a> for valid
values. Sliced VBI capture devices can set the line number of all
packets to <code class="CONSTANT">0</code> if the hardware cannot reliably
identify scan lines. The field number must always be valid.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code></td><td>This field is reserved for future extensions.
Applications and drivers must set it to zero.</td></tr><tr><td>__u8</td><td><code class="STRUCTFIELD">data</code>[48]</td><td>The packet payload. See <a href="#VBI-SERVICES">Table 2</a> for the contents and number of
bytes passed for each data type. The contents of padding bytes at the
end of this array are undefined, drivers and applications shall ignore
them.</td></tr></tbody></table></div><p>Packets are always passed in ascending line number order,
without duplicate line numbers. The <a href="#FUNC-WRITE"><code class="FUNCTION">write()</code></a> function and the
<a href="#VIDIOC-QBUF"><code class="CONSTANT">VIDIOC_QBUF</code></a> ioctl must return an <span class="ERRORCODE">EINVAL</span> error code when applications violate
this rule. They must also return an <span class="ERRORCODE">EINVAL</span> error code when applications pass an
incorrect field or line number, or a combination of
<code class="STRUCTFIELD">field</code>, <code class="STRUCTFIELD">line</code> and
<code class="STRUCTFIELD">id</code> which has not been negotiated with the
<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_G_FMT</code></a> or <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl. When the line numbers are
unknown the driver must pass the packets in transmitted order. The
driver can insert empty packets with <code class="STRUCTFIELD">id</code> set
to zero anywhere in the packet array.</p><p>To assure synchronization and to distinguish from frame
dropping, when a captured frame does not carry any of the requested
data services drivers must pass one or more empty packets. When an
application fails to pass VBI data in time for output, the driver
must output the last VPS and WSS packet again, and disable the output
of Closed Caption and Teletext data, or output data which is ignored
by Closed Caption and Teletext decoders.</p><p>A sliced VBI device may support <a href="#RW">read/write</a> and/or streaming (<a href="#MMAP">memory mapping</a> and/or <a href="#USERP">user
pointer</a>) I/O. The latter bears the possibility of synchronizing
video and VBI data by using buffer timestamps.</p></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="TTX">4.9. Teletext Interface</a></h2><p>This interface aims at devices receiving and demodulating
Teletext data [<a href="#ETS300706"><abbr class="ABBREV">ETS&nbsp;300&nbsp;706</abbr></a>, <a href="#ITU653"><abbr class="ABBREV">ITU&nbsp;BT.653</abbr></a>], evaluating the
Teletext packages and storing formatted pages in cache memory. Such
devices are usually implemented as microcontrollers with serial
interface (I<sup>2</sup>C) and can be found on older
TV cards, dedicated Teletext decoding cards and home-brew devices
connected to the PC parallel port.</p><p>The Teletext API was designed by Martin Buck. It is defined in
the kernel header file <tt class="FILENAME">linux/videotext.h</tt>, the
specification is available from <a href="http://home.pages.de/%7Evideotext/" target="_top">http://home.pages.de/~videotext/</a>. (Videotext is the name of
the German public television Teletext service.) Conventional character
device file names are <tt class="FILENAME">/dev/vtx</tt> and
<tt class="FILENAME">/dev/vttuner</tt>, with device number 83, 0 and 83, 16
respectively. A similar interface exists for the Philips SAA5249
Teletext decoder [specification?] with character device file names
<tt class="FILENAME">/dev/tlkN</tt>, device number 102, N.</p><p>Eventually the Teletext API was integrated into the V4L API
with character device file names <tt class="FILENAME">/dev/vtx0</tt> to
<tt class="FILENAME">/dev/vtx31</tt>, device major number 81, minor numbers
192 to 223. For reference the V4L Teletext API specification is
reproduced here in full: "Teletext interfaces talk the existing VTX
API." Teletext devices with major number 83 and 102 will be removed in
Linux 2.6.</p><p>There are no plans to replace the Teletext API or to integrate
it into V4L2. Please write to the Video4Linux mailing list: <a href="https://listman.redhat.com/mailman/listinfo/video4linux-list" target="_top">https://listman.redhat.com/mailman/listinfo/video4linux-list</a> 
when the need arises.</p></div><div class="SECTION"><hr><h2 class="SECTION"><a name="RADIO">4.10. Radio Interface</a></h2><p>This interface is intended for AM and FM (analog) radio
receivers.</p><p>Conventionally V4L2 radio devices are accessed through
character device special files named <tt class="FILENAME">/dev/radio</tt>
and <tt class="FILENAME">/dev/radio0</tt> to
<tt class="FILENAME">/dev/radio63</tt> with major number 81 and minor
numbers 64 to 127.</p><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN7585">4.10.1. Querying Capabilities</a></h3><p>Devices supporting the radio interface set the
<code class="CONSTANT">V4L2_CAP_RADIO</code> and
<code class="CONSTANT">V4L2_CAP_TUNER</code> flag in the
<code class="STRUCTFIELD">capabilities</code> field of struct&nbsp;<a href="#V4L2-CAPABILITY">v4l2_capability</a>
returned by the <a href="#VIDIOC-QUERYCAP"><code class="CONSTANT">VIDIOC_QUERYCAP</code></a> ioctl. Other combinations of
capability flags are reserved for future extensions.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN7594">4.10.2. Supplemental Functions</a></h3><p>Radio devices can support <a href="#CONTROL">controls</a>, and must support the <a href="#TUNER">tuner</a> ioctls.</p><p>They do not support the video input or output, audio input
or output, video standard, cropping and scaling, compression and
streaming parameter, or overlay ioctls. All other ioctls and I/O
methods are reserved for future extensions.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN7600">4.10.3. Programming</a></h3><p>Radio devices may have a couple audio controls (as discussed
in <a href="#CONTROL">Section 1.8</a>) such as a volume control, possibly custom
controls. Further all radio devices have one tuner (these are
discussed in <a href="#TUNER">Section 1.6</a>) with index number zero to select
the radio frequency and to determine if a monaural or FM stereo
program is received. Drivers switch automatically between AM and FM
depending on the selected frequency. The <a href="#VIDIOC-G-TUNER"><code class="CONSTANT">VIDIOC_G_TUNER</code></a> ioctl
reports the supported frequency range.</p></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="RDS">4.11. RDS Interface</a></h2><p>The Radio Data System transmits supplementary
information in binary format, for example the station name or travel
information, on a inaudible audio subcarrier of a radio program. This
interface aims at devices capable of receiving and decoding RDS
information.</p><p>The V4L API defines its RDS API as follows.</p><p>From radio devices supporting it, RDS data can be read
with the <a href="#FUNC-READ"><code class="FUNCTION">read()</code></a> function. The data is packed in groups of three,
as follows:</p><p></p><ol type="1"><li><p>First Octet Least Significant Byte of RDS Block</p></li><li><p>Second Octet Most Significant Byte of RDS Block</p></li><li><p>Third Octet Bit 7: Error bit. Indicates that an
uncorrectable error occurred during reception of this block. Bit 6:
Corrected bit. Indicates that an error was corrected for this data
block. Bits 5-3: Received Offset. Indicates the offset received by the
sync system. Bits 2-0: Offset Name. Indicates the offset applied to
this data.</p></li></ol><p></p><p>It was argued  the RDS API should be
extended before integration into V4L2, no new API has been devised yet.
Please write to the Video4Linux mailing list for discussion: <a href="https://listman.redhat.com/mailman/listinfo/video4linux-list" target="_top">https://listman.redhat.com/mailman/listinfo/video4linux-list</a>. 
Meanwhile no V4L2 driver should set the
<code class="CONSTANT">V4L2_CAP_RDS_CAPTURE</code> capability flag.</p></div></div><div class="REFERENCE"><a name="USER-FUNC"></a><div class="TITLEPAGE"><h1 class="TITLE">I. Function Reference</h1><div class="TOC"><dl><dt><b>Table of Contents</b></dt><dt><a href="#FUNC-CLOSE">V4L2 close()</a>&nbsp;--&nbsp;Close a V4L2 device</dt><dt><a href="#FUNC-IOCTL">V4L2 ioctl()</a>&nbsp;--&nbsp;Program a V4L2 device</dt><dt><a href="#VIDIOC-CROPCAP">ioctl VIDIOC_CROPCAP</a>&nbsp;--&nbsp;Information about the video cropping and scaling abilities</dt><dt><a href="#VIDIOC-DBG-G-REGISTER">ioctl VIDIOC_DBG_G_REGISTER, VIDIOC_DBG_S_REGISTER</a>&nbsp;--&nbsp;Read or write hardware registers</dt><dt><a href="#VIDIOC-ENCODER-CMD">ioctl VIDIOC_ENCODER_CMD, VIDIOC_TRY_ENCODER_CMD</a>&nbsp;--&nbsp;Execute an encoder command</dt><dt><a href="#VIDIOC-ENUMAUDIO">ioctl VIDIOC_ENUMAUDIO</a>&nbsp;--&nbsp;Enumerate audio inputs</dt><dt><a href="#VIDIOC-ENUMAUDIOOUT">ioctl VIDIOC_ENUMAUDOUT</a>&nbsp;--&nbsp;Enumerate audio outputs</dt><dt><a href="#VIDIOC-ENUM-FMT">ioctl VIDIOC_ENUM_FMT</a>&nbsp;--&nbsp;Enumerate image formats</dt><dt><a href="#VIDIOC-ENUM-FRAMESIZES">ioctl VIDIOC_ENUM_FRAMESIZES</a>&nbsp;--&nbsp;Enumerate frame sizes</dt><dt><a href="#VIDIOC-ENUM-FRAMEINTERVALS">ioctl VIDIOC_ENUM_FRAMEINTERVALS</a>&nbsp;--&nbsp;Enumerate frame intervals</dt><dt><a href="#VIDIOC-ENUMINPUT">ioctl VIDIOC_ENUMINPUT</a>&nbsp;--&nbsp;Enumerate video inputs</dt><dt><a href="#VIDIOC-ENUMOUTPUT">ioctl VIDIOC_ENUMOUTPUT</a>&nbsp;--&nbsp;Enumerate video outputs</dt><dt><a href="#VIDIOC-ENUMSTD">ioctl VIDIOC_ENUMSTD</a>&nbsp;--&nbsp;Enumerate supported video standards</dt><dt><a href="#VIDIOC-G-AUDIO">ioctl VIDIOC_G_AUDIO, VIDIOC_S_AUDIO</a>&nbsp;--&nbsp;Query or select the current audio input and its
attributes</dt><dt><a href="#VIDIOC-G-AUDIOOUT">ioctl VIDIOC_G_AUDOUT, VIDIOC_S_AUDOUT</a>&nbsp;--&nbsp;Query or select the current audio output</dt><dt><a href="#VIDIOC-G-CHIP-IDENT">ioctl VIDIOC_G_CHIP_IDENT</a>&nbsp;--&nbsp;Identify the chips on a TV card</dt><dt><a href="#VIDIOC-G-CROP">ioctl VIDIOC_G_CROP, VIDIOC_S_CROP</a>&nbsp;--&nbsp;Get or set the current cropping rectangle</dt><dt><a href="#VIDIOC-G-CTRL">ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL</a>&nbsp;--&nbsp;Get or set the value of a control</dt><dt><a href="#VIDIOC-G-ENC-INDEX">ioctl VIDIOC_G_ENC_INDEX</a>&nbsp;--&nbsp;Get meta data about a compressed video stream</dt><dt><a href="#VIDIOC-G-EXT-CTRLS">ioctl VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS,
VIDIOC_TRY_EXT_CTRLS</a>&nbsp;--&nbsp;Get or set the value of several controls, try control
values</dt><dt><a href="#VIDIOC-G-FBUF">ioctl VIDIOC_G_FBUF, VIDIOC_S_FBUF</a>&nbsp;--&nbsp;Get or set frame buffer overlay parameters</dt><dt><a href="#VIDIOC-G-FMT">ioctl VIDIOC_G_FMT, VIDIOC_S_FMT,
VIDIOC_TRY_FMT</a>&nbsp;--&nbsp;Get or set the data format, try a format</dt><dt><a href="#VIDIOC-G-FREQUENCY">ioctl VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY</a>&nbsp;--&nbsp;Get or set tuner or modulator radio
frequency</dt><dt><a href="#VIDIOC-G-INPUT">ioctl VIDIOC_G_INPUT, VIDIOC_S_INPUT</a>&nbsp;--&nbsp;Query or select the current video input</dt><dt><a href="#VIDIOC-G-JPEGCOMP">ioctl VIDIOC_G_JPEGCOMP, VIDIOC_S_JPEGCOMP</a>&nbsp;--&nbsp;</dt><dt><a href="#VIDIOC-G-MODULATOR">ioctl VIDIOC_G_MODULATOR, VIDIOC_S_MODULATOR</a>&nbsp;--&nbsp;Get or set modulator attributes</dt><dt><a href="#VIDIOC-G-OUTPUT">ioctl VIDIOC_G_OUTPUT, VIDIOC_S_OUTPUT</a>&nbsp;--&nbsp;Query or select the current video output</dt><dt><a href="#VIDIOC-G-PARM">ioctl VIDIOC_G_PARM, VIDIOC_S_PARM</a>&nbsp;--&nbsp;Get or set streaming parameters</dt><dt><a href="#VIDIOC-G-PRIORITY">ioctl VIDIOC_G_PRIORITY, VIDIOC_S_PRIORITY</a>&nbsp;--&nbsp;Query or request the access priority associated with a
file descriptor</dt><dt><a href="#VIDIOC-G-SLICED-VBI-CAP">ioctl VIDIOC_G_SLICED_VBI_CAP</a>&nbsp;--&nbsp;Query sliced VBI capabilities</dt><dt><a href="#VIDIOC-G-STD">ioctl VIDIOC_G_STD, VIDIOC_S_STD</a>&nbsp;--&nbsp;Query or select the video standard of the current input</dt><dt><a href="#VIDIOC-G-TUNER">ioctl VIDIOC_G_TUNER, VIDIOC_S_TUNER</a>&nbsp;--&nbsp;Get or set tuner attributes</dt><dt><a href="#VIDIOC-LOG-STATUS">ioctl VIDIOC_LOG_STATUS</a>&nbsp;--&nbsp;Log driver status information</dt><dt><a href="#VIDIOC-OVERLAY">ioctl VIDIOC_OVERLAY</a>&nbsp;--&nbsp;Start or stop video overlay</dt><dt><a href="#VIDIOC-QBUF">ioctl VIDIOC_QBUF, VIDIOC_DQBUF</a>&nbsp;--&nbsp;Exchange a buffer with the driver</dt><dt><a href="#VIDIOC-QUERYBUF">ioctl VIDIOC_QUERYBUF</a>&nbsp;--&nbsp;Query the status of a buffer</dt><dt><a href="#VIDIOC-QUERYCAP">ioctl VIDIOC_QUERYCAP</a>&nbsp;--&nbsp;Query device capabilities</dt><dt><a href="#VIDIOC-QUERYCTRL">ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERYMENU</a>&nbsp;--&nbsp;Enumerate controls and menu control items</dt><dt><a href="#VIDIOC-QUERYSTD">ioctl VIDIOC_QUERYSTD</a>&nbsp;--&nbsp;Sense the video standard received by the current
input</dt><dt><a href="#VIDIOC-REQBUFS">ioctl VIDIOC_REQBUFS</a>&nbsp;--&nbsp;Initiate Memory Mapping or User Pointer I/O</dt><dt><a href="#VIDIOC-STREAMON">ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF</a>&nbsp;--&nbsp;Start or stop streaming I/O</dt><dt><a href="#FUNC-MMAP">V4L2 mmap()</a>&nbsp;--&nbsp;Map device memory into application address space</dt><dt><a href="#FUNC-MUNMAP">V4L2 munmap()</a>&nbsp;--&nbsp;Unmap device memory</dt><dt><a href="#FUNC-OPEN">V4L2 open()</a>&nbsp;--&nbsp;Open a V4L2 device</dt><dt><a href="#FUNC-POLL">V4L2 poll()</a>&nbsp;--&nbsp;Wait for some event on a file descriptor</dt><dt><a href="#FUNC-READ">V4L2 read()</a>&nbsp;--&nbsp;Read from a V4L2 device</dt><dt><a href="#FUNC-SELECT">V4L2 select()</a>&nbsp;--&nbsp;Synchronous I/O multiplexing</dt><dt><a href="#FUNC-WRITE">V4L2 write()</a>&nbsp;--&nbsp;Write to a V4L2 device</dt></dl></div></div><h1><a name="FUNC-CLOSE"></a>V4L2 close()</h1><div class="REFNAMEDIV"><a name="AEN7630"></a><h2>Name</h2>v4l2-close&nbsp;--&nbsp;Close a V4L2 device</div><div class="REFSYNOPSISDIV"><a name="AEN7633"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN7634"></a><pre class="FUNCSYNOPSISINFO">#include &lt;unistd.h&gt;</pre><p><code><code class="FUNCDEF">int close</code>(int fd);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN7641"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd></dl></div></div><div class="REFSECT1"><a name="AEN7651"></a><h2>Description</h2><p>Closes the device. Any I/O in progress is terminated and
resources associated with the file descriptor are freed. However data
format parameters, current input or output, control values or other
properties remain unchanged.</p></div><div class="REFSECT1"><a name="AEN7654"></a><h2>Return Value</h2><p>The function returns <span class="RETURNVALUE">0</span> on
success, <span class="RETURNVALUE">-1</span> on failure and the
<code class="VARNAME">errno</code> is set appropriately. Possible error
codes:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EBADF</span></dt><dd><p><code class="PARAMETER">fd</code> is not a valid open file
descriptor.</p></dd></dl></div></div><h1><a name="FUNC-IOCTL"></a>V4L2 ioctl()</h1><div class="REFNAMEDIV"><a name="AEN7671"></a><h2>Name</h2>v4l2-ioctl&nbsp;--&nbsp;Program a V4L2 device</div><div class="REFSYNOPSISDIV"><a name="AEN7674"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN7675"></a><pre class="FUNCSYNOPSISINFO">#include &lt;sys/ioctl.h&gt;</pre><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, void *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN7686"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>V4L2 ioctl request code as defined in the <a href="#VIDEODEV">videodev.h</a> header file, for example
VIDIOC_QUERYCAP.</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p>Pointer to a function parameter, usually a structure.</p></dd></dl></div></div><div class="REFSECT1"><a name="AEN7707"></a><h2>Description</h2><p>The <code class="FUNCTION">ioctl()</code> function is used to program
V4L2 devices. The argument <code class="PARAMETER">fd</code> must be an open
file descriptor. An ioctl <code class="PARAMETER">request</code> has encoded
in it whether the argument is an input, output or read/write
parameter, and the size of the argument <code class="PARAMETER">argp</code> in
bytes. Macros and defines specifying V4L2 ioctl requests are located
in the <a href="#VIDEODEV">videodev.h</a> header file.
Applications should use their own copy, not include the version in the
kernel sources on the system they compile on. All V4L2 ioctl requests,
their respective function and parameters are specified in <a href="#USER-FUNC">Reference I, <i>Function Reference</i></a>.</p></div><div class="REFSECT1"><a name="AEN7716"></a><h2>Return Value</h2><p>On success the <code class="FUNCTION">ioctl()</code> function returns
<span class="RETURNVALUE">0</span> and does not reset the
<code class="VARNAME">errno</code> variable. On failure
<span class="RETURNVALUE">-1</span> is returned, when the ioctl takes an
output or read/write parameter it remains unmodified, and the
<code class="VARNAME">errno</code> variable is set appropriately. See below for
possible error codes. Generic errors like <span class="ERRORCODE">EBADF</span>
or <span class="ERRORCODE">EFAULT</span> are not listed in the sections
discussing individual ioctl requests.</p><p>Note ioctls may return undefined error codes. Since errors
may have side effects such as a driver reset applications should
abort on unexpected errors.</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EBADF</span></dt><dd><p><code class="PARAMETER">fd</code> is not a valid open file
descriptor.</p></dd><dt><span class="ERRORCODE">EBUSY</span></dt><dd><p>The property cannot be changed right now. Typically
this error code is returned when I/O is in progress or the driver
supports multiple opens and another process locked the property.</p></dd><dt><span class="ERRORCODE">EFAULT</span></dt><dd><p><code class="PARAMETER">argp</code> references an inaccessible
memory area.</p></dd><dt><span class="ERRORCODE">ENOTTY</span></dt><dd><p><code class="PARAMETER">fd</code> is  not  associated  with  a
character special device.</p></dd><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The <code class="PARAMETER">request</code> or the data pointed
to by <code class="PARAMETER">argp</code> is not valid. This is a very common
error code, see the individual ioctl requests listed in <a href="#USER-FUNC">Reference I, <i>Function Reference</i></a> for actual causes.</p></dd><dt><span class="ERRORCODE">ENOMEM</span></dt><dd><p>Not enough physical or virtual memory was available to
complete the request.</p></dd><dt><span class="ERRORCODE">ERANGE</span></dt><dd><p>The application attempted to set a control with the
<a href="#VIDIOC-G-CTRL"><code class="CONSTANT">VIDIOC_S_CTRL</code></a> ioctl to a value which is out of bounds.</p></dd></dl></div></div><h1><a name="VIDIOC-CROPCAP"></a>ioctl VIDIOC_CROPCAP</h1><div class="REFNAMEDIV"><a name="AEN7775"></a><h2>Name</h2>VIDIOC_CROPCAP&nbsp;--&nbsp;Information about the video cropping and scaling abilities</div><div class="REFSYNOPSISDIV"><a name="AEN7778"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN7779"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_cropcap
*argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN7789"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_CROPCAP</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN7809"></a><h2>Description</h2><p>Applications use this function to query the cropping
limits, the pixel aspect of images and to calculate scale factors.
They set the <code class="STRUCTFIELD">type</code> field of a v4l2_cropcap
structure to the respective buffer (stream) type and call the
<code class="CONSTANT">VIDIOC_CROPCAP</code> ioctl with a pointer to this
structure. Drivers fill the rest of the structure. The results are
constant except when switching the video standard. Remember this
switch can occur implicit when switching the video input or
output.</p><div class="TABLE"><a name="V4L2-CROPCAP"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_cropcap</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>enum&nbsp;<a href="#V4L2-BUF-TYPE">v4l2_buf_type</a></td><td><code class="STRUCTFIELD">type</code></td><td>Type of the data stream, set by the application.
Only these types are valid here:
<code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_CAPTURE</code>,
<code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_OUTPUT</code>,
<code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_OVERLAY</code>, and custom (driver
defined) types with code <code class="CONSTANT">V4L2_BUF_TYPE_PRIVATE</code>
and higher.</td></tr><tr><td>struct <a href="#V4L2-RECT-CROP">v4l2_rect</a></td><td><code class="STRUCTFIELD">bounds</code></td><td>Defines the window within capturing or output is
possible, this may exclude for example the horizontal and vertical
blanking areas. The cropping rectangle cannot exceed these limits.
Width and height are defined in pixels, the driver writer is free to
choose origin and units of the coordinate system in the analog
domain.</td></tr><tr><td>struct <a href="#V4L2-RECT-CROP">v4l2_rect</a></td><td><code class="STRUCTFIELD">defrect</code></td><td>Default cropping rectangle, it shall cover the
"whole picture". Assuming pixel aspect 1/1 this could be for example a
640&nbsp;¡Á&nbsp;480 rectangle for NTSC, a
768&nbsp;¡Á&nbsp;576 rectangle for PAL and SECAM centered over
the active picture area. The same co-ordinate system as for
            <code class="STRUCTFIELD">bounds</code> is used.</td></tr><tr><td>struct&nbsp;<a href="#V4L2-FRACT">v4l2_fract</a></td><td><code class="STRUCTFIELD">pixelaspect</code></td><td><p>This is the pixel aspect (y / x) when no
scaling is applied, the ratio of the actual sampling
frequency and the frequency required to get square
pixels.</p><p>When cropping coordinates refer to square pixels,
the driver sets <code class="STRUCTFIELD">pixelaspect</code> to 1/1. Other
common values are 54/59 for PAL and SECAM, 11/10 for NTSC sampled
according to [<a href="#ITU601"><abbr class="ABBREV">ITU&nbsp;BT.601</abbr></a>].</p></td></tr></tbody></table></div><div class="TABLE"><a name="V4L2-RECT-CROP"></a><p><b>Table 2. struct <code class="STRUCTNAME">v4l2_rect</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__s32</td><td><code class="STRUCTFIELD">left</code></td><td>Horizontal offset of the top, left corner of the
rectangle, in pixels.</td></tr><tr><td>__s32</td><td><code class="STRUCTFIELD">top</code></td><td>Vertical offset of the top, left corner of the
rectangle, in pixels.</td></tr><tr><td>__s32</td><td><code class="STRUCTFIELD">width</code></td><td>Width of the rectangle, in pixels.</td></tr><tr><td>__s32</td><td><code class="STRUCTFIELD">height</code></td><td>Height of the rectangle, in pixels. Width
and height cannot be negative, the fields are signed for
hysterical reasons. </td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN7885"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The struct&nbsp;<a href="#V4L2-CROPCAP">v4l2_cropcap</a> <code class="STRUCTFIELD">type</code> is
invalid or the ioctl is not supported. This is not permitted for
video capture, output and overlay devices, which must support
<code class="CONSTANT">VIDIOC_CROPCAP</code>.</p></dd></dl></div></div><h1><a name="VIDIOC-DBG-G-REGISTER"></a>ioctl VIDIOC_DBG_G_REGISTER, VIDIOC_DBG_S_REGISTER</h1><div class="REFNAMEDIV"><a name="AEN7904"></a><h2>Name</h2>VIDIOC_DBG_G_REGISTER, VIDIOC_DBG_S_REGISTER&nbsp;--&nbsp;Read or write hardware registers</div><div class="REFSYNOPSISDIV"><a name="AEN7908"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN7909"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_register *argp);</code></p><p></p></div><div class="FUNCSYNOPSIS"><p></p><a name="AEN7919"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, const struct v4l2_register
*argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN7929"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_DBG_G_REGISTER, VIDIOC_DBG_S_REGISTER</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN7949"></a><h2>Description</h2><div class="NOTE"><blockquote class="NOTE"><p><b>Experimental: </b>This is an <a href="#EXPERIMENTAL">experimental</a>
interface and may change in the future.</p></blockquote></div><p>For driver debugging purposes these ioctls allow test
applications to access hardware registers directly. Regular
applications should not use them.</p><p>Since writing or even reading registers can jeopardize the
system security, its stability and damage the hardware, both ioctls
require superuser privileges. Additionally the Linux kernel must be
compiled with the <code class="CONSTANT">CONFIG_VIDEO_ADV_DEBUG</code> option
to enable these ioctls.</p><p>To write a register applications must initialize all fields
of a struct&nbsp;<a href="#V4L2-REGISTER">v4l2_register</a> and call
<code class="CONSTANT">VIDIOC_DBG_S_REGISTER</code> with a pointer to this
structure. The <code class="STRUCTFIELD">match_type</code> and
<code class="STRUCTFIELD">match_chip</code> fields select a chip on the TV
card, the <code class="STRUCTFIELD">reg</code> field specifies a register
number and the <code class="STRUCTFIELD">val</code> field the value to be
written into the register.</p><p>To read a register applications must initialize the
<code class="STRUCTFIELD">match_type</code>,
<code class="STRUCTFIELD">match_chip</code> and
<code class="STRUCTFIELD">reg</code> fields, and call
<code class="CONSTANT">VIDIOC_DBG_G_REGISTER</code> with a pointer to this
structure. On success the driver stores the register value in the
<code class="STRUCTFIELD">val</code> field. On failure the structure remains
unchanged.</p><p>When <code class="STRUCTFIELD">match_type</code> is
<code class="CONSTANT">V4L2_CHIP_MATCH_HOST</code>,
<code class="STRUCTFIELD">match_chip</code> selects the nth non-I<sup>2</sup>C chip
on the TV card. Drivers may also interpret
<code class="STRUCTFIELD">match_chip</code> as a random ID, but we recommend
against that. The number zero always selects the host chip, e.&nbsp;g. the
chip connected to the PCI bus. You can find out which chips are
present with the <a href="#VIDIOC-G-CHIP-IDENT"><code class="CONSTANT">VIDIOC_G_CHIP_IDENT</code></a> ioctl.</p><p>When <code class="STRUCTFIELD">match_type</code> is
<code class="CONSTANT">V4L2_CHIP_MATCH_I2C_DRIVER</code>,
<code class="STRUCTFIELD">match_chip</code> contains a driver ID as defined
in the <tt class="FILENAME">linux/i2c-id.h</tt> header file. For instance
<code class="CONSTANT">I2C_DRIVERID_SAA7127</code> will match any chip
supported by the saa7127 driver, regardless of its I<sup>2</sup>C bus address.
When multiple chips supported by the same driver are present, the
effect of these ioctls is undefined. Again with the
<a href="#VIDIOC-G-CHIP-IDENT"><code class="CONSTANT">VIDIOC_G_CHIP_IDENT</code></a> ioctl you can find out which I<sup>2</sup>C chips are
present.</p><p>When <code class="STRUCTFIELD">match_type</code> is
<code class="CONSTANT">V4L2_CHIP_MATCH_I2C_ADDR</code>,
<code class="STRUCTFIELD">match_chip</code> selects a chip by its 7 bit I<sup>2</sup>C
bus address.</p><div class="NOTE"><blockquote class="NOTE"><p><b>Success not guaranteed: </b>Due to a flaw in the Linux I<sup>2</sup>C bus driver these ioctls may
return successfully without actually reading or writing a register. To
catch the most likely failure we recommend a <a href="#VIDIOC-G-CHIP-IDENT"><code class="CONSTANT">VIDIOC_G_CHIP_IDENT</code></a>
call confirming the presence of the selected I<sup>2</sup>C chip.</p></blockquote></div><p>These ioctls are optional, not all drivers may support them.
However when a driver supports these ioctls it must also support
<a href="#VIDIOC-G-CHIP-IDENT"><code class="CONSTANT">VIDIOC_G_CHIP_IDENT</code></a>. Conversely it may support
<code class="CONSTANT">VIDIOC_G_CHIP_IDENT</code> but not these ioctls.</p><p><code class="CONSTANT">VIDIOC_DBG_G_REGISTER</code> and
<code class="CONSTANT">VIDIOC_DBG_S_REGISTER</code> were introduced in Linux
2.6.21.</p><p>We recommended the <span class="APPLICATION">v4l2-dbg</span>
utility over calling these ioctls directly. It is available from the
LinuxTV v4l-dvb repository; see <a href="http://linuxtv.org/repo/" target="_top">http://linuxtv.org/repo/</a> for
access instructions.</p><div class="TABLE"><a name="V4L2-REGISTER"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_register</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="33%"><col title="C2" width="33%"><col title="C4" width="33%"><col></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">match_type</code></td><td>See <a href="#CHIP-MATCH-TYPES">Table 2</a> for a list of
 possible types.</td><td>&nbsp;</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">match_chip</code></td><td>Match a chip by this number, interpreted according
to the <code class="STRUCTFIELD">match_type</code> field.</td><td>&nbsp;</td></tr><tr><td>__u64</td><td><code class="STRUCTFIELD">reg</code></td><td>A register number.</td><td>&nbsp;</td></tr><tr><td>__u64</td><td><code class="STRUCTFIELD">val</code></td><td>The value read from, or to be written into the
register.</td><td>&nbsp;</td></tr></tbody></table></div><div class="TABLE"><a name="CHIP-MATCH-TYPES"></a><p><b>Table 2. Chip Match Types</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_CHIP_MATCH_HOST</code></td><td>0</td><td>Match the nth chip on the card, zero for the
            host chip. Does not match I<sup>2</sup>C chips.</td></tr><tr><td><code class="CONSTANT">V4L2_CHIP_MATCH_I2C_DRIVER</code></td><td>1</td><td>Match an I<sup>2</sup>C chip by its driver ID from the
<tt class="FILENAME">linux/i2c-id.h</tt> header file.</td></tr><tr><td><code class="CONSTANT">V4L2_CHIP_MATCH_I2C_ADDR</code></td><td>2</td><td>Match a chip by its 7 bit I<sup>2</sup>C bus address.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN8068"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The driver does not support this ioctl, or the kernel
was not compiled with the <code class="CONSTANT">CONFIG_VIDEO_ADV_DEBUG</code>
option, or the <code class="STRUCTFIELD">match_type</code> is invalid, or the
selected chip or register does not exist.</p></dd><dt><span class="ERRORCODE">EPERM</span></dt><dd><p>Insufficient permissions. Root privileges are required
to execute these ioctls.</p></dd></dl></div></div><h1><a name="VIDIOC-ENCODER-CMD"></a>ioctl VIDIOC_ENCODER_CMD, VIDIOC_TRY_ENCODER_CMD</h1><div class="REFNAMEDIV"><a name="AEN8091"></a><h2>Name</h2>VIDIOC_ENCODER_CMD, VIDIOC_TRY_ENCODER_CMD&nbsp;--&nbsp;Execute an encoder command</div><div class="REFSYNOPSISDIV"><a name="AEN8095"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN8096"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_encoder_cmd *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN8106"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_ENCODER_CMD, VIDIOC_TRY_ENCODER_CMD</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN8126"></a><h2>Description</h2><div class="NOTE"><blockquote class="NOTE"><p><b>Experimental: </b>This is an <a href="#EXPERIMENTAL">experimental</a>
interface and may change in the future.</p></blockquote></div><p>These ioctls control an audio/video (usually MPEG-) encoder.
<code class="CONSTANT">VIDIOC_ENCODER_CMD</code> sends a command to the
encoder, <code class="CONSTANT">VIDIOC_TRY_ENCODER_CMD</code> can be used to
try a command without actually executing it.</p><p>To send a command applications must initialize all fields of a
    struct&nbsp;<a href="#V4L2-ENCODER-CMD">v4l2_encoder_cmd</a> and call
    <code class="CONSTANT">VIDIOC_ENCODER_CMD</code> or
    <code class="CONSTANT">VIDIOC_TRY_ENCODER_CMD</code> with a pointer to this
    structure.</p><p>The <code class="STRUCTFIELD">cmd</code> field must contain the
command code. The <code class="STRUCTFIELD">flags</code> field is currently
only used by the STOP command and contains one bit: If the
<code class="CONSTANT">V4L2_ENC_CMD_STOP_AT_GOP_END</code> flag is set,
encoding will continue until the end of the current <i class="WORDASWORD">Group
Of Pictures</i>, otherwise it will stop immediately.</p><p>A <code class="FUNCTION">read</code>() call sends a START command to
the encoder if it has not been started yet. After a STOP command,
<code class="FUNCTION">read</code>() calls will read the remaining data
buffered by the driver. When the buffer is empty,
<code class="FUNCTION">read</code>() will return zero and the next
<code class="FUNCTION">read</code>() call will restart the encoder.</p><p>A <code class="FUNCTION">close</code>() call sends an immediate STOP
to the encoder, and all buffered data is discarded.</p><p>These ioctls are optional, not all drivers may support
them. They were introduced in Linux 2.6.21.</p><div class="TABLE"><a name="V4L2-ENCODER-CMD"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_encoder_cmd</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">cmd</code></td><td>The encoder command, see <a href="#ENCODER-CMDS">Table 2</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">flags</code></td><td>Flags to go with the command, see <a href="#ENCODER-FLAGS">Table 3</a>. If no flags are defined for
this command, drivers and applications must set this field to
zero.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">data</code>[8]</td><td>Reserved for future extensions. Drivers and
applications must set the array to zero.</td></tr></tbody></table></div><div class="TABLE"><a name="ENCODER-CMDS"></a><p><b>Table 2. Encoder Commands</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_ENC_CMD_START</code></td><td>0</td><td>Start the encoder. When the encoder is already
running or paused, this command does nothing. No flags are defined for
this command.</td></tr><tr><td><code class="CONSTANT">V4L2_ENC_CMD_STOP</code></td><td>1</td><td>Stop the encoder. When the
<code class="CONSTANT">V4L2_ENC_CMD_STOP_AT_GOP_END</code> flag is set,
encoding will continue until the end of the current <i class="WORDASWORD">Group
Of Pictures</i>, otherwise encoding will stop immediately.
When the encoder is already stopped, this command does
nothing.</td></tr><tr><td><code class="CONSTANT">V4L2_ENC_CMD_PAUSE</code></td><td>2</td><td>Pause the encoder. When the encoder has not been
started yet, the driver will return an <span class="ERRORCODE">EPERM</span> error code. When the encoder is
already paused, this command does nothing. No flags are defined for
this command.</td></tr><tr><td><code class="CONSTANT">V4L2_ENC_CMD_RESUME</code></td><td>3</td><td>Resume encoding after a PAUSE command. When the
encoder has not been started yet, the driver will return an <span class="ERRORCODE">EPERM</span> error code.
When the encoder is already running, this command does nothing. No
flags are defined for this command.</td></tr></tbody></table></div><div class="TABLE"><a name="ENCODER-FLAGS"></a><p><b>Table 3. Encoder Command Flags</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_ENC_CMD_STOP_AT_GOP_END</code></td><td>0x0001</td><td>Stop encoding at the end of the current <i class="WORDASWORD">Group Of
Pictures</i>, rather than immediately.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN8224"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The driver does not support this ioctl, or the
<code class="STRUCTFIELD">cmd</code> field is invalid.</p></dd><dt><span class="ERRORCODE">EPERM</span></dt><dd><p>The application sent a PAUSE or RESUME command when
the encoder was not running.</p></dd></dl></div></div><h1><a name="VIDIOC-ENUMAUDIO"></a>ioctl VIDIOC_ENUMAUDIO</h1><div class="REFNAMEDIV"><a name="AEN8246"></a><h2>Name</h2>VIDIOC_ENUMAUDIO&nbsp;--&nbsp;Enumerate audio inputs</div><div class="REFSYNOPSISDIV"><a name="AEN8249"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN8250"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_audio *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN8260"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_ENUMAUDIO</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN8280"></a><h2>Description</h2><p>To query the attributes of an audio input applications
initialize the <code class="STRUCTFIELD">index</code> field and zero out the
<code class="STRUCTFIELD">reserved</code> array of a struct&nbsp;<a href="#V4L2-AUDIO">v4l2_audio</a>
and call the <code class="CONSTANT">VIDIOC_ENUMAUDIO</code> ioctl with a pointer
to this structure. Drivers fill the rest of the structure or return an
<span class="ERRORCODE">EINVAL</span> error code when the index is out of bounds. To enumerate all audio
inputs applications shall begin at index zero, incrementing by one
until the driver returns <span class="ERRORCODE">EINVAL</span>.</p><p>See <a href="#VIDIOC-G-AUDIO">ioctl VIDIOC_G_AUDIO, VIDIOC_S_AUDIO(2)</a> for a description of
struct&nbsp;<a href="#V4L2-AUDIO">v4l2_audio</a>.</p></div><div class="REFSECT1"><a name="AEN8292"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The number of the audio input is out of bounds, or
there are no audio inputs at all and this ioctl is not
supported.</p></dd></dl></div></div><h1><a name="VIDIOC-ENUMAUDIOOUT"></a>ioctl VIDIOC_ENUMAUDOUT</h1><div class="REFNAMEDIV"><a name="AEN8308"></a><h2>Name</h2>VIDIOC_ENUMAUDOUT&nbsp;--&nbsp;Enumerate audio outputs</div><div class="REFSYNOPSISDIV"><a name="AEN8311"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN8312"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_audioout *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN8322"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_ENUMAUDOUT</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN8342"></a><h2>Description</h2><p>To query the attributes of an audio output applications
initialize the <code class="STRUCTFIELD">index</code> field and zero out the
<code class="STRUCTFIELD">reserved</code> array of a struct&nbsp;<a href="#V4L2-AUDIOOUT">v4l2_audioout</a> and
call the <code class="CONSTANT">VIDIOC_G_AUDOUT</code> ioctl with a pointer
to this structure. Drivers fill the rest of the structure or return an
<span class="ERRORCODE">EINVAL</span> error code when the index is out of bounds. To enumerate all audio
outputs applications shall begin at index zero, incrementing by one
until the driver returns <span class="ERRORCODE">EINVAL</span>.</p><p>Note connectors on a TV card to loop back the received audio
signal to a sound card are not audio outputs in this sense.</p><p>See <a href="#VIDIOC-G-AUDIOOUT">ioctl VIDIOC_G_AUDOUT, VIDIOC_S_AUDOUT(2)</a> for a description of
struct&nbsp;<a href="#V4L2-AUDIOOUT">v4l2_audioout</a>.</p></div><div class="REFSECT1"><a name="AEN8355"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The number of the audio output is out of bounds, or
there are no audio outputs at all and this ioctl is not
supported.</p></dd></dl></div></div><h1><a name="VIDIOC-ENUM-FMT"></a>ioctl VIDIOC_ENUM_FMT</h1><div class="REFNAMEDIV"><a name="AEN8371"></a><h2>Name</h2>VIDIOC_ENUM_FMT&nbsp;--&nbsp;Enumerate image formats</div><div class="REFSYNOPSISDIV"><a name="AEN8374"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN8375"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_fmtdesc
*argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN8385"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_ENUM_FMT</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN8405"></a><h2>Description</h2><p>To enumerate image formats applications initialize the
<code class="STRUCTFIELD">type</code> and <code class="STRUCTFIELD">index</code>
field of struct&nbsp;<a href="#V4L2-FMTDESC">v4l2_fmtdesc</a> and call the
<code class="CONSTANT">VIDIOC_ENUM_FMT</code> ioctl with a pointer to this
structure. Drivers fill the rest of the structure or return an
<span class="ERRORCODE">EINVAL</span> error code. All formats are enumerable by beginning at index zero and
incrementing by one until <span class="ERRORCODE">EINVAL</span> is
returned.</p><div class="TABLE"><a name="V4L2-FMTDESC"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_fmtdesc</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">index</code></td><td>Number of the format in the enumeration, set by
the application. This is in no way related to the <code class="STRUCTFIELD">pixelformat</code> field.</td></tr><tr><td>enum&nbsp;<a href="#V4L2-BUF-TYPE">v4l2_buf_type</a></td><td><code class="STRUCTFIELD">type</code></td><td>Type of the data stream, set by the application.
Only these types are valid here:
<code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_CAPTURE</code>,
<code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_OUTPUT</code>,
<code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_OVERLAY</code>, and custom (driver
defined) types with code <code class="CONSTANT">V4L2_BUF_TYPE_PRIVATE</code>
and higher.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">flags</code></td><td>See <a href="#FMTDESC-FLAGS">Table 2</a></td></tr><tr><td>__u8</td><td><code class="STRUCTFIELD">description</code>[32]</td><td>Description of the format, a NUL-terminated ASCII
string. This information is intended for the user, for example: "YUV
4:2:2".</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">pixelformat</code></td><td>The image format identifier. This is a
four character code as computed by the v4l2_fourcc()
macro:</td></tr><tr><td colspan="3"><p></p><pre class="PROGRAMLISTING">#define v4l2_fourcc(a,b,c,d) (((__u32)(a)&lt;&lt;0)|((__u32)(b)&lt;&lt;8)|((__u32)(c)&lt;&lt;16)|((__u32)(d)&lt;&lt;24))</pre><p></p><p>Several image formats are already
defined by this specification in <a href="#PIXFMT">Chapter 2</a>. Note these
codes are not the same as those used in the Windows world.</p></td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code>[4]</td><td>Reserved for future extensions. Drivers must set
the array to zero.</td></tr></tbody></table></div><div class="TABLE"><a name="FMTDESC-FLAGS"></a><p><b>Table 2. Image Format Description Flags</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_FMT_FLAG_COMPRESSED</code></td><td>0x0001</td><td>This is a compressed format.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN8479"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The struct&nbsp;<a href="#V4L2-FMTDESC">v4l2_fmtdesc</a> <code class="STRUCTFIELD">type</code>
is not supported or the <code class="STRUCTFIELD">index</code> is out of
bounds.</p></dd></dl></div></div><h1><a name="VIDIOC-ENUM-FRAMESIZES"></a>ioctl VIDIOC_ENUM_FRAMESIZES</h1><div class="REFNAMEDIV"><a name="AEN8498"></a><h2>Name</h2>VIDIOC_ENUM_FRAMESIZES&nbsp;--&nbsp;Enumerate frame sizes</div><div class="REFSYNOPSISDIV"><a name="AEN8501"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN8502"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_frmsizeenum *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN8512"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_ENUM_FRAMESIZES</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p>Pointer to a struct&nbsp;<a href="#V4L2-FRMSIZEENUM">v4l2_frmsizeenum</a> that contains an index
and pixel format and receives a frame width and height.</p></dd></dl></div></div><div class="REFSECT1"><a name="AEN8533"></a><h2>Description</h2><div class="NOTE"><blockquote class="NOTE"><p><b>Experimental: </b>This is an <a href="#EXPERIMENTAL">experimental</a>
interface and may change in the future.</p></blockquote></div><p>This ioctl allows applications to enumerate all frame sizes
(i.&nbsp;e. width and height in pixels) that the device supports for the
given pixel format.</p><p>The supported pixel formats can be obtained by using the
<a href="#VIDIOC-ENUM-FMT"><code class="CONSTANT">VIDIOC_ENUM_FMT</code></a> function.</p><p>The return value and the content of the
<code class="STRUCTFIELD">v4l2_frmsizeenum.type</code> field depend on the
type of frame sizes the device supports. Here are the semantics of the
function for the different cases:</p><p></p><ul><li><p><span class="bold"><b class="EMPHASIS">Discrete:</b></span> The function
returns success if the given index value (zero-based) is valid. The
application should increase the index by one for each call until
<code class="CONSTANT">EINVAL</code> is returned. The
<code class="STRUCTFIELD">v4l2_frmsizeenum.type</code> field is set to
<code class="CONSTANT">V4L2_FRMSIZE_TYPE_DISCRETE</code> by the driver. Of the
union only the <code class="STRUCTFIELD">discrete</code> member is
valid.</p></li><li><p><span class="bold"><b class="EMPHASIS">Step-wise:</b></span> The function
returns success if the given index value is zero and
<code class="CONSTANT">EINVAL</code> for any other index value. The
<code class="STRUCTFIELD">v4l2_frmsizeenum.type</code> field is set to
<code class="CONSTANT">V4L2_FRMSIZE_TYPE_STEPWISE</code> by the driver. Of the
union only the <code class="STRUCTFIELD">stepwise</code> member is
valid.</p></li><li><p><span class="bold"><b class="EMPHASIS">Continuous:</b></span> This is a
special case of the step-wise type above. The function returns success
if the given index value is zero and <code class="CONSTANT">EINVAL</code> for
any other index value. The
<code class="STRUCTFIELD">v4l2_frmsizeenum.type</code> field is set to
<code class="CONSTANT">V4L2_FRMSIZE_TYPE_CONTINUOUS</code> by the driver. Of
the union only the <code class="STRUCTFIELD">stepwise</code> member is valid
and the <code class="STRUCTFIELD">step_width</code> and
<code class="STRUCTFIELD">step_height</code> values are set to 1.</p></li></ul><p>When the application calls the function with index zero, it
must check the <code class="STRUCTFIELD">type</code> field to determine the
type of frame size enumeration the device supports. Only for the
<code class="CONSTANT">V4L2_FRMSIZE_TYPE_DISCRETE</code> type does it make
sense to increase the index value to receive more frame sizes.</p><p>Note that the order in which the frame sizes are returned
has no special meaning. In particular does it not say anything about
potential default format sizes.</p><p>Applications can assume that the enumeration data does not
change without any interaction from the application itself. This means
that the enumeration data is consistent if the application does not
perform any other ioctl calls while it runs the frame size
enumeration.</p></div><div class="REFSECT1"><a name="AEN8574"></a><h2>Structs</h2><p>In the structs below, <span class="emphasis"><i class="EMPHASIS">IN</i></span> denotes a
value that has to be filled in by the application,
<span class="emphasis"><i class="EMPHASIS">OUT</i></span> denotes values that the driver fills in. The
application should zero out all members except for the
<span class="emphasis"><i class="EMPHASIS">IN</i></span> fields.</p><div class="TABLE"><a name="V4L2-FRMSIZE-DISCRETE"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_frmsize_discrete</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">width</code></td><td>Width of the frame [pixel].</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">height</code></td><td>Height of the frame [pixel].</td></tr></tbody></table></div><div class="TABLE"><a name="V4L2-FRMSIZE-STEPWISE"></a><p><b>Table 2. struct <code class="STRUCTNAME">v4l2_frmsize_stepwise</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">min_width</code></td><td>Minimum frame width [pixel].</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">max_width</code></td><td>Maximum frame width [pixel].</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">step_width</code></td><td>Frame width step size [pixel].</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">min_height</code></td><td>Minimum frame height [pixel].</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">max_height</code></td><td>Maximum frame height [pixel].</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">step_height</code></td><td>Frame height step size [pixel].</td></tr></tbody></table></div><div class="TABLE"><a name="V4L2-FRMSIZEENUM"></a><p><b>Table 3. struct <code class="STRUCTNAME">v4l2_frmsizeenum</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="25%"><col title="C4" width="25%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">index</code></td><td>&nbsp;</td><td>IN: Index of the given frame size in the enumeration.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">pixel_format</code></td><td>&nbsp;</td><td>IN: Pixel format for which the frame sizes are enumerated.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">type</code></td><td>&nbsp;</td><td>OUT: Frame size type the device supports.</td></tr><tr><td>union</td><td>&nbsp;</td><td>&nbsp;</td><td>OUT: Frame size with the given index.</td></tr><tr><td>&nbsp;</td><td>struct&nbsp;<a href="#V4L2-FRMSIZE-DISCRETE">v4l2_frmsize_discrete</a></td><td><code class="STRUCTFIELD">discrete</code></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td>struct&nbsp;<a href="#V4L2-FRMSIZE-STEPWISE">v4l2_frmsize_stepwise</a></td><td><code class="STRUCTFIELD">stepwise</code></td><td>&nbsp;</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved[2]</code></td><td>&nbsp;</td><td>Reserved space for future use.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN8690"></a><h2>Enums</h2><div class="TABLE"><a name="V4L2-FRMSIZETYPES"></a><p><b>Table 4. enum <code class="STRUCTNAME">v4l2_frmsizetypes</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_FRMSIZE_TYPE_DISCRETE</code></td><td>1</td><td>Discrete frame size.</td></tr><tr><td><code class="CONSTANT">V4L2_FRMSIZE_TYPE_CONTINUOUS</code></td><td>2</td><td>Continuous frame size.</td></tr><tr><td><code class="CONSTANT">V4L2_FRMSIZE_TYPE_STEPWISE</code></td><td>3</td><td>Step-wise defined frame size.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN8716"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p>See the description section above for a list of return
values that <code class="VARNAME">errno</code> can have.</p></div><h1><a name="VIDIOC-ENUM-FRAMEINTERVALS"></a>ioctl VIDIOC_ENUM_FRAMEINTERVALS</h1><div class="REFNAMEDIV"><a name="AEN8728"></a><h2>Name</h2>VIDIOC_ENUM_FRAMEINTERVALS&nbsp;--&nbsp;Enumerate frame intervals</div><div class="REFSYNOPSISDIV"><a name="AEN8731"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN8732"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_frmivalenum *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN8742"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_ENUM_FRAMEINTERVALS</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p>Pointer to a struct&nbsp;<a href="#V4L2-FRMIVALENUM">v4l2_frmivalenum</a> structure that
contains a pixel format and size and receives a frame interval.</p></dd></dl></div></div><div class="REFSECT1"><a name="AEN8763"></a><h2>Description</h2><p>This ioctl allows applications to enumerate all frame
intervals that the device supports for the given pixel format and
frame size.</p><p>The supported pixel formats and frame sizes can be obtained
by using the <a href="#VIDIOC-ENUM-FMT"><code class="CONSTANT">VIDIOC_ENUM_FMT</code></a> and <a href="#VIDIOC-ENUM-FRAMESIZES"><code class="CONSTANT">VIDIOC_ENUM_FRAMESIZES</code></a>
functions.</p><p>The return value and the content of the
<code class="STRUCTFIELD">v4l2_frmivalenum.type</code> field depend on the
type of frame intervals the device supports. Here are the semantics of
the function for the different cases:</p><p></p><ul><li><p><span class="bold"><b class="EMPHASIS">Discrete:</b></span> The function
returns success if the given index value (zero-based) is valid. The
application should increase the index by one for each call until
<code class="CONSTANT">EINVAL</code> is returned. The `v4l2_frmivalenum.type`
field is set to `V4L2_FRMIVAL_TYPE_DISCRETE` by the driver. Of the
union only the `discrete` member is valid.</p></li><li><p><span class="bold"><b class="EMPHASIS">Step-wise:</b></span> The function
returns success if the given index value is zero and
<code class="CONSTANT">EINVAL</code> for any other index value. The
<code class="STRUCTFIELD">v4l2_frmivalenum.type</code> field is set to
<code class="CONSTANT">V4L2_FRMIVAL_TYPE_STEPWISE</code> by the driver. Of the
union only the <code class="STRUCTFIELD">stepwise</code> member is
valid.</p></li><li><p><span class="bold"><b class="EMPHASIS">Continuous:</b></span> This is a
special case of the step-wise type above. The function returns success
if the given index value is zero and <code class="CONSTANT">EINVAL</code> for
any other index value. The
<code class="STRUCTFIELD">v4l2_frmivalenum.type</code> field is set to
<code class="CONSTANT">V4L2_FRMIVAL_TYPE_CONTINUOUS</code> by the driver. Of
the union only the <code class="STRUCTFIELD">stepwise</code> member is valid
and the <code class="STRUCTFIELD">step</code> value is set to 1.</p></li></ul><p>When the application calls the function with index zero, it
must check the <code class="STRUCTFIELD">type</code> field to determine the
type of frame interval enumeration the device supports. Only for the
<code class="CONSTANT">V4L2_FRMIVAL_TYPE_DISCRETE</code> type does it make
sense to increase the index value to receive more frame
intervals.</p><p>Note that the order in which the frame intervals are
returned has no special meaning. In particular does it not say
anything about potential default frame intervals.</p><p>Applications can assume that the enumeration data does not
change without any interaction from the application itself. This means
that the enumeration data is consistent if the application does not
perform any other ioctl calls while it runs the frame interval
enumeration.</p></div><div class="REFSECT1"><a name="AEN8798"></a><h2>Notes</h2><p></p><ul><li><p><span class="bold"><b class="EMPHASIS">Frame intervals and frame
rates:</b></span> The V4L2 API uses frame intervals instead of frame
rates. Given the frame interval the frame rate can be computed as
follows:</p><pre class="SCREEN">frame_rate = 1 / frame_interval</pre><p></p></li></ul></div><div class="REFSECT1"><a name="AEN8805"></a><h2>Structs</h2><p>In the structs below, <span class="emphasis"><i class="EMPHASIS">IN</i></span> denotes a
value that has to be filled in by the application,
<span class="emphasis"><i class="EMPHASIS">OUT</i></span> denotes values that the driver fills in. The
application should zero out all members except for the
<span class="emphasis"><i class="EMPHASIS">IN</i></span> fields.</p><div class="TABLE"><a name="V4L2-FRMIVAL-STEPWISE"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_frmival_stepwise</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>struct&nbsp;<a href="#V4L2-FRACT">v4l2_fract</a></td><td><code class="STRUCTFIELD">min</code></td><td>Minimum frame interval [s].</td></tr><tr><td>struct&nbsp;<a href="#V4L2-FRACT">v4l2_fract</a></td><td><code class="STRUCTFIELD">max</code></td><td>Maximum frame interval [s].</td></tr><tr><td>struct&nbsp;<a href="#V4L2-FRACT">v4l2_fract</a></td><td><code class="STRUCTFIELD">step</code></td><td>Frame interval step size [s].</td></tr></tbody></table></div><div class="TABLE"><a name="V4L2-FRMIVALENUM"></a><p><b>Table 2. struct <code class="STRUCTNAME">v4l2_frmivalenum</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="25%"><col title="C4" width="25%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">index</code></td><td>&nbsp;</td><td>IN: Index of the given frame interval in the
enumeration.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">pixel_format</code></td><td>&nbsp;</td><td>IN: Pixel format for which the frame intervals are
enumerated.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">width</code></td><td>&nbsp;</td><td>IN: Frame width for which the frame intervals are
enumerated.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">height</code></td><td>&nbsp;</td><td>IN: Frame height for which the frame intervals are
enumerated.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">type</code></td><td>&nbsp;</td><td>OUT: Frame interval type the device supports.</td></tr><tr><td>union</td><td>&nbsp;</td><td>&nbsp;</td><td>OUT: Frame interval with the given index.</td></tr><tr><td>&nbsp;</td><td>struct&nbsp;<a href="#V4L2-FRACT">v4l2_fract</a></td><td><code class="STRUCTFIELD">discrete</code></td><td>Frame interval [s].</td></tr><tr><td>&nbsp;</td><td>struct&nbsp;<a href="#V4L2-FRMIVAL-STEPWISE">v4l2_frmival_stepwise</a></td><td><code class="STRUCTFIELD">stepwise</code></td><td>&nbsp;</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved[2]</code></td><td>&nbsp;</td><td>Reserved space for future use.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN8902"></a><h2>Enums</h2><div class="TABLE"><a name="V4L2-FRMIVALTYPES"></a><p><b>Table 3. enum <code class="STRUCTNAME">v4l2_frmivaltypes</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_FRMIVAL_TYPE_DISCRETE</code></td><td>1</td><td>Discrete frame interval.</td></tr><tr><td><code class="CONSTANT">V4L2_FRMIVAL_TYPE_CONTINUOUS</code></td><td>2</td><td>Continuous frame interval.</td></tr><tr><td><code class="CONSTANT">V4L2_FRMIVAL_TYPE_STEPWISE</code></td><td>3</td><td>Step-wise defined frame interval.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN8928"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p>See the description section above for a list of return
values that <code class="VARNAME">errno</code> can have.</p></div><h1><a name="VIDIOC-ENUMINPUT"></a>ioctl VIDIOC_ENUMINPUT</h1><div class="REFNAMEDIV"><a name="AEN8940"></a><h2>Name</h2>VIDIOC_ENUMINPUT&nbsp;--&nbsp;Enumerate video inputs</div><div class="REFSYNOPSISDIV"><a name="AEN8943"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN8944"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_input
*argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN8954"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_ENUMINPUT</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN8974"></a><h2>Description</h2><p>To query the attributes of a video input applications
initialize the <code class="STRUCTFIELD">index</code> field of struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a>
and call the <code class="CONSTANT">VIDIOC_ENUMINPUT</code> ioctl with a
pointer to this structure. Drivers fill the rest of the structure or
return an <span class="ERRORCODE">EINVAL</span> error code when the index is out of bounds. To enumerate all
inputs applications shall begin at index zero, incrementing by one
until the driver returns <span class="ERRORCODE">EINVAL</span>.</p><div class="TABLE"><a name="V4L2-INPUT"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_input</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">index</code></td><td>Identifies the input, set by the
application.</td></tr><tr><td>__u8</td><td><code class="STRUCTFIELD">name</code>[32]</td><td>Name of the video input, a NUL-terminated ASCII
string, for example: "Vin (Composite 2)". This information is intended
for the user, preferably the connector label on the device itself.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">type</code></td><td>Type of the input, see <a href="#INPUT-TYPE">Table 2</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">audioset</code></td><td><p>Drivers can enumerate up to 32 video and
audio inputs. This field shows which audio inputs were selectable as
audio source if this was the currently selected video input. It is a
bit mask. The LSB corresponds to audio input 0, the MSB to input 31.
Any number of bits can be set, or none.</p><p>When the driver
does not enumerate audio inputs no bits must be set. Applications
shall not interpret this as lack of audio support. Some drivers
automatically select audio sources and do not enumerate them since
there is no choice anyway.</p><p>For details on audio inputs and
how to select the current input see <a href="#AUDIO">Section 1.5</a>.</p></td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">tuner</code></td><td>Capture devices can have zero or more tuners (RF
demodulators). When the <code class="STRUCTFIELD">type</code> is set to
<code class="CONSTANT">V4L2_INPUT_TYPE_TUNER</code> this is an RF connector and
this field identifies the tuner. It corresponds to
struct&nbsp;<a href="#V4L2-TUNER">v4l2_tuner</a> field <code class="STRUCTFIELD">index</code>. For details on
tuners see <a href="#TUNER">Section 1.6</a>.</td></tr><tr><td><a href="#V4L2-STD-ID">v4l2_std_id</a></td><td><code class="STRUCTFIELD">std</code></td><td>Every video input supports one or more different
video standards. This field is a set of all supported standards. For
details on video standards and how to switch see <a href="#STANDARD">Section 1.7</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">status</code></td><td>This field provides status information about the
input. See <a href="#INPUT-STATUS">Table 3</a> for flags.
<code class="STRUCTFIELD">status</code> is only valid when this is the
current input.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code>[4]</td><td>Reserved for future extensions. Drivers must set
the array to zero.</td></tr></tbody></table></div><div class="TABLE"><a name="INPUT-TYPE"></a><p><b>Table 2. Input Types</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_INPUT_TYPE_TUNER</code></td><td>1</td><td>This input uses a tuner (RF demodulator).</td></tr><tr><td><code class="CONSTANT">V4L2_INPUT_TYPE_CAMERA</code></td><td>2</td><td>Analog baseband input, for example CVBS /
Composite Video, S-Video, RGB.</td></tr></tbody></table></div><div class="TABLE"><a name="INPUT-STATUS"></a><p><b>Table 3. Input Status Flags</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="33%"><col title="C2" align="CENTER" width="33%"><col title="C3" width="33%"></colgroup><tbody valign="TOP"><tr><td colspan="3" align="LEFT">General</td></tr><tr><td><code class="CONSTANT">V4L2_IN_ST_NO_POWER</code></td><td>0x00000001</td><td>Attached device is off.</td></tr><tr><td><code class="CONSTANT">V4L2_IN_ST_NO_SIGNAL</code></td><td>0x00000002</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_IN_ST_NO_COLOR</code></td><td>0x00000004</td><td>The hardware supports color decoding, but does not
detect color modulation in the signal.</td></tr><tr><td colspan="3" align="LEFT">Analog Video</td></tr><tr><td><code class="CONSTANT">V4L2_IN_ST_NO_H_LOCK</code></td><td>0x00000100</td><td>No horizontal sync lock.</td></tr><tr><td><code class="CONSTANT">V4L2_IN_ST_COLOR_KILL</code></td><td>0x00000200</td><td>A color killer circuit automatically disables color
decoding when it detects no color modulation. When this flag is set
the color killer is enabled <span class="emphasis"><i class="EMPHASIS">and</i></span> has shut off
color decoding.</td></tr><tr><td colspan="3" align="LEFT">Digital Video</td></tr><tr><td><code class="CONSTANT">V4L2_IN_ST_NO_SYNC</code></td><td>0x00010000</td><td>No synchronization lock.</td></tr><tr><td><code class="CONSTANT">V4L2_IN_ST_NO_EQU</code></td><td>0x00020000</td><td>No equalizer lock.</td></tr><tr><td><code class="CONSTANT">V4L2_IN_ST_NO_CARRIER</code></td><td>0x00040000</td><td>Carrier recovery failed.</td></tr><tr><td colspan="3" align="LEFT">VCR and Set-Top Box</td></tr><tr><td><code class="CONSTANT">V4L2_IN_ST_MACROVISION</code></td><td>0x01000000</td><td>Macrovision is an analog copy prevention system
mangling the video signal to confuse video recorders. When this
flag is set Macrovision has been detected.</td></tr><tr><td><code class="CONSTANT">V4L2_IN_ST_NO_ACCESS</code></td><td>0x02000000</td><td>Conditional access denied.</td></tr><tr><td><code class="CONSTANT">V4L2_IN_ST_VTR</code></td><td>0x04000000</td><td>VTR time constant. [?]</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN9135"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a> <code class="STRUCTFIELD">index</code> is
out of bounds.</p></dd></dl></div></div><h1><a name="VIDIOC-ENUMOUTPUT"></a>ioctl VIDIOC_ENUMOUTPUT</h1><div class="REFNAMEDIV"><a name="AEN9153"></a><h2>Name</h2>VIDIOC_ENUMOUTPUT&nbsp;--&nbsp;Enumerate video outputs</div><div class="REFSYNOPSISDIV"><a name="AEN9156"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN9157"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_output *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN9167"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_ENUMOUTPUT</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN9187"></a><h2>Description</h2><p>To query the attributes of a video outputs applications
initialize the <code class="STRUCTFIELD">index</code> field of struct&nbsp;<a href="#V4L2-OUTPUT">v4l2_output</a>
and call the <code class="CONSTANT">VIDIOC_ENUMOUTPUT</code> ioctl with a
pointer to this structure. Drivers fill the rest of the structure or
return an <span class="ERRORCODE">EINVAL</span> error code when the index is out of bounds. To enumerate all
outputs applications shall begin at index zero, incrementing by one
until the driver returns <span class="ERRORCODE">EINVAL</span>.</p><div class="TABLE"><a name="V4L2-OUTPUT"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_output</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">index</code></td><td>Identifies the output, set by the
application.</td></tr><tr><td>__u8</td><td><code class="STRUCTFIELD">name</code>[32]</td><td>Name of the video output, a NUL-terminated ASCII
string, for example: "Vout". This information is intended for the
user, preferably the connector label on the device itself.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">type</code></td><td>Type of the output, see <a href="#OUTPUT-TYPE">Table 2</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">audioset</code></td><td><p>Drivers can enumerate up to 32 video and
audio outputs. This field shows which audio outputs were
selectable as the current output if this was the currently selected
video output. It is a bit mask. The LSB corresponds to audio output 0,
the MSB to output 31. Any number of bits can be set, or
none.</p><p>When the driver does not enumerate audio outputs no
bits must be set. Applications shall not interpret this as lack of
audio support. Drivers may automatically select audio outputs without
enumerating them.</p><p>For details on audio outputs and how to
select the current output see <a href="#AUDIO">Section 1.5</a>.</p></td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">modulator</code></td><td>Output devices can have zero or more RF modulators.
When the <code class="STRUCTFIELD">type</code> is
<code class="CONSTANT">V4L2_OUTPUT_TYPE_MODULATOR</code> this is an RF
connector and this field identifies the modulator. It corresponds to
struct&nbsp;<a href="#V4L2-MODULATOR">v4l2_modulator</a> field <code class="STRUCTFIELD">index</code>. For details
on modulators see <a href="#TUNER">Section 1.6</a>.</td></tr><tr><td><a href="#V4L2-STD-ID">v4l2_std_id</a></td><td><code class="STRUCTFIELD">std</code></td><td>Every video output supports one or more different
video standards. This field is a set of all supported standards. For
details on video standards and how to switch see <a href="#STANDARD">Section 1.7</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code>[4]</td><td>Reserved for future extensions. Drivers must set
the array to zero.</td></tr></tbody></table></div><div class="TABLE"><a name="OUTPUT-TYPE"></a><p><b>Table 2. Output Type</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_OUTPUT_TYPE_MODULATOR</code></td><td>1</td><td>This output is an analog TV modulator.</td></tr><tr><td><code class="CONSTANT">V4L2_OUTPUT_TYPE_ANALOG</code></td><td>2</td><td>Analog baseband output, for example Composite /
CVBS, S-Video, RGB.</td></tr><tr><td><code class="CONSTANT">V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY</code></td><td>3</td><td>[?]</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN9274"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The struct&nbsp;<a href="#V4L2-OUTPUT">v4l2_output</a> <code class="STRUCTFIELD">index</code>
is out of bounds.</p></dd></dl></div></div><h1><a name="VIDIOC-ENUMSTD"></a>ioctl VIDIOC_ENUMSTD</h1><div class="REFNAMEDIV"><a name="AEN9292"></a><h2>Name</h2>VIDIOC_ENUMSTD&nbsp;--&nbsp;Enumerate supported video standards</div><div class="REFSYNOPSISDIV"><a name="AEN9295"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN9296"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_standard *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN9306"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_ENUMSTD</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN9326"></a><h2>Description</h2><p>To query the attributes of a video standard,
especially a custom (driver defined) one, applications initialize the
<code class="STRUCTFIELD">index</code> field of struct&nbsp;<a href="#V4L2-STANDARD">v4l2_standard</a> and call the
<code class="CONSTANT">VIDIOC_ENUMSTD</code> ioctl with a pointer to this
structure. Drivers fill the rest of the structure or return an
<span class="ERRORCODE">EINVAL</span> error code when the index is out of bounds. To enumerate all standards
applications shall begin  at index zero, incrementing by one until the
driver returns <span class="ERRORCODE">EINVAL</span>. Drivers may enumerate a
different set of standards after switching the video input or
output.<a name="AEN9334" href="#FTN.AEN9334"><span class="footnote">[23]</span></a></p><div class="TABLE"><a name="V4L2-STANDARD"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_standard</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">index</code></td><td>Number of the video standard, set by the
application.</td></tr><tr><td><a href="#V4L2-STD-ID">v4l2_std_id</a></td><td><code class="STRUCTFIELD">id</code></td><td>The bits in this field identify the standard as
one of the common standards listed in <a href="#V4L2-STD-ID">Table 3</a>,
or if bits 32 to 63 are set as custom standards. Multiple bits can be
set if the hardware does not distinguish between these standards,
however separate indices do not indicate the opposite. The
<code class="STRUCTFIELD">id</code> must be unique. No other enumerated
<code class="STRUCTNAME">v4l2_standard</code> structure, for this input or
output anyway, can contain the same set of bits.</td></tr><tr><td>__u8</td><td><code class="STRUCTFIELD">name</code>[24]</td><td>Name of the standard, a NUL-terminated ASCII
string, for example: "PAL-B/G", "NTSC Japan". This information is
intended for the user.</td></tr><tr><td>struct&nbsp;<a href="#V4L2-FRACT">v4l2_fract</a></td><td><code class="STRUCTFIELD">frameperiod</code></td><td>The frame period (not field period) is numerator
/ denominator. For example M/NTSC has a frame period of 1001 /
30000 seconds.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">framelines</code></td><td>Total lines per frame including blanking,
e.&nbsp;g. 625 for B/PAL.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code>[4]</td><td>Reserved for future extensions. Drivers must set
the array to zero.</td></tr></tbody></table></div><div class="TABLE"><a name="V4L2-FRACT"></a><p><b>Table 2. struct <code class="STRUCTNAME">v4l2_fract</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">numerator</code></td><td>&nbsp;</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">denominator</code></td><td>&nbsp;</td></tr></tbody></table></div><div class="TABLE"><a name="V4L2-STD-ID"></a><p><b>Table 3. typedef <code class="STRUCTNAME">v4l2_std_id</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u64</td><td><code class="STRUCTFIELD">v4l2_std_id</code></td><td>This type is a set, each bit representing another
video standard as listed below and in <a href="#VIDEO-STANDARDS">Table 4</a>. The 32 most significant bits are reserved
for custom (driver defined) video standards.</td></tr></tbody></table></div><p></p><pre class="PROGRAMLISTING">#define V4L2_STD_PAL_B          ((v4l2_std_id)0x00000001)
#define V4L2_STD_PAL_B1         ((v4l2_std_id)0x00000002)
#define V4L2_STD_PAL_G          ((v4l2_std_id)0x00000004)
#define V4L2_STD_PAL_H          ((v4l2_std_id)0x00000008)
#define V4L2_STD_PAL_I          ((v4l2_std_id)0x00000010)
#define V4L2_STD_PAL_D          ((v4l2_std_id)0x00000020)
#define V4L2_STD_PAL_D1         ((v4l2_std_id)0x00000040)
#define V4L2_STD_PAL_K          ((v4l2_std_id)0x00000080)

#define V4L2_STD_PAL_M          ((v4l2_std_id)0x00000100)
#define V4L2_STD_PAL_N          ((v4l2_std_id)0x00000200)
#define V4L2_STD_PAL_Nc         ((v4l2_std_id)0x00000400)
#define V4L2_STD_PAL_60         ((v4l2_std_id)0x00000800)</pre><p></p><p><code class="CONSTANT">V4L2_STD_PAL_60</code> is
a hybrid standard with 525 lines, 60 Hz refresh rate, and PAL color
modulation with a 4.43 MHz color subcarrier. Some PAL video recorders
can play back NTSC tapes in this mode for display on a 50/60 Hz agnostic
PAL TV.</p><p></p><pre class="PROGRAMLISTING">#define V4L2_STD_NTSC_M         ((v4l2_std_id)0x00001000)
#define V4L2_STD_NTSC_M_JP      ((v4l2_std_id)0x00002000)
#define V4L2_STD_NTSC_443       ((v4l2_std_id)0x00004000)</pre><p></p><p><code class="CONSTANT">V4L2_STD_NTSC_443</code>
is a hybrid standard with 525 lines, 60 Hz refresh rate, and NTSC
color modulation with a 4.43 MHz color
subcarrier.</p><p></p><pre class="PROGRAMLISTING">#define V4L2_STD_NTSC_M_KR      ((v4l2_std_id)0x00008000)

#define V4L2_STD_SECAM_B        ((v4l2_std_id)0x00010000)
#define V4L2_STD_SECAM_D        ((v4l2_std_id)0x00020000)
#define V4L2_STD_SECAM_G        ((v4l2_std_id)0x00040000)
#define V4L2_STD_SECAM_H        ((v4l2_std_id)0x00080000)
#define V4L2_STD_SECAM_K        ((v4l2_std_id)0x00100000)
#define V4L2_STD_SECAM_K1       ((v4l2_std_id)0x00200000)
#define V4L2_STD_SECAM_L        ((v4l2_std_id)0x00400000)
#define V4L2_STD_SECAM_LC       ((v4l2_std_id)0x00800000)

/* ATSC/HDTV */
#define V4L2_STD_ATSC_8_VSB     ((v4l2_std_id)0x01000000)
#define V4L2_STD_ATSC_16_VSB    ((v4l2_std_id)0x02000000)</pre><p></p><p><code class="CONSTANT">V4L2_STD_ATSC_8_VSB</code> and
<code class="CONSTANT">V4L2_STD_ATSC_16_VSB</code> are U.S. terrestrial digital
TV standards. Presently the V4L2 API does not support digital TV. See
also the Linux DVB API at <a href="http://linuxtv.org/" target="_top">http://linuxtv.org</a>.</p><p></p><pre class="PROGRAMLISTING">#define V4L2_STD_PAL_BG         (V4L2_STD_PAL_B         |\
                                 V4L2_STD_PAL_B1        |\
                                 V4L2_STD_PAL_G)
#define V4L2_STD_B              (V4L2_STD_PAL_B         |\
                                 V4L2_STD_PAL_B1        |\
                                 V4L2_STD_SECAM_B)
#define V4L2_STD_GH             (V4L2_STD_PAL_G         |\
                                 V4L2_STD_PAL_H         |\
                                 V4L2_STD_SECAM_G       |\
                                 V4L2_STD_SECAM_H)
#define V4L2_STD_PAL_DK         (V4L2_STD_PAL_D         |\
                                 V4L2_STD_PAL_D1        |\
                                 V4L2_STD_PAL_K)
#define V4L2_STD_PAL            (V4L2_STD_PAL_BG        |\
                                 V4L2_STD_PAL_DK        |\
                                 V4L2_STD_PAL_H         |\
                                 V4L2_STD_PAL_I)
#define V4L2_STD_NTSC           (V4L2_STD_NTSC_M        |\
                                 V4L2_STD_NTSC_M_JP     |\
                                 V4L2_STD_NTSC_M_KR)
#define V4L2_STD_MN             (V4L2_STD_PAL_M         |\
                                 V4L2_STD_PAL_N         |\
                                 V4L2_STD_PAL_Nc        |\
                                 V4L2_STD_NTSC)
#define V4L2_STD_SECAM_DK       (V4L2_STD_SECAM_D       |\
                                 V4L2_STD_SECAM_K       |\
                                 V4L2_STD_SECAM_K1)
#define V4L2_STD_DK             (V4L2_STD_PAL_DK        |\
                                 V4L2_STD_SECAM_DK)

#define V4L2_STD_SECAM          (V4L2_STD_SECAM_B       |\
                                 V4L2_STD_SECAM_G       |\
                                 V4L2_STD_SECAM_H       |\
                                 V4L2_STD_SECAM_DK      |\
                                 V4L2_STD_SECAM_L       |\
                                 V4L2_STD_SECAM_LC)

#define V4L2_STD_525_60         (V4L2_STD_PAL_M         |\
                                 V4L2_STD_PAL_60        |\
                                 V4L2_STD_NTSC          |\
                                 V4L2_STD_NTSC_443)
#define V4L2_STD_625_50         (V4L2_STD_PAL           |\
                                 V4L2_STD_PAL_N         |\
                                 V4L2_STD_PAL_Nc        |\
                                 V4L2_STD_SECAM)

#define V4L2_STD_UNKNOWN        0
#define V4L2_STD_ALL            (V4L2_STD_525_60        |\
                                 V4L2_STD_625_50)</pre><p></p><div class="TABLE"><a name="VIDEO-STANDARDS"></a><p><b>Table 4. Video Standards (based on [<a href="#ITU470"><abbr class="ABBREV">ITU&nbsp;BT.470</abbr></a>])</b></p><table rules="all" class="CALSTABLE" border="1" width="100%"><colgroup><col title="C1" align="LEFT" width="12%"><col title="C2" width="12%"><col title="C3" width="12%"><col title="C4" width="12%"><col title="C5" width="12%"><col><col title="C7" width="12%"><col><col title="C9" width="12%"><col><col><col title="C12" width="12%"></colgroup><thead><tr><th>Characteristics</th><th><p>M/NTSC<sup>a</sup></p></th><th>M/PAL</th><th><p>N/PAL<sup>b</sup></p></th><th align="CENTER">B, B1, G/PAL</th><th align="CENTER">D, D1, K/PAL</th><th align="CENTER">H/PAL</th><th align="CENTER">I/PAL</th><th align="CENTER">B, G/SECAM</th><th align="CENTER">D, K/SECAM</th><th align="CENTER">K1/SECAM</th><th align="CENTER">L/SECAM</th></tr></thead><tbody valign="TOP"><tr><td>Frame lines</td><td colspan="2" align="CENTER">525</td><td colspan="9" align="CENTER">625</td></tr><tr><td>Frame period (s)</td><td colspan="2" align="CENTER">1001/30000</td><td colspan="9" align="CENTER">1/25</td></tr><tr><td>Chrominance sub-carrier frequency (Hz)</td><td>3579545 ¡À&nbsp;10</td><td>3579611.49 ¡À&nbsp;10</td><td>4433618.75 ¡À&nbsp;5 (3582056.25
¡À&nbsp;5)</td><td colspan="3" align="CENTER">4433618.75 ¡À&nbsp;5</td><td>4433618.75 ¡À&nbsp;1</td><td colspan="4" align="CENTER">f<sub>OR</sub>&nbsp;=
4406250 ¡À&nbsp;2000, f<sub>OB</sub>&nbsp;= 4250000
¡À&nbsp;2000</td></tr><tr><td>Nominal radio-frequency channel bandwidth
(MHz)</td><td>6</td><td>6</td><td>6</td><td>B: 7; B1, G: 8</td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td></tr><tr><td>Sound carrier relative to vision carrier
(MHz)</td><td>+&nbsp;4.5</td><td>+&nbsp;4.5</td><td>+&nbsp;4.5</td><td><p>+&nbsp;5.5 ¡À&nbsp;0.001
<sup>c</sup> <sup>d</sup> <sup>e</sup> <sup>f</sup></p></td><td>+&nbsp;6.5 ¡À&nbsp;0.001</td><td>+&nbsp;5.5</td><td>+&nbsp;5.9996 ¡À&nbsp;0.0005</td><td>+&nbsp;5.5 ¡À&nbsp;0.001</td><td>+&nbsp;6.5 ¡À&nbsp;0.001</td><td>+&nbsp;6.5</td><td><p>+&nbsp;6.5 <sup>g</sup></p></td></tr></tbody><tbody><tr><td colspan="12">Notes:<br><a name="FTN.AEN9452">a. </a>Japan uses a standard
similar to M/NTSC
(V4L2_STD_NTSC_M_JP).<br><a name="FTN.AEN9457">b. </a> The values in
brackets apply to the combination N/PAL a.k.a.
N<sub>C</sub> used in Argentina
(V4L2_STD_PAL_Nc).<br><a name="FTN.AEN9507">c. </a>In the Federal Republic of Germany, Austria, Italy,
the Netherlands, Slovakia and Switzerland a system of two sound
carriers is used, the frequency of the second carrier being
242.1875&nbsp;kHz above the frequency of the first sound carrier. For
stereophonic sound transmissions a similar system is used in
Australia.<br><a name="FTN.AEN9509">d. </a>New Zealand uses a sound
carrier displaced 5.4996 ¡À&nbsp;0.0005 MHz from the vision
carrier.<br><a name="FTN.AEN9511">e. </a>In Denmark, Finland, New
Zealand, Sweden and Spain a system of two sound carriers is used. In
Iceland, Norway and Poland the same system is being introduced. The
second carrier is 5.85&nbsp;MHz above the vision carrier and is DQPSK
modulated with 728&nbsp;kbit/s sound and data multiplex. (NICAM
system)<br><a name="FTN.AEN9513">f. </a>In the United Kingdom, a
system of two sound carriers is used. The second sound carrier is
6.552&nbsp;MHz above the vision carrier and is DQPSK modulated with a
728&nbsp;kbit/s sound and data multiplex able to carry two sound
channels. (NICAM system)<br><a name="FTN.AEN9523">g. </a>In France, a
digital carrier 5.85 MHz away from the vision carrier may be used in
addition to the main sound carrier. It is modulated in differentially
encoded QPSK with a 728 kbit/s sound and data multiplexer capable of
carrying two sound channels. (NICAM
system)<br></td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN9525"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The struct&nbsp;<a href="#V4L2-STANDARD">v4l2_standard</a> <code class="STRUCTFIELD">index</code>
is out of bounds.</p></dd></dl></div></div><h1><a name="VIDIOC-G-AUDIO"></a>ioctl VIDIOC_G_AUDIO, VIDIOC_S_AUDIO</h1><div class="REFNAMEDIV"><a name="AEN9543"></a><h2>Name</h2>VIDIOC_G_AUDIO, VIDIOC_S_AUDIO&nbsp;--&nbsp;Query or select the current audio input and its
attributes</div><div class="REFSYNOPSISDIV"><a name="AEN9547"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN9548"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_audio *argp);</code></p><p></p></div><div class="FUNCSYNOPSIS"><p></p><a name="AEN9558"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, const struct v4l2_audio *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN9568"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_G_AUDIO, VIDIOC_S_AUDIO</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN9588"></a><h2>Description</h2><p>To query the current audio input applications zero out the
<code class="STRUCTFIELD">reserved</code> array of a struct&nbsp;<a href="#V4L2-AUDIO">v4l2_audio</a>
and call the <code class="CONSTANT">VIDIOC_G_AUDIO</code> ioctl with a pointer
to this structure. Drivers fill the rest of the structure or return an
<span class="ERRORCODE">EINVAL</span> error code when the device has no audio inputs, or none which combine
with the current video input.</p><p>Audio inputs have one writable property, the audio mode. To
select the current audio input <span class="emphasis"><i class="EMPHASIS">and</i></span> change the
audio mode, applications initialize the
<code class="STRUCTFIELD">index</code> and <code class="STRUCTFIELD">mode</code>
fields, and the
<code class="STRUCTFIELD">reserved</code> array of a
<code class="STRUCTNAME">v4l2_audio</code> structure and call the
<code class="CONSTANT">VIDIOC_S_AUDIO</code> ioctl. Drivers may switch to a
different audio mode if the request cannot be satisfied. However, this
is a write-only ioctl, it does not return the actual new audio
mode.</p><div class="TABLE"><a name="V4L2-AUDIO"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_audio</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">index</code></td><td>Identifies the audio input, set by the
driver or application.</td></tr><tr><td>__u8</td><td><code class="STRUCTFIELD">name</code>[32]</td><td>Name of the audio input, a NUL-terminated ASCII
string, for example: "Line In". This information is intended for the
user, preferably the connector label on the device itself.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">capability</code></td><td>Audio capability flags, see <a href="#AUDIO-CAPABILITY">Table 2</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">mode</code></td><td>Audio mode flags set by drivers and applications (on
            <code class="CONSTANT">VIDIOC_S_AUDIO</code> ioctl), see <a href="#AUDIO-MODE">Table 3</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code>[2]</td><td>Reserved for future extensions. Drivers and
applications must set the array to zero.</td></tr></tbody></table></div><div class="TABLE"><a name="AUDIO-CAPABILITY"></a><p><b>Table 2. Audio Capability Flags</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_AUDCAP_STEREO</code></td><td>0x00001</td><td>This is a stereo input. The flag is intended to
automatically disable stereo recording etc. when the signal is always
monaural. The API provides no means to detect if stereo is
<span class="emphasis"><i class="EMPHASIS">received</i></span>, unless the audio input belongs to a
tuner.</td></tr><tr><td><code class="CONSTANT">V4L2_AUDCAP_AVL</code></td><td>0x00002</td><td>Automatic Volume Level mode is supported.</td></tr></tbody></table></div><div class="TABLE"><a name="AUDIO-MODE"></a><p><b>Table 3. Audio Mode Flags</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_AUDMODE_AVL</code></td><td>0x00001</td><td>AVL mode is on.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN9671"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>No audio inputs combine with the current video input,
or the number of the selected audio input is out of bounds or it does
not combine, or there are no audio inputs at all and the ioctl is not
supported.</p></dd><dt><span class="ERRORCODE">EBUSY</span></dt><dd><p>I/O is in progress, the input cannot be
switched.</p></dd></dl></div></div><h1><a name="VIDIOC-G-AUDIOOUT"></a>ioctl VIDIOC_G_AUDOUT, VIDIOC_S_AUDOUT</h1><div class="REFNAMEDIV"><a name="AEN9692"></a><h2>Name</h2>VIDIOC_G_AUDOUT, VIDIOC_S_AUDOUT&nbsp;--&nbsp;Query or select the current audio output</div><div class="REFSYNOPSISDIV"><a name="AEN9696"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN9697"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_audioout *argp);</code></p><p></p></div><div class="FUNCSYNOPSIS"><p></p><a name="AEN9707"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, const struct v4l2_audioout *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN9717"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_G_AUDOUT, VIDIOC_S_AUDOUT</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN9737"></a><h2>Description</h2><p>To query the current audio output applications zero out the
<code class="STRUCTFIELD">reserved</code> array of a struct&nbsp;<a href="#V4L2-AUDIOOUT">v4l2_audioout</a> and
call the <code class="CONSTANT">VIDIOC_G_AUDOUT</code> ioctl with a pointer
to this structure. Drivers fill the rest of the structure or return an
<span class="ERRORCODE">EINVAL</span> error code when the device has no audio inputs, or none which combine
with the current video output.</p><p>Audio outputs have no writable properties. Nevertheless, to
select the current audio output applications can initialize the
<code class="STRUCTFIELD">index</code> field and
<code class="STRUCTFIELD">reserved</code> array (which in the future may
contain writable properties) of a
<code class="STRUCTNAME">v4l2_audioout</code> structure and call the
<code class="CONSTANT">VIDIOC_S_AUDOUT</code> ioctl. Drivers switch to the
requested output or return the <span class="ERRORCODE">EINVAL</span> error code when the index is out of
bounds. This is a write-only ioctl, it does not return the current
audio output attributes as <code class="CONSTANT">VIDIOC_G_AUDOUT</code>
does.</p><p>Note connectors on a TV card to loop back the received audio
signal to a sound card are not audio outputs in this sense.</p><div class="TABLE"><a name="V4L2-AUDIOOUT"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_audioout</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">index</code></td><td>Identifies the audio output, set by the
driver or application.</td></tr><tr><td>__u8</td><td><code class="STRUCTFIELD">name</code>[32]</td><td>Name of the audio output, a NUL-terminated ASCII
string, for example: "Line Out". This information is intended for the
user, preferably the connector label on the device itself.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">capability</code></td><td>Audio capability flags, none defined yet. Drivers
must set this field to zero.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">mode</code></td><td>Audio mode, none defined yet. Drivers and
applications (on <code class="CONSTANT">VIDIOC_S_AUDOUT</code>) must set this
field to zero.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code>[2]</td><td>Reserved for future extensions. Drivers and
applications must set the array to zero.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN9787"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>No audio outputs combine with the current video
output, or the number of the selected audio output is out of bounds or
it does not combine, or there are no audio outputs at all and the
ioctl is not supported.</p></dd><dt><span class="ERRORCODE">EBUSY</span></dt><dd><p>I/O is in progress, the output cannot be
switched.</p></dd></dl></div></div><h1><a name="VIDIOC-G-CHIP-IDENT"></a>ioctl VIDIOC_G_CHIP_IDENT</h1><div class="REFNAMEDIV"><a name="AEN9808"></a><h2>Name</h2>VIDIOC_G_CHIP_IDENT&nbsp;--&nbsp;Identify the chips on a TV card</div><div class="REFSYNOPSISDIV"><a name="AEN9811"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN9812"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_chip_ident
*argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN9822"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_G_CHIP_IDENT</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN9842"></a><h2>Description</h2><div class="NOTE"><blockquote class="NOTE"><p><b>Experimental: </b>This is an <a href="#EXPERIMENTAL">experimental</a> interface and may change in
the future.</p></blockquote></div><p>For driver debugging purposes this ioctl allows test
applications to query the driver about the chips present on the TV
card. Regular applications should not use it. When you found a chip
specific bug, please contact the Video4Linux mailing list (<a href="https://listman.redhat.com/mailman/listinfo/video4linux-list" target="_top">https://listman.redhat.com/mailman/listinfo/video4linux-list</a>)
so it can be fixed.</p><p>To query the driver applications must initialize the
<code class="STRUCTFIELD">match_type</code> and
<code class="STRUCTFIELD">match_chip</code> fields of a struct&nbsp;<a href="#V4L2-CHIP-IDENT">v4l2_chip_ident</a>
and call <code class="CONSTANT">VIDIOC_G_CHIP_IDENT</code> with a pointer to
this structure. On success the driver stores information about the
selected chip in the <code class="STRUCTFIELD">ident</code> and
<code class="STRUCTFIELD">revision</code> fields. On failure the structure
remains unchanged.</p><p>When <code class="STRUCTFIELD">match_type</code> is
<code class="CONSTANT">V4L2_CHIP_MATCH_HOST</code>,
<code class="STRUCTFIELD">match_chip</code> selects the nth non-I<sup>2</sup>C chip
on the TV card. You can enumerate all chips by starting at zero and
incrementing <code class="STRUCTFIELD">match_chip</code> by one until
<code class="CONSTANT">VIDIOC_G_CHIP_IDENT</code> fails with an <span class="ERRORCODE">EINVAL</span> error code.
Drivers may also interpret <code class="STRUCTFIELD">match_chip</code> as a
random ID, but we recommend against that. The number zero always
selects the host chip, e.&nbsp;g. the chip connected to the PCI bus.</p><p>When <code class="STRUCTFIELD">match_type</code> is
<code class="CONSTANT">V4L2_CHIP_MATCH_I2C_DRIVER</code>,
<code class="STRUCTFIELD">match_chip</code> contains a driver ID as defined
in the <tt class="FILENAME">linux/i2c-id.h</tt> header file. For instance
<code class="CONSTANT">I2C_DRIVERID_SAA7127</code> will match any chip
supported by the saa7127 driver, regardless of its I<sup>2</sup>C bus address.
When multiple chips supported by the same driver are present, the
ioctl will return <code class="CONSTANT">V4L2_IDENT_AMBIGUOUS</code> in the
<code class="STRUCTFIELD">ident</code> field.</p><p>When <code class="STRUCTFIELD">match_type</code> is
<code class="CONSTANT">V4L2_CHIP_MATCH_I2C_ADDR</code>,
<code class="STRUCTFIELD">match_chip</code> selects a chip by its 7 bit
I<sup>2</sup>C bus address.</p><p>On success, the <code class="STRUCTFIELD">ident</code> field will
contain a chip ID from the Linux
<tt class="FILENAME">media/v4l2-chip-ident.h</tt> header file, and the
<code class="STRUCTFIELD">revision</code> field will contain a driver
specific value, or zero if no particular revision is associated with
this chip.</p><p>When the driver could not identify the selected chip,
<code class="STRUCTFIELD">ident</code> will contain
<code class="CONSTANT">V4L2_IDENT_UNKNOWN</code>. When no chip matched
<code class="STRUCTFIELD">match_type</code> and
<code class="STRUCTFIELD">match_chip</code>, the ioctl will succeed but the
<code class="STRUCTFIELD">ident</code> field will contain
<code class="CONSTANT">V4L2_IDENT_NONE</code>. If multiple chips matched,
<code class="STRUCTFIELD">ident</code> will contain
<code class="CONSTANT">V4L2_IDENT_AMBIGUOUS</code>. In all these cases the
<code class="STRUCTFIELD">revision</code> field remains unchanged.</p><p>This ioctl is optional, not all drivers may support it. It
was introduced in Linux 2.6.21.</p><p>We recommended the <span class="APPLICATION">v4l2-dbg</span>
utility over calling this ioctl directly. It is available from the
LinuxTV v4l-dvb repository; see <a href="http://linuxtv.org/repo/" target="_top">http://linuxtv.org/repo/</a> for
access instructions.</p><div class="TABLE"><a name="V4L2-CHIP-IDENT"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_chip_ident</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">match_type</code></td><td>See <a href="#IDENT-CHIP-MATCH-TYPES">Table 2</a> for a list of
possible types.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">match_chip</code></td><td>Match a chip by this number, interpreted according
to the <code class="STRUCTFIELD">match_type</code> field.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">ident</code></td><td>A chip identifier as defined in the Linux
<tt class="FILENAME">media/v4l2-chip-ident.h</tt> header file, or one of
the values from <a href="#CHIP-IDS">Table 3</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">revision</code></td><td>A chip revision, chip and driver specific.</td></tr></tbody></table></div><div class="TABLE"><a name="IDENT-CHIP-MATCH-TYPES"></a><p><b>Table 2. Chip Match Types</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_CHIP_MATCH_HOST</code></td><td>0</td><td>Match the nth chip on the card, zero for the
            host chip. Does not match I<sup>2</sup>C chips.</td></tr><tr><td><code class="CONSTANT">V4L2_CHIP_MATCH_I2C_DRIVER</code></td><td>1</td><td>Match an I<sup>2</sup>C chip by its driver ID from the
<tt class="FILENAME">linux/i2c-id.h</tt> header file.</td></tr><tr><td><code class="CONSTANT">V4L2_CHIP_MATCH_I2C_ADDR</code></td><td>2</td><td>Match a chip by its 7 bit I<sup>2</sup>C bus address.</td></tr></tbody></table></div><div class="TABLE"><a name="CHIP-IDS"></a><p><b>Table 3. Chip Identifiers</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_IDENT_NONE</code></td><td>0</td><td>No chip matched.</td></tr><tr><td><code class="CONSTANT">V4L2_IDENT_AMBIGUOUS</code></td><td>1</td><td>Multiple chips matched.</td></tr><tr><td><code class="CONSTANT">V4L2_IDENT_UNKNOWN</code></td><td>2</td><td>A chip is present at this address, but the driver
could not identify it.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN9981"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The driver does not support this ioctl, or the
<code class="STRUCTFIELD">match_type</code> is invalid.</p></dd></dl></div></div><h1><a name="VIDIOC-G-CROP"></a>ioctl VIDIOC_G_CROP, VIDIOC_S_CROP</h1><div class="REFNAMEDIV"><a name="AEN9998"></a><h2>Name</h2>VIDIOC_G_CROP, VIDIOC_S_CROP&nbsp;--&nbsp;Get or set the current cropping rectangle</div><div class="REFSYNOPSISDIV"><a name="AEN10002"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN10003"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_crop *argp);</code></p><p></p></div><div class="FUNCSYNOPSIS"><p></p><a name="AEN10013"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, const struct v4l2_crop *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN10023"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_G_CROP, VIDIOC_S_CROP</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN10043"></a><h2>Description</h2><p>To query the cropping rectangle size and position
applications set the <code class="STRUCTFIELD">type</code> field of a
<code class="STRUCTNAME">v4l2_crop</code> structure to the respective buffer
(stream) type and call the <code class="CONSTANT">VIDIOC_G_CROP</code> ioctl
with a pointer to this structure. The driver fills the rest of the
structure or returns the <span class="ERRORCODE">EINVAL</span> error code if cropping is not supported.</p><p>To change the cropping rectangle applications initialize the
<code class="STRUCTFIELD">type</code> and struct&nbsp;<a href="#V4L2-RECT">v4l2_rect</a> substructure named
<code class="STRUCTFIELD">c</code> of a v4l2_crop structure and call the
<code class="CONSTANT">VIDIOC_S_CROP</code> ioctl with a pointer to this
structure.</p><p>The driver first adjusts the requested dimensions against
hardware limits, i.&nbsp;e. the bounds given by the capture/output window,
and it rounds to the closest possible values of horizontal and
vertical offset, width and height. In particular the driver must round
the vertical offset of the cropping rectangle to frame lines modulo
two, such that the field order cannot be confused.</p><p>Second the driver adjusts the image size (the opposite
rectangle of the scaling process, source or target depending on the
data direction) to the closest size possible while maintaining the
current horizontal and vertical scaling factor.</p><p>Finally the driver programs the hardware with the actual
cropping and image parameters. <code class="CONSTANT">VIDIOC_S_CROP</code> is a
write-only ioctl, it does not return the actual parameters. To query
them applications must call <code class="CONSTANT">VIDIOC_G_CROP</code> and
<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_G_FMT</code></a>. When the parameters are unsuitable the application may
modify the cropping or image parameters and repeat the cycle until
satisfactory parameters have been negotiated.</p><p>When cropping is not supported then no parameters are
changed and <code class="CONSTANT">VIDIOC_S_CROP</code> returns the
<span class="ERRORCODE">EINVAL</span> error code.</p><div class="TABLE"><a name="V4L2-CROP"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_crop</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>enum&nbsp;<a href="#V4L2-BUF-TYPE">v4l2_buf_type</a></td><td><code class="STRUCTFIELD">type</code></td><td>Type of the data stream, set by the application.
Only these types are valid here: <code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_CAPTURE</code>,
<code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_OUTPUT</code>,
<code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_OVERLAY</code>, and custom (driver
defined) types with code <code class="CONSTANT">V4L2_BUF_TYPE_PRIVATE</code>
and higher.</td></tr><tr><td>struct&nbsp;<a href="#V4L2-RECT">v4l2_rect</a></td><td><code class="STRUCTFIELD">c</code></td><td>Cropping rectangle. The same co-ordinate system as
for struct&nbsp;<a href="#V4L2-CROPCAP">v4l2_cropcap</a> <code class="STRUCTFIELD">bounds</code> is used.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN10092"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>Cropping is not supported.</p></dd></dl></div></div><h1><a name="VIDIOC-G-CTRL"></a>ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL</h1><div class="REFNAMEDIV"><a name="AEN10108"></a><h2>Name</h2>VIDIOC_G_CTRL, VIDIOC_S_CTRL&nbsp;--&nbsp;Get or set the value of a control</div><div class="REFSYNOPSISDIV"><a name="AEN10112"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN10113"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_control
*argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN10123"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_G_CTRL, VIDIOC_S_CTRL</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN10143"></a><h2>Description</h2><p>To get the current value of a control applications
initialize the <code class="STRUCTFIELD">id</code> field of a struct
<code class="STRUCTNAME">v4l2_control</code> and call the
<code class="CONSTANT">VIDIOC_G_CTRL</code> ioctl with a pointer to this
structure. To change the value of a control applications initialize
the <code class="STRUCTFIELD">id</code> and <code class="STRUCTFIELD">value</code>
fields of a struct <code class="STRUCTNAME">v4l2_control</code> and call the
<code class="CONSTANT">VIDIOC_S_CTRL</code> ioctl.</p><p>When the <code class="STRUCTFIELD">id</code> is invalid drivers
return an <span class="ERRORCODE">EINVAL</span> error code. When the <code class="STRUCTFIELD">value</code> is out
of bounds drivers can choose to take the closest valid value or return
an <span class="ERRORCODE">ERANGE</span> error code, whatever seems more appropriate. However,
<code class="CONSTANT">VIDIOC_S_CTRL</code> is a write-only ioctl, it does not
return the actual new value.</p><p>These ioctls work only with user controls. For other
control classes the <a href="#VIDIOC-G-EXT-CTRLS"><code class="CONSTANT">VIDIOC_G_EXT_CTRLS</code></a>, <a href="#VIDIOC-G-EXT-CTRLS"><code class="CONSTANT">VIDIOC_S_EXT_CTRLS</code></a> or
<a href="#VIDIOC-G-EXT-CTRLS"><code class="CONSTANT">VIDIOC_TRY_EXT_CTRLS</code></a> must be used.</p><div class="TABLE"><a name="V4L2-CONTROL"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_control</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">id</code></td><td>Identifies the control, set by the
application.</td></tr><tr><td>__s32</td><td><code class="STRUCTFIELD">value</code></td><td>New value or current value.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN10185"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The struct&nbsp;<a href="#V4L2-CONTROL">v4l2_control</a> <code class="STRUCTFIELD">id</code> is
invalid.</p></dd><dt><span class="ERRORCODE">ERANGE</span></dt><dd><p>The struct&nbsp;<a href="#V4L2-CONTROL">v4l2_control</a> <code class="STRUCTFIELD">value</code>
is out of bounds.</p></dd><dt><span class="ERRORCODE">EBUSY</span></dt><dd><p>The control is temporarily not changeable, possibly
because another applications took over control of the device function
this control belongs to.</p></dd></dl></div></div><h1><a name="VIDIOC-G-ENC-INDEX"></a>ioctl VIDIOC_G_ENC_INDEX</h1><div class="REFNAMEDIV"><a name="AEN10215"></a><h2>Name</h2>VIDIOC_G_ENC_INDEX&nbsp;--&nbsp;Get meta data about a compressed video stream</div><div class="REFSYNOPSISDIV"><a name="AEN10218"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN10219"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_enc_idx *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN10229"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_G_ENC_INDEX</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN10249"></a><h2>Description</h2><div class="NOTE"><blockquote class="NOTE"><p><b>Experimental: </b>This is an <a href="#EXPERIMENTAL">experimental</a>
interface and may change in the future.</p></blockquote></div><p>The <code class="CONSTANT">VIDIOC_G_ENC_INDEX</code> ioctl provides
meta data about a compressed video stream the same or another
application currently reads from the driver, which is useful for
random access into the stream without decoding it.</p><p>To read the data applications must call
<code class="CONSTANT">VIDIOC_G_ENC_INDEX</code> with a pointer to a
struct&nbsp;<a href="#V4L2-ENC-IDX">v4l2_enc_idx</a>. On success the driver fills the
<code class="STRUCTFIELD">entry</code> array, stores the number of elements
written in the <code class="STRUCTFIELD">entries</code> field, and
initializes the <code class="STRUCTFIELD">entries_cap</code> field.</p><p>Each element of the <code class="STRUCTFIELD">entry</code> array
contains meta data about one picture. A
<code class="CONSTANT">VIDIOC_G_ENC_INDEX</code> call reads up to
<code class="CONSTANT">V4L2_ENC_IDX_ENTRIES</code> entries from a driver
buffer, which can hold up to <code class="STRUCTFIELD">entries_cap</code>
entries. This number can be lower or higher than
<code class="CONSTANT">V4L2_ENC_IDX_ENTRIES</code>, but not zero. When the
application fails to read the meta data in time the oldest entries
will be lost. When the buffer is empty or no capturing/encoding is in
progress, <code class="STRUCTFIELD">entries</code> will be zero.</p><p>Currently this ioctl is only defined for MPEG-2 program
streams and video elementary streams.</p><div class="TABLE"><a name="V4L2-ENC-IDX"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_enc_idx</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">entries</code></td><td>The number of entries the driver stored in the
<code class="STRUCTFIELD">entry</code> array.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">entries_cap</code></td><td>The number of entries the driver can
buffer. Must be greater than zero.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code>[4]</td><td colspan="3">Reserved for future extensions.
Drivers must set the array to zero.</td></tr><tr><td>struct&nbsp;<a href="#V4L2-ENC-IDX-ENTRY">v4l2_enc_idx_entry</a></td><td><code class="STRUCTFIELD">entry</code>[<code class="CONSTANT">V4L2_ENC_IDX_ENTRIES</code>]</td><td>Meta data about a compressed video stream. Each
element of the array corresponds to one picture, sorted in ascending
order by their <code class="STRUCTFIELD">offset</code>.</td></tr></tbody></table></div><div class="TABLE"><a name="V4L2-ENC-IDX-ENTRY"></a><p><b>Table 2. struct <code class="STRUCTNAME">v4l2_enc_idx_entry</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u64</td><td><code class="STRUCTFIELD">offset</code></td><td>The offset in bytes from the beginning of the
compressed video stream to the beginning of this picture, that is a
<i class="WORDASWORD">PES packet header</i> as defined in <a href="#MPEG2PART1"><abbr class="ABBREV">ISO&nbsp;13818-1</abbr></a> or a <i class="WORDASWORD">picture
header</i> as defined in <a href="#MPEG2PART2"><abbr class="ABBREV">ISO&nbsp;13818-2</abbr></a>. When
the encoder is stopped, the driver resets the offset to zero.</td></tr><tr><td>__u64</td><td><code class="STRUCTFIELD">pts</code></td><td>The 33 bit <i class="WORDASWORD">Presentation Time
Stamp</i> of this picture as defined in <a href="#MPEG2PART1"><abbr class="ABBREV">ISO&nbsp;13818-1</abbr></a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">length</code></td><td>The length of this picture in bytes.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">flags</code></td><td>Flags containing the coding type of this picture, see <a href="#ENC-IDX-FLAGS">Table 3</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code>[2]</td><td>Reserved for future extensions.
Drivers must set the array to zero.</td></tr></tbody></table></div><div class="TABLE"><a name="ENC-IDX-FLAGS"></a><p><b>Table 3. Index Entry Flags</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_ENC_IDX_FRAME_I</code></td><td>0x00</td><td>This is an Intra-coded picture.</td></tr><tr><td><code class="CONSTANT">V4L2_ENC_IDX_FRAME_P</code></td><td>0x01</td><td>This is a Predictive-coded picture.</td></tr><tr><td><code class="CONSTANT">V4L2_ENC_IDX_FRAME_B</code></td><td>0x02</td><td>This is a Bidirectionally predictive-coded
picture.</td></tr><tr><td><code class="CONSTANT">V4L2_ENC_IDX_FRAME_MASK</code></td><td>0x0F</td><td><i class="WORDASWORD">AND</i> the flags field with
this mask to obtain the picture coding type.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN10374"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The driver does not support this ioctl.</p></dd></dl></div></div><h1><a name="VIDIOC-G-EXT-CTRLS"></a>ioctl VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS,
VIDIOC_TRY_EXT_CTRLS</h1><div class="REFNAMEDIV"><a name="AEN10390"></a><h2>Name</h2>VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS, VIDIOC_TRY_EXT_CTRLS&nbsp;--&nbsp;Get or set the value of several controls, try control
values</div><div class="REFSYNOPSISDIV"><a name="AEN10395"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN10396"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_ext_controls
*argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN10406"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS,
VIDIOC_TRY_EXT_CTRLS</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN10426"></a><h2>Description</h2><p>These ioctls allow the caller to get or set multiple
controls atomically. Control IDs are grouped into control classes (see
<a href="#CTRL-CLASS">Table 3</a>) and all controls in the control array
must belong to the same control class.</p><p>Applications must always fill in the
<code class="STRUCTFIELD">count</code>,
<code class="STRUCTFIELD">ctrl_class</code>,
<code class="STRUCTFIELD">controls</code> and
<code class="STRUCTFIELD">reserved</code> fields of struct&nbsp;<a href="#V4L2-EXT-CONTROLS">v4l2_ext_controls</a>, and
initialize the struct&nbsp;<a href="#V4L2-EXT-CONTROL">v4l2_ext_control</a> array pointed to by the
<code class="STRUCTFIELD">controls</code> fields.</p><p>To get the current value of a set of controls applications
initialize the <code class="STRUCTFIELD">id</code> field of each
struct&nbsp;<a href="#V4L2-EXT-CONTROL">v4l2_ext_control</a> and call the
<code class="CONSTANT">VIDIOC_G_EXT_CTRLS</code> ioctl.</p><p>To change the value of a set of controls applications
initialize the <code class="STRUCTFIELD">id</code> and
<code class="STRUCTFIELD">value</code> fields of a struct&nbsp;<a href="#V4L2-EXT-CONTROL">v4l2_ext_control</a> and
call the <code class="CONSTANT">VIDIOC_S_EXT_CTRLS</code> ioctl. The controls
will only be set if <span class="emphasis"><i class="EMPHASIS">all</i></span> control values are
valid.</p><p>To check if the a set of controls have correct values
applications initialize the <code class="STRUCTFIELD">id</code> and
<code class="STRUCTFIELD">value</code> fields of a struct&nbsp;<a href="#V4L2-EXT-CONTROL">v4l2_ext_control</a> and
call the <code class="CONSTANT">VIDIOC_TRY_EXT_CTRLS</code> ioctl. It is up to
the driver whether wrong values are automatically adjusted to a valid
value or if an error is returned.</p><p>When the <code class="STRUCTFIELD">id</code> or
<code class="STRUCTFIELD">ctrl_class</code> is invalid drivers return an
<span class="ERRORCODE">EINVAL</span> error code. When the value is out of bounds drivers can choose to take
the closest valid value or return an <span class="ERRORCODE">ERANGE</span> error code, whatever seems more
appropriate. In the first case the new value is set in
struct&nbsp;<a href="#V4L2-EXT-CONTROL">v4l2_ext_control</a>.</p><p>The driver will only set/get these controls if all control
values are correct. This prevents the situation where only some of the
controls were set/get. Only low-level errors (e.&nbsp;g. a failed i2c
command) can still cause this situation.</p><div class="TABLE"><a name="V4L2-EXT-CONTROL"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_ext_control</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="20%"><col title="C2" width="20%"><col title="C3" width="20%"><col title="C4" width="40%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">id</code></td><td>&nbsp;</td><td>Identifies the control, set by the
application.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved2</code>[2]</td><td>&nbsp;</td><td>Reserved for future extensions. Drivers and
applications must set the array to zero.</td></tr><tr><td>union</td><td>(anonymous)</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td>__s32</td><td><code class="STRUCTFIELD">value</code></td><td>New value or current value.</td></tr><tr><td>&nbsp;</td><td>__s64</td><td><code class="STRUCTFIELD">value64</code></td><td>New value or current value.</td></tr><tr><td>&nbsp;</td><td>void *</td><td><code class="STRUCTFIELD">reserved</code></td><td>Reserved for future pointer-type controls. Currently unused.</td></tr></tbody></table></div><div class="TABLE"><a name="V4L2-EXT-CONTROLS"></a><p><b>Table 2. struct <code class="STRUCTNAME">v4l2_ext_controls</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">ctrl_class</code></td><td>The control class to which all controls belong, see
<a href="#CTRL-CLASS">Table 3</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">count</code></td><td>The number of controls in the controls array. May
also be zero.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">error_idx</code></td><td>Set by the driver in case of an error. It is the
index of the control causing the error or equal to 'count' when the
error is not associated with a particular control. Undefined when the
ioctl returns 0 (success).</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code>[2]</td><td>Reserved for future extensions. Drivers and
applications must set the array to zero.</td></tr><tr><td>struct&nbsp;<a href="#V4L2-EXT-CONTROL">v4l2_ext_control</a> *</td><td><code class="STRUCTFIELD">controls</code></td><td>Pointer to an array of
<code class="STRUCTFIELD">count</code> v4l2_ext_control structures. Ignored
if <code class="STRUCTFIELD">count</code> equals zero.</td></tr></tbody></table></div><div class="TABLE"><a name="CTRL-CLASS"></a><p><b>Table 3. Control classes</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_CTRL_CLASS_USER</code></td><td>0x980000</td><td>The class containing user controls. These controls
are described in <a href="#CONTROL">Section 1.8</a>. All controls that can be set
using the <a href="#VIDIOC-G-CTRL"><code class="CONSTANT">VIDIOC_S_CTRL</code></a> and <a href="#VIDIOC-G-CTRL"><code class="CONSTANT">VIDIOC_G_CTRL</code></a> ioctl belong to this
class.</td></tr><tr><td><code class="CONSTANT">V4L2_CTRL_CLASS_MPEG</code></td><td>0x990000</td><td>The class containing MPEG compression controls.
These controls are described in section <a href="#MPEG-CONTROLS">Section 1.9.5</a>.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN10565"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The struct&nbsp;<a href="#V4L2-EXT-CONTROL">v4l2_ext_control</a> <code class="STRUCTFIELD">id</code>
is invalid or the struct&nbsp;<a href="#V4L2-EXT-CONTROLS">v4l2_ext_controls</a>
<code class="STRUCTFIELD">ctrl_class</code> is invalid. This error code is
also returned by the <code class="CONSTANT">VIDIOC_S_EXT_CTRLS</code> and
<code class="CONSTANT">VIDIOC_TRY_EXT_CTRLS</code> ioctls if two or more
control values are in conflict.</p></dd><dt><span class="ERRORCODE">ERANGE</span></dt><dd><p>The struct&nbsp;<a href="#V4L2-EXT-CONTROL">v4l2_ext_control</a> <code class="STRUCTFIELD">value</code>
is out of bounds.</p></dd><dt><span class="ERRORCODE">EBUSY</span></dt><dd><p>The control is temporarily not changeable, possibly
because another applications took over control of the device function
this control belongs to.</p></dd></dl></div></div><h1><a name="VIDIOC-G-FBUF"></a>ioctl VIDIOC_G_FBUF, VIDIOC_S_FBUF</h1><div class="REFNAMEDIV"><a name="AEN10599"></a><h2>Name</h2>VIDIOC_G_FBUF, VIDIOC_S_FBUF&nbsp;--&nbsp;Get or set frame buffer overlay parameters</div><div class="REFSYNOPSISDIV"><a name="AEN10603"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN10604"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_framebuffer *argp);</code></p><p></p></div><div class="FUNCSYNOPSIS"><p></p><a name="AEN10614"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, const struct v4l2_framebuffer *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN10624"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_G_FBUF, VIDIOC_S_FBUF</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN10644"></a><h2>Description</h2><p>Applications can use the <code class="CONSTANT">VIDIOC_G_FBUF</code> and
<code class="CONSTANT">VIDIOC_S_FBUF</code> ioctl to get and set the
framebuffer parameters for a <a href="#OVERLAY">Video
Overlay</a> or <a href="#OSD">Video Output Overlay</a>
(OSD). The type of overlay is implied by the device type (capture or
output device) and can be determined with the <a href="#VIDIOC-QUERYCAP"><code class="CONSTANT">VIDIOC_QUERYCAP</code></a> ioctl.
One <tt class="FILENAME">/dev/videoN</tt> device must not support both
kinds of overlay.</p><p>The V4L2 API distinguishes destructive and non-destructive
overlays. A destructive overlay copies captured video images into the
video memory of a graphics card. A non-destructive overlay blends
video images into a VGA signal or graphics into a video signal.
<i class="WORDASWORD">Video Output Overlays</i> are always
non-destructive.</p><p>To get the current parameters applications call the
<code class="CONSTANT">VIDIOC_G_FBUF</code> ioctl with a pointer to a
<code class="STRUCTNAME">v4l2_framebuffer</code> structure. The driver fills
all fields of the structure or returns an <span class="ERRORCODE">EINVAL</span> error code when overlays are
not supported.</p><p>To set the parameters for a <i class="WORDASWORD">Video Output
Overlay</i>, applications must initialize the
<code class="STRUCTFIELD">flags</code> field of a struct
<code class="STRUCTNAME">v4l2_framebuffer</code>. Since the framebuffer is
implemented on the TV card all other parameters are determined by the
driver. When an application calls <code class="CONSTANT">VIDIOC_S_FBUF</code>
with a pointer to this structure, the driver prepares for the overlay
and returns the framebuffer parameters as
<code class="CONSTANT">VIDIOC_G_FBUF</code> does, or it returns an error
code.</p><p>To set the parameters for a <i class="WORDASWORD">non-destructive
Video Overlay</i>, applications must initialize the
<code class="STRUCTFIELD">flags</code> field, the
<code class="STRUCTFIELD">fmt</code> substructure, and call
<code class="CONSTANT">VIDIOC_S_FBUF</code>. Again the driver prepares for the
overlay and returns the framebuffer parameters as
<code class="CONSTANT">VIDIOC_G_FBUF</code> does, or it returns an error
code.</p><p>For a <i class="WORDASWORD">destructive Video Overlay</i>
applications must additionally provide a
<code class="STRUCTFIELD">base</code> address. Setting up a DMA to a
random memory location can jeopardize the system security, its
stability or even damage the hardware, therefore only the superuser
can set the parameters for a destructive video overlay.</p><div class="TABLE"><a name="V4L2-FRAMEBUFFER"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_framebuffer</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="20%"><col title="C2" width="20%"><col title="C3" width="20%"><col title="C4" width="40%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">capability</code></td><td>&nbsp;</td><td>Overlay capability flags set by the driver, see
<a href="#FRAMEBUFFER-CAP">Table 2</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">flags</code></td><td>&nbsp;</td><td>Overlay control flags set by application and
driver, see <a href="#FRAMEBUFFER-FLAGS">Table 3</a></td></tr><tr><td>void *</td><td><code class="STRUCTFIELD">base</code></td><td>&nbsp;</td><td><p>Physical base address of the framebuffer,
that is the address of the pixel in the top left corner of the
framebuffer.<sup>a</sup></p><p>This field is irrelevant to
<i class="WORDASWORD">non-destructive Video Overlays</i>. For
<i class="WORDASWORD">destructive Video Overlays</i> applications must
provide a base address. The driver may accept only base addresses
which are a multiple of two, four or eight bytes. For
<i class="WORDASWORD">Video Output Overlays</i> the driver must return
a valid base address, so applications can find the corresponding Linux
framebuffer device (see <a href="#OSD">Section 4.4</a>).</p></td></tr><tr><td>struct&nbsp;<a href="#V4L2-PIX-FORMAT">v4l2_pix_format</a></td><td><code class="STRUCTFIELD">fmt</code></td><td>&nbsp;</td><td>Layout of the frame buffer. The
<code class="STRUCTNAME">v4l2_pix_format</code> structure is defined in <a href="#PIXFMT">Chapter 2</a>, for clarification the fields and acceptable values
            are listed below:</td></tr><tr><td>&nbsp;</td><td>__u32</td><td><code class="STRUCTFIELD">width</code></td><td>Width of the frame buffer in pixels.</td></tr><tr><td>&nbsp;</td><td>__u32</td><td><code class="STRUCTFIELD">height</code></td><td>Height of the frame buffer in pixels.</td></tr><tr><td>&nbsp;</td><td>__u32</td><td><code class="STRUCTFIELD">pixelformat</code></td><td><p>The pixel format of the
framebuffer.</p><p>For <i class="WORDASWORD">non-destructive Video
Overlays</i> this field only defines a format for the
struct&nbsp;<a href="#V4L2-WINDOW">v4l2_window</a> <code class="STRUCTFIELD">chromakey</code>
field.</p><p>For <i class="WORDASWORD">destructive Video
Overlays</i> applications must initialize this field. For
<i class="WORDASWORD">Video Output Overlays</i> the driver must return
a valid format.</p><p>Usually this is an RGB format (for example
<a href="#V4L2-PIX-FMT-RGB565"><code class="CONSTANT">V4L2_PIX_FMT_RGB565</code></a>) 
but YUV formats (only packed YUV formats when chroma keying is used,
not including <code class="CONSTANT">V4L2_PIX_FMT_YUYV</code> and
<code class="CONSTANT">V4L2_PIX_FMT_UYVY</code>) and the
<code class="CONSTANT">V4L2_PIX_FMT_PAL8</code> format are also permitted. The
behavior of the driver when an application requests a compressed
format is undefined. See <a href="#PIXFMT">Chapter 2</a> for information on
pixel formats.</p></td></tr><tr><td>&nbsp;</td><td>enum&nbsp;<a href="#V4L2-FIELD">v4l2_field</a></td><td><code class="STRUCTFIELD">field</code></td><td>Drivers and applications shall ignore this field.
If applicable, the field order is selected with the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a>
ioctl, using the <code class="STRUCTFIELD">field</code> field of
struct&nbsp;<a href="#V4L2-WINDOW">v4l2_window</a>.</td></tr><tr><td>&nbsp;</td><td>__u32</td><td><code class="STRUCTFIELD">bytesperline</code></td><td>Distance in bytes between the leftmost pixels in
two adjacent lines.</td></tr><tr><td colspan="4"><p>This field is irrelevant to
<i class="WORDASWORD">non-destructive Video
Overlays</i>.</p><p>For <i class="WORDASWORD">destructive Video
Overlays</i> both applications and drivers can set this field
to request padding bytes at the end of each line. Drivers however may
ignore the requested value, returning <code class="STRUCTFIELD">width</code>
times bytes-per-pixel or a larger value required by the hardware. That
implies applications can just set this field to zero to get a
reasonable default.</p><p>For <i class="WORDASWORD">Video Output
Overlays</i> the driver must return a valid
value.</p><p>Video hardware may access padding bytes, therefore
they must reside in accessible memory. Consider for example the case
where padding bytes after the last line of an image cross a system
page boundary. Capture devices may write padding bytes, the value is
undefined. Output devices ignore the contents of padding
bytes.</p><p>When the image format is planar the
<code class="STRUCTFIELD">bytesperline</code> value applies to the largest
plane and is divided by the same factor as the
<code class="STRUCTFIELD">width</code> field for any smaller planes. For
example the Cb and Cr planes of a YUV 4:2:0 image have half as many
padding bytes following each line as the Y plane. To avoid ambiguities
drivers must return a <code class="STRUCTFIELD">bytesperline</code> value
rounded up to a multiple of the scale factor.</p></td></tr><tr><td>&nbsp;</td><td>__u32</td><td><code class="STRUCTFIELD">sizeimage</code></td><td><p>This field is irrelevant to
<i class="WORDASWORD">non-destructive Video Overlays</i>. For
<i class="WORDASWORD">destructive Video Overlays</i> applications must
initialize this field. For <i class="WORDASWORD">Video Output
Overlays</i> the driver must return a valid
format.</p><p>Together with <code class="STRUCTFIELD">base</code> it
defines the framebuffer memory accessible by the
driver.</p></td></tr><tr><td>&nbsp;</td><td>enum&nbsp;<a href="#V4L2-COLORSPACE">v4l2_colorspace</a></td><td><code class="STRUCTFIELD">colorspace</code></td><td>This information supplements the
<code class="STRUCTFIELD">pixelformat</code> and must be set by the driver,
see <a href="#COLORSPACES">Section 2.2</a>.</td></tr><tr><td>&nbsp;</td><td>__u32</td><td><code class="STRUCTFIELD">priv</code></td><td>Reserved for additional information about custom
(driver defined) formats. When not used drivers and applications must
set this field to zero.</td></tr></tbody><tbody><tr><td colspan="4">Notes:<br><a name="FTN.AEN10706">a. </a>A physical base address may not suit all
platforms. GK notes in theory we should pass something like PCI device
+ memory region + offset instead. If you encounter problems please
discuss on the Video4Linux mailing list:
<a href="https://listman.redhat.com/mailman/listinfo/video4linux-list" target="_top">https://listman.redhat.com/mailman/listinfo/video4linux-list</a>.<br></td></tr></tbody></table></div><div class="TABLE"><a name="FRAMEBUFFER-CAP"></a><p><b>Table 2. Frame Buffer Capability Flags</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_FBUF_CAP_EXTERNOVERLAY</code></td><td>0x0001</td><td>The device is capable of non-destructive overlays.
When the driver clears this flag, only destructive overlays are
supported. There are no drivers yet which support both destructive and
non-destructive overlays.</td></tr><tr><td><code class="CONSTANT">V4L2_FBUF_CAP_CHROMAKEY</code></td><td>0x0002</td><td>The device supports clipping by chroma-keying the
images. That is, image pixels replace pixels in the VGA or video
signal only where the latter assume a certain color. Chroma-keying
makes no sense for destructive overlays.</td></tr><tr><td><code class="CONSTANT">V4L2_FBUF_CAP_LIST_CLIPPING</code></td><td>0x0004</td><td>The device supports clipping using a list of clip
rectangles.</td></tr><tr><td><code class="CONSTANT">V4L2_FBUF_CAP_BITMAP_CLIPPING</code></td><td>0x0008</td><td>The device supports clipping using a bit mask.</td></tr><tr><td><code class="CONSTANT">V4L2_FBUF_CAP_LOCAL_ALPHA</code></td><td>0x0010</td><td>The device supports clipping/blending using the
alpha channel of the framebuffer or VGA signal. Alpha blending makes
no sense for destructive overlays.</td></tr><tr><td><code class="CONSTANT">V4L2_FBUF_CAP_GLOBAL_ALPHA</code></td><td>0x0020</td><td>The device supports alpha blending using a global
alpha value. Alpha blending makes no sense for destructive overlays.</td></tr><tr><td><code class="CONSTANT">V4L2_FBUF_CAP_LOCAL_INV_ALPHA</code></td><td>0x0040</td><td>The device supports clipping/blending using the
inverted alpha channel of the framebuffer or VGA signal. Alpha
blending makes no sense for destructive overlays.</td></tr></tbody></table></div><div class="TABLE"><a name="FRAMEBUFFER-FLAGS"></a><p><b>Table 3. Frame Buffer Flags</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_FBUF_FLAG_PRIMARY</code></td><td>0x0001</td><td>The framebuffer is the primary graphics surface.
In other words, the overlay is destructive. [?]</td></tr><tr><td><code class="CONSTANT">V4L2_FBUF_FLAG_OVERLAY</code></td><td>0x0002</td><td>The frame buffer is an overlay surface the same
size as the capture. [?]</td></tr><tr><td colspan="3">The purpose of
<code class="CONSTANT">V4L2_FBUF_FLAG_PRIMARY</code> and
<code class="CONSTANT">V4L2_FBUF_FLAG_OVERLAY</code> was never quite clear.
Most drivers seem to ignore these flags. For compatibility with the
<i class="WORDASWORD">bttv</i> driver applications should set the
<code class="CONSTANT">V4L2_FBUF_FLAG_OVERLAY</code> flag.</td></tr><tr><td><code class="CONSTANT">V4L2_FBUF_FLAG_CHROMAKEY</code></td><td>0x0004</td><td>Use chroma-keying. The chroma-key color is
determined by the <code class="STRUCTFIELD">chromakey</code> field of
struct&nbsp;<a href="#V4L2-WINDOW">v4l2_window</a> and negotiated with the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl, see <a href="#OVERLAY">Section 4.2</a>
and
            <a href="#OSD">Section 4.4</a>.</td></tr><tr><td colspan="3">There are no flags to enable
clipping using a list of clip rectangles or a bitmap. These methods
are negotiated with the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl, see <a href="#OVERLAY">Section 4.2</a> and <a href="#OSD">Section 4.4</a>.</td></tr><tr><td><code class="CONSTANT">V4L2_FBUF_FLAG_LOCAL_ALPHA</code></td><td>0x0008</td><td>Use the alpha channel of the framebuffer to clip or
blend framebuffer pixels with video images. The blend
function is: output = framebuffer pixel * alpha + video pixel * (1 -
alpha). The actual alpha depth depends on the framebuffer pixel
format.</td></tr><tr><td><code class="CONSTANT">V4L2_FBUF_FLAG_GLOBAL_ALPHA</code></td><td>0x0010</td><td>Use a global alpha value to blend the framebuffer
with video images. The blend function is: output = (framebuffer pixel
* alpha + video pixel * (255 - alpha)) / 255. The alpha value is
determined by the <code class="STRUCTFIELD">global_alpha</code> field of
struct&nbsp;<a href="#V4L2-WINDOW">v4l2_window</a> and negotiated with the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl, see <a href="#OVERLAY">Section 4.2</a>
and <a href="#OSD">Section 4.4</a>.</td></tr><tr><td><code class="CONSTANT">V4L2_FBUF_FLAG_LOCAL_INV_ALPHA</code></td><td>0x0020</td><td>Like
<code class="CONSTANT">V4L2_FBUF_FLAG_LOCAL_ALPHA</code>, use the alpha channel
of the framebuffer to clip or blend framebuffer pixels with video
images, but with an inverted alpha value. The blend function is:
output = framebuffer pixel * (1 - alpha) + video pixel * alpha. The
actual alpha depth depends on the framebuffer pixel format.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN10920"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EPERM</span></dt><dd><p><code class="CONSTANT">VIDIOC_S_FBUF</code> can only be called
by a privileged user to negotiate the parameters for a destructive
overlay.</p></dd><dt><span class="ERRORCODE">EBUSY</span></dt><dd><p>The framebuffer parameters cannot be changed at this
time because overlay is already enabled, or capturing is enabled
and the hardware cannot capture and overlay simultaneously.</p></dd><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The ioctl is not supported or the
<code class="CONSTANT">VIDIOC_S_FBUF</code> parameters are unsuitable.</p></dd></dl></div></div><h1><a name="VIDIOC-G-FMT"></a>ioctl VIDIOC_G_FMT, VIDIOC_S_FMT,
VIDIOC_TRY_FMT</h1><div class="REFNAMEDIV"><a name="AEN10948"></a><h2>Name</h2>VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT&nbsp;--&nbsp;Get or set the data format, try a format</div><div class="REFSYNOPSISDIV"><a name="AEN10953"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN10954"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_format
*argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN10964"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN10984"></a><h2>Description</h2><p>These ioctls are used to negotiate the format of data
(typically image format) exchanged between driver and
application.</p><p>To query the current parameters applications set the
<code class="STRUCTFIELD">type</code> field of a struct
<code class="STRUCTNAME">v4l2_format</code> to the respective buffer (stream)
type. For example video capture devices use
<code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_CAPTURE</code>. When the application
calls the <code class="CONSTANT">VIDIOC_G_FMT</code> ioctl with a pointer to
this structure the driver fills the respective member of the
<code class="STRUCTFIELD">fmt</code> union. In case of video capture devices
that is the struct&nbsp;<a href="#V4L2-PIX-FORMAT">v4l2_pix_format</a> <code class="STRUCTFIELD">pix</code> member.
When the requested buffer type is not supported drivers return an
<span class="ERRORCODE">EINVAL</span> error code.</p><p>To change the current format parameters applications
initialize the <code class="STRUCTFIELD">type</code> field and all
fields of the respective <code class="STRUCTFIELD">fmt</code>
union member. For details see the documentation of the various devices
types in <a href="#DEVICES">Chapter 4</a>. Good practice is to query the
current parameters first, and to
modify only those parameters not suitable for the application. When
the application calls the <code class="CONSTANT">VIDIOC_S_FMT</code> ioctl
with a pointer to a <code class="STRUCTNAME">v4l2_format</code> structure
the driver checks
and adjusts the parameters against hardware abilities. Drivers
should not return an error code unless the input is ambiguous, this is
a mechanism to fathom device capabilities and to approach parameters
acceptable for both the application and driver. On success the driver
may program the hardware, allocate resources and generally prepare for
data exchange.
Finally the <code class="CONSTANT">VIDIOC_S_FMT</code> ioctl returns the
current format parameters as <code class="CONSTANT">VIDIOC_G_FMT</code> does.
Very simple, inflexible devices may even ignore all input and always
return the default parameters. However all V4L2 devices exchanging
data with the application must implement the
<code class="CONSTANT">VIDIOC_G_FMT</code> and
<code class="CONSTANT">VIDIOC_S_FMT</code> ioctl. When the requested buffer
type is not supported drivers return an <span class="ERRORCODE">EINVAL</span> error code on a
<code class="CONSTANT">VIDIOC_S_FMT</code> attempt. When I/O is already in
progress or the resource is not available for other reasons drivers
return the <span class="ERRORCODE">EBUSY</span> error code.</p><p>The <code class="CONSTANT">VIDIOC_TRY_FMT</code> ioctl is equivalent
to <code class="CONSTANT">VIDIOC_S_FMT</code> with one exception: it does not
change driver state. It can also be called at any time, never
returning <span class="ERRORCODE">EBUSY</span>. This function is provided to
negotiate parameters, to learn about hardware limitations, without
disabling I/O or possibly time consuming hardware preparations.
Although strongly recommended drivers are not required to implement
this ioctl.</p><div class="TABLE"><a name="V4L2-FORMAT"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_format</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="25%"><col title="C4" width="25%"></colgroup><tbody valign="TOP"><tr><td>enum&nbsp;<a href="#V4L2-BUF-TYPE">v4l2_buf_type</a></td><td><code class="STRUCTFIELD">type</code></td><td>&nbsp;</td><td>Type of the data stream, see <a href="#V4L2-BUF-TYPE">Table 3-2</a>.</td></tr><tr><td>union</td><td><code class="STRUCTFIELD">fmt</code></td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td>struct&nbsp;<a href="#V4L2-PIX-FORMAT">v4l2_pix_format</a></td><td><code class="STRUCTFIELD">pix</code></td><td>Definition of an image format, see <a href="#PIXFMT">Chapter 2</a>, used by video capture and output
devices.</td></tr><tr><td>&nbsp;</td><td>struct&nbsp;<a href="#V4L2-WINDOW">v4l2_window</a></td><td><code class="STRUCTFIELD">win</code></td><td>Definition of an overlaid image, see <a href="#OVERLAY">Section 4.2</a>, used by video overlay devices.</td></tr><tr><td>&nbsp;</td><td>struct&nbsp;<a href="#V4L2-VBI-FORMAT">v4l2_vbi_format</a></td><td><code class="STRUCTFIELD">vbi</code></td><td>Raw VBI capture or output parameters. This is
discussed in more detail in <a href="#RAW-VBI">Section 4.7</a>. Used by raw VBI
capture and output devices.</td></tr><tr><td>&nbsp;</td><td>struct&nbsp;<a href="#V4L2-SLICED-VBI-FORMAT">v4l2_sliced_vbi_format</a></td><td><code class="STRUCTFIELD">sliced</code></td><td>Sliced VBI capture or output parameters. See
<a href="#SLICED">Section 4.8</a> for details. Used by sliced VBI
capture and output devices.</td></tr><tr><td>&nbsp;</td><td>__u8</td><td><code class="STRUCTFIELD">raw_data</code>[200]</td><td>Place holder for future extensions and custom
(driver defined) formats with <code class="STRUCTFIELD">type</code>
<code class="CONSTANT">V4L2_BUF_TYPE_PRIVATE</code> and higher.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN11074"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EBUSY</span></dt><dd><p>The data format cannot be changed at this
time, for example because I/O is already in progress.</p></dd><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a> <code class="STRUCTFIELD">type</code>
field is invalid, the requested buffer type not supported, or
<code class="CONSTANT">VIDIOC_TRY_FMT</code> was called and is not
supported with this buffer type.</p></dd></dl></div></div><h1><a name="VIDIOC-G-FREQUENCY"></a>ioctl VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY</h1><div class="REFNAMEDIV"><a name="AEN11098"></a><h2>Name</h2>VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY&nbsp;--&nbsp;Get or set tuner or modulator radio
frequency</div><div class="REFSYNOPSISDIV"><a name="AEN11102"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN11103"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_frequency
*argp);</code></p><p></p></div><div class="FUNCSYNOPSIS"><p></p><a name="AEN11113"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, const struct v4l2_frequency
*argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN11123"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN11143"></a><h2>Description</h2><p>To get the current tuner or modulator radio frequency
applications set the <code class="STRUCTFIELD">tuner</code> field of a
struct&nbsp;<a href="#V4L2-FREQUENCY">v4l2_frequency</a> to the respective tuner or modulator number (only
input devices have tuners, only output devices have modulators), zero
out the <code class="STRUCTFIELD">reserved</code> array and
call the <code class="CONSTANT">VIDIOC_G_FREQUENCY</code> ioctl with a pointer
to this structure. The driver stores the current frequency in the
<code class="STRUCTFIELD">frequency</code> field.</p><p>To change the current tuner or modulator radio frequency
applications initialize the <code class="STRUCTFIELD">tuner</code>,
<code class="STRUCTFIELD">type</code> and
<code class="STRUCTFIELD">frequency</code> fields, and the
<code class="STRUCTFIELD">reserved</code> array of a struct&nbsp;<a href="#V4L2-FREQUENCY">v4l2_frequency</a> and
call the <code class="CONSTANT">VIDIOC_S_FREQUENCY</code> ioctl with a pointer
to this structure. When the requested frequency is not possible the
driver assumes the closest possible value. However
<code class="CONSTANT">VIDIOC_S_FREQUENCY</code> is a write-only ioctl, it does
not return the actual new frequency.</p><div class="TABLE"><a name="V4L2-FREQUENCY"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_frequency</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">tuner</code></td><td>The tuner or modulator index number. This is the
same value as in the struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a> <code class="STRUCTFIELD">tuner</code>
field and the struct&nbsp;<a href="#V4L2-TUNER">v4l2_tuner</a> <code class="STRUCTFIELD">index</code> field, or
the struct&nbsp;<a href="#V4L2-OUTPUT">v4l2_output</a> <code class="STRUCTFIELD">modulator</code> field and the
struct&nbsp;<a href="#V4L2-MODULATOR">v4l2_modulator</a> <code class="STRUCTFIELD">index</code> field.</td></tr><tr><td>enum&nbsp;<a href="#V4L2-TUNER-TYPE">v4l2_tuner_type</a></td><td><code class="STRUCTFIELD">type</code></td><td>The tuner type. This is the same value as in the
struct&nbsp;<a href="#V4L2-TUNER">v4l2_tuner</a> <code class="STRUCTFIELD">type</code> field. The field is not
applicable to modulators, i.&nbsp;e. ignored by drivers.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">frequency</code></td><td>Tuning frequency in units of 62.5 kHz, or if the
struct&nbsp;<a href="#V4L2-TUNER">v4l2_tuner</a> or struct&nbsp;<a href="#V4L2-MODULATOR">v4l2_modulator</a> <code class="STRUCTFIELD">capabilities</code> flag
<code class="CONSTANT">V4L2_TUNER_CAP_LOW</code> is set, in units of 62.5
Hz.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code>[8];</td><td>Reserved for future extensions. Drivers and
            applications must set the array to zero.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN11203"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The <code class="STRUCTFIELD">tuner</code> index is out of
bounds or the value in the <code class="STRUCTFIELD">type</code> field is
wrong.</p></dd></dl></div></div><h1><a name="VIDIOC-G-INPUT"></a>ioctl VIDIOC_G_INPUT, VIDIOC_S_INPUT</h1><div class="REFNAMEDIV"><a name="AEN11221"></a><h2>Name</h2>VIDIOC_G_INPUT, VIDIOC_S_INPUT&nbsp;--&nbsp;Query or select the current video input</div><div class="REFSYNOPSISDIV"><a name="AEN11225"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN11226"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, int *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN11236"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_G_INPUT, VIDIOC_S_INPUT</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN11256"></a><h2>Description</h2><p>To query the current video input applications call the
<code class="CONSTANT">VIDIOC_G_INPUT</code> ioctl with a pointer to an integer
where the driver stores the number of the input, as in the
struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a> <code class="STRUCTFIELD">index</code> field. This ioctl will
fail only when there are no video inputs, returning
<span class="ERRORCODE">EINVAL</span>.</p><p>To select a video input applications store the number of the
desired input in an integer and call the
<code class="CONSTANT">VIDIOC_S_INPUT</code> ioctl with a pointer to this
integer. Side effects are possible. For example inputs may support
different video standards, so the driver may implicitly switch the
current standard. It is good practice to select an input before
querying or negotiating any other parameters.</p><p>Information about video inputs is available using the
<a href="#VIDIOC-ENUMINPUT"><code class="CONSTANT">VIDIOC_ENUMINPUT</code></a> ioctl.</p></div><div class="REFSECT1"><a name="AEN11268"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The number of the video input is out of bounds, or
there are no video inputs at all and this ioctl is not
supported.</p></dd><dt><span class="ERRORCODE">EBUSY</span></dt><dd><p>I/O is in progress, the input cannot be
switched.</p></dd></dl></div></div><h1><a name="VIDIOC-G-JPEGCOMP"></a>ioctl VIDIOC_G_JPEGCOMP, VIDIOC_S_JPEGCOMP</h1><div class="REFNAMEDIV"><a name="AEN11289"></a><h2>Name</h2>VIDIOC_G_JPEGCOMP, VIDIOC_S_JPEGCOMP&nbsp;--&nbsp;</div><div class="REFSYNOPSISDIV"><a name="AEN11293"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN11294"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, v4l2_jpegcompression *argp);</code></p><p></p></div><div class="FUNCSYNOPSIS"><p></p><a name="AEN11304"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, const v4l2_jpegcompression *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN11314"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_G_JPEGCOMP, VIDIOC_S_JPEGCOMP</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN11334"></a><h2>Description</h2><p>[to do]</p><p>Ronald Bultje elaborates:</p><p>APP is some application-specific information. The
application can set it itself, and it'll be stored in the JPEG-encoded
fields (eg; interlacing information for in an AVI or so). COM is the
same, but it's comments, like 'encoded by me' or so.</p><p>jpeg_markers describes whether the huffman tables,
quantization tables and the restart interval information (all
JPEG-specific stuff) should be stored in the JPEG-encoded fields.
These define how the JPEG field is encoded. If you omit them,
applications assume you've used standard encoding. You usually do want
to add them.</p><div class="TABLE"><a name="V4L2-JPEGCOMPRESSION"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_jpegcompression</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>int</td><td><code class="STRUCTFIELD">quality</code></td><td>&nbsp;</td></tr><tr><td>int</td><td><code class="STRUCTFIELD">APPn</code></td><td>&nbsp;</td></tr><tr><td>int</td><td><code class="STRUCTFIELD">APP_len</code></td><td>&nbsp;</td></tr><tr><td>char</td><td><code class="STRUCTFIELD">APP_data</code>[60]</td><td>&nbsp;</td></tr><tr><td>int</td><td><code class="STRUCTFIELD">COM_len</code></td><td>&nbsp;</td></tr><tr><td>char</td><td><code class="STRUCTFIELD">COM_data</code>[60]</td><td>&nbsp;</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">jpeg_markers</code></td><td>See <a href="#JPEG-MARKERS">Table 2</a>.</td></tr></tbody></table></div><div class="TABLE"><a name="JPEG-MARKERS"></a><p><b>Table 2. JPEG Markers Flags</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_JPEG_MARKER_DHT</code></td><td>(1&lt;&lt;3)</td><td>Define Huffman Tables</td></tr><tr><td><code class="CONSTANT">V4L2_JPEG_MARKER_DQT</code></td><td>(1&lt;&lt;4)</td><td>Define Quantization Tables</td></tr><tr><td><code class="CONSTANT">V4L2_JPEG_MARKER_DRI</code></td><td>(1&lt;&lt;5)</td><td>Define Restart Interval</td></tr><tr><td><code class="CONSTANT">V4L2_JPEG_MARKER_COM</code></td><td>(1&lt;&lt;6)</td><td>Comment segment</td></tr><tr><td><code class="CONSTANT">V4L2_JPEG_MARKER_APP</code></td><td>(1&lt;&lt;7)</td><td>App segment, driver will always use APP0</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN11418"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>This ioctl is not supported.</p></dd></dl></div></div><h1><a name="VIDIOC-G-MODULATOR"></a>ioctl VIDIOC_G_MODULATOR, VIDIOC_S_MODULATOR</h1><div class="REFNAMEDIV"><a name="AEN11434"></a><h2>Name</h2>VIDIOC_G_MODULATOR, VIDIOC_S_MODULATOR&nbsp;--&nbsp;Get or set modulator attributes</div><div class="REFSYNOPSISDIV"><a name="AEN11438"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN11439"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_modulator
*argp);</code></p><p></p></div><div class="FUNCSYNOPSIS"><p></p><a name="AEN11449"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, const struct v4l2_modulator
*argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN11459"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_G_MODULATOR, VIDIOC_S_MODULATOR</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN11479"></a><h2>Description</h2><p>To query the attributes of a modulator applications initialize
the <code class="STRUCTFIELD">index</code> field and zero out the
<code class="STRUCTFIELD">reserved</code> array of a struct&nbsp;<a href="#V4L2-MODULATOR">v4l2_modulator</a> and
call the <code class="CONSTANT">VIDIOC_G_MODULATOR</code> ioctl with a pointer
to this structure. Drivers fill the rest of the structure or return an
<span class="ERRORCODE">EINVAL</span> error code when the index is out of bounds. To enumerate all modulators
applications shall begin at index zero, incrementing by one until the
driver returns <span class="ERRORCODE">EINVAL</span>.</p><p>Modulators have two writable properties, an audio
modulation set and the radio frequency. To change the modulated audio
subprograms, applications initialize the <code class="STRUCTFIELD">index</code> and <code class="STRUCTFIELD">txsubchans</code> fields and the
<code class="STRUCTFIELD">reserved</code> array and call the
<code class="CONSTANT">VIDIOC_S_MODULATOR</code> ioctl. Drivers may choose a
different audio modulation if the request cannot be satisfied. However
this is a write-only ioctl, it does not return the actual audio
modulation selected.</p><p>To change the radio frequency the <a href="#VIDIOC-G-FREQUENCY"><code class="CONSTANT">VIDIOC_S_FREQUENCY</code></a> ioctl
is available.</p><div class="TABLE"><a name="V4L2-MODULATOR"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_modulator</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">index</code></td><td>Identifies the modulator, set by the
application.</td></tr><tr><td>__u8</td><td><code class="STRUCTFIELD">name</code>[32]</td><td>Name of the modulator, a NUL-terminated ASCII
string. This information is intended for the user.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">capability</code></td><td>Modulator capability flags. No flags are defined
for this field, the tuner flags in struct&nbsp;<a href="#V4L2-TUNER">v4l2_tuner</a>
are used accordingly. The audio flags indicate the ability
to encode audio subprograms. They will <span class="emphasis"><i class="EMPHASIS">not</i></span>
change for example with the current video standard.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">rangelow</code></td><td>The lowest tunable frequency in units of 62.5
KHz, or if the <code class="STRUCTFIELD">capability</code> flag
<code class="CONSTANT">V4L2_TUNER_CAP_LOW</code> is set, in units of 62.5
Hz.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">rangehigh</code></td><td>The highest tunable frequency in units of 62.5
KHz, or if the <code class="STRUCTFIELD">capability</code> flag
<code class="CONSTANT">V4L2_TUNER_CAP_LOW</code> is set, in units of 62.5
Hz.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">txsubchans</code></td><td>With this field applications can determine how
audio sub-carriers shall be modulated. It contains a set of flags as
defined in <a href="#MODULATOR-TXSUBCHANS">Table 2</a>. Note the tuner
<code class="STRUCTFIELD">rxsubchans</code> flags are reused, but the
semantics are different. Video output devices are assumed to have an
analog or PCM audio input with 1-3 channels. The
<code class="STRUCTFIELD">txsubchans</code> flags select one or more
channels for modulation, together with some audio subprogram
indicator, for example a stereo pilot tone.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code>[4]</td><td>Reserved for future extensions. Drivers and
applications must set the array to zero.</td></tr></tbody></table></div><div class="TABLE"><a name="MODULATOR-TXSUBCHANS"></a><p><b>Table 2. Modulator Audio Transmission Flags</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_TUNER_SUB_MONO</code></td><td>0x0001</td><td>Modulate channel 1 as mono audio, when the input
has more channels, a down-mix of channel 1 and 2. This flag does not
combine with <code class="CONSTANT">V4L2_TUNER_SUB_STEREO</code> or
<code class="CONSTANT">V4L2_TUNER_SUB_LANG1</code>.</td></tr><tr><td><code class="CONSTANT">V4L2_TUNER_SUB_STEREO</code></td><td>0x0002</td><td>Modulate channel 1 and 2 as left and right
channel of a stereo audio signal. When the input has only one channel
or two channels and <code class="CONSTANT">V4L2_TUNER_SUB_SAP</code> is also
set, channel 1 is encoded as left and right channel. This flag does
not combine with <code class="CONSTANT">V4L2_TUNER_SUB_MONO </code> or
<code class="CONSTANT">V4L2_TUNER_SUB_LANG1</code>. When the driver does not
support stereo audio it shall fall back to mono.</td></tr><tr><td><code class="CONSTANT">V4L2_TUNER_SUB_LANG1</code></td><td>0x0008</td><td>Modulate channel 1 and 2 as primary and secondary
language of a bilingual audio signal. When the input has only one
channel it is used for both languages. It is not possible to encode
the primary or secondary language only. This flag does not combine
with <code class="CONSTANT">V4L2_TUNER_SUB_MONO </code> or
<code class="CONSTANT">V4L2_TUNER_SUB_STEREO</code>. If the hardware does not
support the respective audio matrix, or the current video standard
does not permit bilingual audio the
<code class="CONSTANT">VIDIOC_S_MODULATOR</code> ioctl shall return an <span class="ERRORCODE">EINVAL</span> error code
and the driver shall fall back to mono or stereo mode.</td></tr><tr><td><code class="CONSTANT">V4L2_TUNER_SUB_LANG2</code></td><td>0x0004</td><td>Same effect as
<code class="CONSTANT">V4L2_TUNER_SUB_LANG1</code>.</td></tr><tr><td><code class="CONSTANT">V4L2_TUNER_SUB_SAP</code></td><td>0x0004</td><td>When combined with <code class="CONSTANT">V4L2_TUNER_SUB_MONO</code> the first channel is encoded as mono audio, the last
channel as Second Audio Program. When the input has only one channel
it is used for both audio tracks. When the input has three channels
the mono track is a down-mix of channel 1 and 2. When combined with
<code class="CONSTANT">V4L2_TUNER_SUB_STEREO </code> channel 1 and 2 are
encoded as left and right stereo audio, channel 3 as Second Audio
Program. When the input has only two channels, the first is encoded as
left and right channel and the second as SAP. When the input has only
one channel it is used for all audio tracks. It is not possible to
encode a Second Audio Program only. This flag must combine with
<code class="CONSTANT">V4L2_TUNER_SUB_MONO</code> or
<code class="CONSTANT">V4L2_TUNER_SUB_STEREO</code>. If the hardware does not
support the respective audio matrix, or the current video standard
does not permit SAP the <code class="CONSTANT"> VIDIOC_S_MODULATOR</code> ioctl
shall return an <span class="ERRORCODE">EINVAL</span> error code and driver shall fall back to mono or stereo
mode.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN11598"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The struct&nbsp;<a href="#V4L2-MODULATOR">v4l2_modulator</a>
<code class="STRUCTFIELD">index</code> is out of bounds.</p></dd></dl></div></div><h1><a name="VIDIOC-G-OUTPUT"></a>ioctl VIDIOC_G_OUTPUT, VIDIOC_S_OUTPUT</h1><div class="REFNAMEDIV"><a name="AEN11616"></a><h2>Name</h2>VIDIOC_G_OUTPUT, VIDIOC_S_OUTPUT&nbsp;--&nbsp;Query or select the current video output</div><div class="REFSYNOPSISDIV"><a name="AEN11620"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN11621"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, int *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN11631"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_G_OUTPUT, VIDIOC_S_OUTPUT</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN11651"></a><h2>Description</h2><p>To query the current video output applications call the
<code class="CONSTANT">VIDIOC_G_OUTPUT</code> ioctl with a pointer to an integer
where the driver stores the number of the output, as in the
struct&nbsp;<a href="#V4L2-OUTPUT">v4l2_output</a> <code class="STRUCTFIELD">index</code> field. This ioctl
will fail only when there are no video outputs, returning the
<span class="ERRORCODE">EINVAL</span> error code.</p><p>To select a video output applications store the number of the
desired output in an integer and call the
<code class="CONSTANT">VIDIOC_S_OUTPUT</code> ioctl with a pointer to this integer.
Side effects are possible. For example outputs may support different
video standards, so the driver may implicitly switch the current
standard. It is good practice to select an output before querying or
negotiating any other parameters.</p><p>Information about video outputs is available using the
<a href="#VIDIOC-ENUMOUTPUT"><code class="CONSTANT">VIDIOC_ENUMOUTPUT</code></a> ioctl.</p></div><div class="REFSECT1"><a name="AEN11663"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The number of the video output is out of bounds, or
there are no video outputs at all and this ioctl is not
supported.</p></dd><dt><span class="ERRORCODE">EBUSY</span></dt><dd><p>I/O is in progress, the output cannot be
switched.</p></dd></dl></div></div><h1><a name="VIDIOC-G-PARM"></a>ioctl VIDIOC_G_PARM, VIDIOC_S_PARM</h1><div class="REFNAMEDIV"><a name="AEN11684"></a><h2>Name</h2>VIDIOC_G_PARM, VIDIOC_S_PARM&nbsp;--&nbsp;Get or set streaming parameters</div><div class="REFSYNOPSISDIV"><a name="AEN11688"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN11689"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, v4l2_streamparm *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN11699"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_G_PARM, VIDIOC_S_PARM</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN11719"></a><h2>Description</h2><p>The current video standard determines a nominal number of
frames per second. If less than this number of frames is to be
captured or output, applications can request frame skipping or
duplicating on the driver side. This is especially useful when using
the <code class="FUNCTION">read()</code> or <code class="FUNCTION">write()</code>, which
are not augmented by timestamps or sequence counters, and to avoid
unneccessary data copying.</p><p>Further these ioctls can be used to determine the number of
buffers used internally by a driver in read/write mode. For
implications see the section discussing the <a href="#FUNC-READ"><code class="FUNCTION">read()</code></a>
function.</p><p>To get and set the streaming parameters applications call
the <code class="CONSTANT">VIDIOC_G_PARM</code> and
<code class="CONSTANT">VIDIOC_S_PARM</code> ioctl, respectively. They take a
pointer to a struct <code class="STRUCTNAME">v4l2_streamparm</code> which
contains a union holding separate parameters for input and output
devices.</p><div class="TABLE"><a name="V4L2-STREAMPARM"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_streamparm</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="20%"><col title="C2" width="20%"><col title="C3" width="20%"><col title="C4" width="40%"></colgroup><tbody valign="TOP"><tr><td>enum&nbsp;<a href="#V4L2-BUF-TYPE">v4l2_buf_type</a></td><td><code class="STRUCTFIELD">type</code></td><td>&nbsp;</td><td>The buffer (stream) type, same as struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a>
<code class="STRUCTFIELD">type</code>, set by the application.</td></tr><tr><td>union</td><td><code class="STRUCTFIELD">parm</code></td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td>struct&nbsp;<a href="#V4L2-CAPTUREPARM">v4l2_captureparm</a></td><td><code class="STRUCTFIELD">capture</code></td><td>Parameters for capture devices, used when
<code class="STRUCTFIELD">type</code> is
<code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_CAPTURE</code>.</td></tr><tr><td>&nbsp;</td><td>struct&nbsp;<a href="#V4L2-OUTPUTPARM">v4l2_outputparm</a></td><td><code class="STRUCTFIELD">output</code></td><td>Parameters for output devices, used when
<code class="STRUCTFIELD">type</code> is
<code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_OUTPUT</code>.</td></tr><tr><td>&nbsp;</td><td>__u8</td><td><code class="STRUCTFIELD">raw_data</code>[200]</td><td>A place holder for future extensions and custom
(driver defined) buffer types <code class="CONSTANT">V4L2_BUF_TYPE_PRIVATE</code> and
higher.</td></tr></tbody></table></div><div class="TABLE"><a name="V4L2-CAPTUREPARM"></a><p><b>Table 2. struct <code class="STRUCTNAME">v4l2_captureparm</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">capability</code></td><td>See <a href="#PARM-CAPS">Table 4</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">capturemode</code></td><td>Set by drivers and applications, see <a href="#PARM-FLAGS">Table 5</a>.</td></tr><tr><td>struct&nbsp;<a href="#V4L2-FRACT">v4l2_fract</a></td><td><code class="STRUCTFIELD">timeperframe</code></td><td><p>This is is the desired period between
successive frames captured by the driver, in seconds. The
field is intended to skip frames on the driver side, saving I/O
bandwidth.</p><p>Applications store here the desired frame
period, drivers return the actual frame period, which must be greater
or equal to the nominal frame period determined by the current video
standard (struct&nbsp;<a href="#V4L2-STANDARD">v4l2_standard</a> <code class="STRUCTFIELD">frameperiod</code>
field). Changing the video standard (also implicitly by switching the
video input) may reset this parameter to the nominal frame period. To
reset manually applications can just set this field to
zero.</p><p>Drivers support this function only when they set the
<code class="CONSTANT">V4L2_CAP_TIMEPERFRAME</code> flag in the
<code class="STRUCTFIELD">capability</code> field.</p></td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">extendedmode</code></td><td>Custom (driver specific) streaming parameters. When
unused, applications and drivers must set this field to zero.
Applications using this field should check the driver name and
version, see <a href="#QUERYCAP">Section 1.2</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">readbuffers</code></td><td>Applications set this field to the desired number
of buffers used internally by the driver in <a href="#FUNC-READ"><code class="FUNCTION">read()</code></a> mode. Drivers
return the actual number of buffers. When an application requests zero
buffers, drivers should just return the current setting rather than
the minimum or an error code. For details see <a href="#RW">Section 3.1</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code>[4]</td><td>Reserved for future extensions. Drivers and
applications must set the array to zero.</td></tr></tbody></table></div><div class="TABLE"><a name="V4L2-OUTPUTPARM"></a><p><b>Table 3. struct <code class="STRUCTNAME">v4l2_outputparm</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">capability</code></td><td>See <a href="#PARM-CAPS">Table 4</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">outputmode</code></td><td>Set by drivers and applications, see <a href="#PARM-FLAGS">Table 5</a>.</td></tr><tr><td>struct&nbsp;<a href="#V4L2-FRACT">v4l2_fract</a></td><td><code class="STRUCTFIELD">timeperframe</code></td><td>This is is the desired period between
successive frames output by the driver, in seconds.</td></tr><tr><td colspan="3"><p>The field is intended to
repeat frames on the driver side in <a href="#FUNC-WRITE"><code class="FUNCTION">write()</code></a> mode (in streaming
mode timestamps can be used to throttle the output), saving I/O
bandwidth.</p><p>Applications store here the desired frame
period, drivers return the actual frame period, which must be greater
or equal to the nominal frame period determined by the current video
standard (struct&nbsp;<a href="#V4L2-STANDARD">v4l2_standard</a> <code class="STRUCTFIELD">frameperiod</code>
field). Changing the video standard (also implicitly by switching the
video output) may reset this parameter to the nominal frame period. To
reset manually applications can just set this field to
zero.</p><p>Drivers support this function only when they set the
<code class="CONSTANT">V4L2_CAP_TIMEPERFRAME</code> flag in the
<code class="STRUCTFIELD">capability</code> field.</p></td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">extendedmode</code></td><td>Custom (driver specific) streaming parameters. When
unused, applications and drivers must set this field to zero.
Applications using this field should check the driver name and
version, see <a href="#QUERYCAP">Section 1.2</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">writebuffers</code></td><td>Applications set this field to the desired number
of buffers used internally by the driver in
<code class="FUNCTION">write()</code> mode. Drivers return the actual number of
buffers. When an application requests zero buffers, drivers should
just return the current setting rather than the minimum or an error
code. For details see <a href="#RW">Section 3.1</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code>[4]</td><td>Reserved for future extensions. Drivers and
applications must set the array to zero.</td></tr></tbody></table></div><div class="TABLE"><a name="PARM-CAPS"></a><p><b>Table 4. Streaming Parameters Capabilites</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_CAP_TIMEPERFRAME</code></td><td>0x1000</td><td>The frame skipping/repeating controlled by the
<code class="STRUCTFIELD">timeperframe</code> field is supported.</td></tr></tbody></table></div><div class="TABLE"><a name="PARM-FLAGS"></a><p><b>Table 5. Capture Parameters Flags</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_MODE_HIGHQUALITY</code></td><td>0x0001</td><td><p>High quality imaging mode. High quality mode
is intended for still imaging applications. The idea is to get the
best possible image quality that the hardware can deliver. It is not
defined how the driver writer may achieve that; it will depend on the
hardware and the ingenuity of the driver writer. High quality mode is
a different mode from the the regular motion video capture modes. In
high quality mode:</p><p></p><ul><li><p>The driver may be able to capture higher
resolutions than for motion capture.</p></li><li><p>The driver may support fewer pixel formats
than motion capture (eg; true color).</p></li><li><p>The driver may capture and arithmetically
combine multiple successive fields or frames to remove color edge
artifacts and reduce the noise in the video data.</p></li><li><p>The driver may capture images in slices like
a scanner in order to handle larger format images than would otherwise
be possible. </p></li><li><p>An image capture operation may be
significantly slower than motion capture. </p></li><li><p>Moving objects in the image might have
excessive motion blur. </p></li><li><p>Capture might only work through the
<code class="FUNCTION">read()</code> call.</p></li></ul><p></p></td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN11934"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>This ioctl is not supported.</p></dd></dl></div></div><h1><a name="VIDIOC-G-PRIORITY"></a>ioctl VIDIOC_G_PRIORITY, VIDIOC_S_PRIORITY</h1><div class="REFNAMEDIV"><a name="AEN11950"></a><h2>Name</h2>VIDIOC_G_PRIORITY, VIDIOC_S_PRIORITY&nbsp;--&nbsp;Query or request the access priority associated with a
file descriptor</div><div class="REFSYNOPSISDIV"><a name="AEN11954"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN11955"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, enum v4l2_priority *argp);</code></p><p></p></div><div class="FUNCSYNOPSIS"><p></p><a name="AEN11965"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, const enum v4l2_priority *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN11975"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_G_PRIORITY, VIDIOC_S_PRIORITY</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p>Pointer to an enum v4l2_priority type.</p></dd></dl></div></div><div class="REFSECT1"><a name="AEN11995"></a><h2>Description</h2><p>To query the current access priority
applications call the <code class="CONSTANT">VIDIOC_G_PRIORITY</code> ioctl
with a pointer to an enum v4l2_priority variable where the driver stores
the current priority.</p><p>To request an access priority applications store the
desired priority in an enum v4l2_priority variable and call
<code class="CONSTANT">VIDIOC_S_PRIORITY</code> ioctl with a pointer to this
variable.</p><div class="TABLE"><a name="V4L2-PRIORITY"></a><p><b>Table 1. enum v4l2_priority</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_PRIORITY_UNSET</code></td><td>0</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_PRIORITY_BACKGROUND</code></td><td>1</td><td>Lowest priority, usually applications running in
background, for example monitoring VBI transmissions. A proxy
application running in user space will be necessary if multiple
applications want to read from a device at this priority.</td></tr><tr><td><code class="CONSTANT">V4L2_PRIORITY_INTERACTIVE</code></td><td>2</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_PRIORITY_DEFAULT</code></td><td>2</td><td>Medium priority, usually applications started and
interactively controlled by the user. For example TV viewers, Teletext
browsers, or just "panel" applications to change the channel or video
controls. This is the default priority unless an application requests
another.</td></tr><tr><td><code class="CONSTANT">V4L2_PRIORITY_RECORD</code></td><td>3</td><td>Highest priority. Only one file descriptor can have
this priority, it blocks any other fd from changing device properties.
Usually applications which must not be interrupted, like video
recording.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN12034"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The requested priority value is invalid, or the
driver does not support access priorities.</p></dd><dt><span class="ERRORCODE">EBUSY</span></dt><dd><p>Another application already requested higher
priority.</p></dd></dl></div></div><h1><a name="VIDIOC-G-SLICED-VBI-CAP"></a>ioctl VIDIOC_G_SLICED_VBI_CAP</h1><div class="REFNAMEDIV"><a name="AEN12055"></a><h2>Name</h2>VIDIOC_G_SLICED_VBI_CAP&nbsp;--&nbsp;Query sliced VBI capabilities</div><div class="REFSYNOPSISDIV"><a name="AEN12058"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN12059"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_sliced_vbi_cap *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN12069"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_G_SLICED_VBI_CAP</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN12089"></a><h2>Description</h2><p>To find out which data services are supported by a sliced
VBI capture or output device, applications initialize the
<code class="STRUCTFIELD">type</code> field of a struct&nbsp;<a href="#V4L2-SLICED-VBI-CAP">v4l2_sliced_vbi_cap</a>,
clear the <code class="STRUCTFIELD">reserved</code> array and
call the <code class="CONSTANT">VIDIOC_G_SLICED_VBI_CAP</code> ioctl. The
driver fills in the remaining fields or returns an <span class="ERRORCODE">EINVAL</span> error code if the
sliced VBI API is unsupported or <code class="STRUCTFIELD">type</code>
is invalid.</p><p>Note the <code class="STRUCTFIELD">type</code> field was added,
and the ioctl changed from read-only to write-read, in Linux 2.6.19.</p><div class="TABLE"><a name="V4L2-SLICED-VBI-CAP"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_sliced_vbi_cap</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="17%"><col title="C4" width="17%"><col title="C5" width="17%"></colgroup><tbody valign="TOP"><tr><td>__u16</td><td><code class="STRUCTFIELD">service_set</code></td><td colspan="3">A set of all data services
supported by the driver. Equal to the union of all elements of the
<code class="STRUCTFIELD">service_lines </code> array.</td></tr><tr><td>__u16</td><td><code class="STRUCTFIELD">service_lines</code>[2][24]</td><td colspan="3">Each element of this array
contains a set of data services the hardware can look for or insert
into a particular scan line. Data services are defined in <a href="#VBI-SERVICES">Table 2</a>. Array indices map to ITU-R
line numbers (see also <a href="#VBI-525">Figure 4-2</a> and <a href="#VBI-625">Figure 4-3</a>) as follows:</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>Element</td><td>525 line systems</td><td>625 line systems</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td><code class="STRUCTFIELD">service_lines</code>[0][1]</td><td align="CENTER">1</td><td align="CENTER">1</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td><code class="STRUCTFIELD">service_lines</code>[0][23]</td><td align="CENTER">23</td><td align="CENTER">23</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td><code class="STRUCTFIELD">service_lines</code>[1][1]</td><td align="CENTER">264</td><td align="CENTER">314</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td><code class="STRUCTFIELD">service_lines</code>[1][23]</td><td align="CENTER">286</td><td align="CENTER">336</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td colspan="3">The number of VBI lines the
hardware can capture or output per frame, or the number of services it
can identify on a given line may be limited. For example on PAL line
16 the hardware may be able to look for a VPS or Teletext signal, but
not both at the same time. Applications can learn about these limits
using the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl as described in <a href="#SLICED">Section 4.8</a>.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td colspan="3">Drivers must set
<code class="STRUCTFIELD">service_lines</code>[0][0] and
<code class="STRUCTFIELD">service_lines</code>[1][0] to zero.</td></tr><tr><td>enum&nbsp;<a href="#V4L2-BUF-TYPE">v4l2_buf_type</a></td><td><code class="STRUCTFIELD">type</code></td><td>Type of the data stream, see <a href="#V4L2-BUF-TYPE">Table 3-2</a>. Should be
<code class="CONSTANT">V4L2_BUF_TYPE_SLICED_VBI_CAPTURE</code> or
<code class="CONSTANT">V4L2_BUF_TYPE_SLICED_VBI_OUTPUT</code>.</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code>[3]</td><td colspan="3">This array is reserved for future
extensions. Applications and drivers must set it to zero.</td></tr></tbody></table></div><div class="TABLE"><a name="VBI-SERVICES"></a><p><b>Table 2. Sliced VBI services</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="12%"><col title="C3" width="12%"><col title="C4" width="25%"><col title="C5" width="25%"></colgroup><thead><tr><th>Symbol</th><th>Value</th><th>Reference</th><th>Lines, usually</th><th>Payload</th></tr></thead><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_SLICED_TELETEXT_B</code> (Teletext
System B)</td><td>0x0001</td><td><a href="#ETS300706"><abbr class="ABBREV">ETS&nbsp;300&nbsp;706</abbr></a>, <a href="#ITU653"><abbr class="ABBREV">ITU&nbsp;BT.653</abbr></a></td><td>PAL/SECAM line 7-22, 320-335 (second field 7-22)</td><td>Last 42 of the 45 byte Teletext packet, that is
without clock run-in and framing code, lsb first transmitted.</td></tr><tr><td><code class="CONSTANT">V4L2_SLICED_VPS</code></td><td>0x0400</td><td><a href="#ETS300231"><abbr class="ABBREV">ETS&nbsp;300&nbsp;231</abbr></a></td><td>PAL line 16</td><td>Byte number 3 to 15 according to Figure 9 of
ETS&nbsp;300&nbsp;231, lsb first transmitted.</td></tr><tr><td><code class="CONSTANT">V4L2_SLICED_CAPTION_525</code></td><td>0x1000</td><td><a href="#EIA608"><abbr class="ABBREV">EIA&nbsp;608-B</abbr></a></td><td>NTSC line 21, 284 (second field 21)</td><td>Two bytes in transmission order, including parity
bit, lsb first transmitted.</td></tr><tr><td><code class="CONSTANT">V4L2_SLICED_WSS_625</code></td><td>0x4000</td><td><a href="#EN300294"><abbr class="ABBREV">EN&nbsp;300&nbsp;294</abbr></a>, <a href="#ITU1119"><abbr class="ABBREV">ITU&nbsp;BT.1119</abbr></a></td><td>PAL/SECAM line 23</td><td><pre class="SCREEN">Byte        0                 1
     msb         lsb  msb           lsb
Bit  7 6 5 4 3 2 1 0  x x 13 12 11 10 9</pre></td></tr><tr><td><code class="CONSTANT">V4L2_SLICED_VBI_525</code></td><td>0x1000</td><td colspan="3">Set of services applicable to 525
line systems.</td></tr><tr><td><code class="CONSTANT">V4L2_SLICED_VBI_625</code></td><td>0x4401</td><td colspan="3">Set of services applicable to 625
line systems.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN12252"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The device does not support sliced VBI capturing or
output, or the value in the <code class="STRUCTFIELD">type</code> field is
wrong.</p></dd></dl></div></div><h1><a name="VIDIOC-G-STD"></a>ioctl VIDIOC_G_STD, VIDIOC_S_STD</h1><div class="REFNAMEDIV"><a name="AEN12269"></a><h2>Name</h2>VIDIOC_G_STD, VIDIOC_S_STD&nbsp;--&nbsp;Query or select the video standard of the current input</div><div class="REFSYNOPSISDIV"><a name="AEN12273"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN12274"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, v4l2_std_id
*argp);</code></p><p></p></div><div class="FUNCSYNOPSIS"><p></p><a name="AEN12284"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, const v4l2_std_id
*argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN12294"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_G_STD, VIDIOC_S_STD</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN12314"></a><h2>Description</h2><p>To query and select the current video standard applications
use the <code class="CONSTANT">VIDIOC_G_STD</code> and <code class="CONSTANT">VIDIOC_S_STD</code> ioctls which take a pointer to a
<a href="#V4L2-STD-ID">v4l2_std_id</a> type as argument. <code class="CONSTANT">VIDIOC_G_STD</code> can
return a single flag or a set of flags as in struct&nbsp;<a href="#V4L2-STANDARD">v4l2_standard</a> field
<code class="STRUCTFIELD">id</code>. The flags must be unambiguous such
that they appear in only one enumerated <code class="STRUCTNAME">v4l2_standard</code> structure.</p><p><code class="CONSTANT">VIDIOC_S_STD</code> accepts one or more
flags, being a write-only ioctl it does not return the actual new standard as
<code class="CONSTANT">VIDIOC_G_STD</code> does. When no flags are given or
the current input does not support the requested standard the driver
returns an <span class="ERRORCODE">EINVAL</span> error code. When the standard set is ambiguous drivers may
return <span class="ERRORCODE">EINVAL</span> or choose any of the requested
standards.</p></div><div class="REFSECT1"><a name="AEN12329"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>This ioctl is not supported, or the
<code class="CONSTANT">VIDIOC_S_STD</code> parameter was unsuitable.</p></dd></dl></div></div><h1><a name="VIDIOC-G-TUNER"></a>ioctl VIDIOC_G_TUNER, VIDIOC_S_TUNER</h1><div class="REFNAMEDIV"><a name="AEN12346"></a><h2>Name</h2>VIDIOC_G_TUNER, VIDIOC_S_TUNER&nbsp;--&nbsp;Get or set tuner attributes</div><div class="REFSYNOPSISDIV"><a name="AEN12350"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN12351"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_tuner
*argp);</code></p><p></p></div><div class="FUNCSYNOPSIS"><p></p><a name="AEN12361"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, const struct v4l2_tuner
*argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN12371"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_G_TUNER, VIDIOC_S_TUNER</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN12391"></a><h2>Description</h2><p>To query the attributes of a tuner applications initialize the
<code class="STRUCTFIELD">index</code> field and zero out the
<code class="STRUCTFIELD">reserved</code> array of a struct&nbsp;<a href="#V4L2-TUNER">v4l2_tuner</a> and call the
<code class="CONSTANT">VIDIOC_G_TUNER</code> ioctl with a pointer to this
structure. Drivers fill the rest of the structure or return an
<span class="ERRORCODE">EINVAL</span> error code when the index is out of bounds. To enumerate all tuners
applications shall begin at index zero, incrementing by one until the
driver returns <span class="ERRORCODE">EINVAL</span>.</p><p>Tuners have two writable properties, the audio mode and
the radio frequency. To change the audio mode, applications initialize
the <code class="STRUCTFIELD">index</code>,
<code class="STRUCTFIELD">audmode</code> and
<code class="STRUCTFIELD">reserved</code> fields and call the
<code class="CONSTANT">VIDIOC_S_TUNER</code> ioctl. This will
<span class="emphasis"><i class="EMPHASIS">not</i></span> change the current tuner, which is determined
by the current video input. Drivers may choose a different audio mode
if the requested mode is invalid or unsupported. Since this is a
write-only ioctl, it does not return the actually
selected audio mode.</p><p>To change the radio frequency the <a href="#VIDIOC-G-FREQUENCY"><code class="CONSTANT">VIDIOC_S_FREQUENCY</code></a> ioctl
is available.</p><div class="TABLE"><a name="V4L2-TUNER"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_tuner</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="25%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">index</code></td><td colspan="2">Identifies the tuner, set by the
application.</td></tr><tr><td>__u8</td><td><code class="STRUCTFIELD">name</code>[32]</td><td colspan="2"><p>Name of the tuner, a
NUL-terminated ASCII string. This information is intended for the
user.</p></td></tr><tr><td>enum&nbsp;<a href="#V4L2-TUNER-TYPE">v4l2_tuner_type</a></td><td><code class="STRUCTFIELD">type</code></td><td colspan="2">Type of the tuner, see <a href="#V4L2-TUNER-TYPE">Table 2</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">capability</code></td><td colspan="2"><p>Tuner capability flags, see
<a href="#TUNER-CAPABILITY">Table 3</a>. Audio flags indicate the ability
to decode audio subprograms. They will <span class="emphasis"><i class="EMPHASIS">not</i></span>
change, for example with the current video standard.</p><p>When
the structure refers to a radio tuner only the
<code class="CONSTANT">V4L2_TUNER_CAP_LOW</code> and
<code class="CONSTANT">V4L2_TUNER_CAP_STEREO</code> flags can be
set.</p></td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">rangelow</code></td><td colspan="2">The lowest tunable frequency in
units of 62.5 kHz, or if the <code class="STRUCTFIELD">capability</code>
flag <code class="CONSTANT">V4L2_TUNER_CAP_LOW</code> is set, in units of 62.5
Hz.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">rangehigh</code></td><td colspan="2">The highest tunable frequency in
units of 62.5 kHz, or if the <code class="STRUCTFIELD">capability</code>
flag <code class="CONSTANT">V4L2_TUNER_CAP_LOW</code> is set, in units of 62.5
Hz.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">rxsubchans</code></td><td colspan="2"><p>Some tuners or audio
decoders can determine the received audio subprograms by analyzing
audio carriers, pilot tones or other indicators. To pass this
information drivers set flags defined in <a href="#TUNER-RXSUBCHANS">Table 4</a> in this field. For
example:</p></td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td><code class="CONSTANT">V4L2_TUNER_SUB_MONO</code></td><td>receiving mono audio</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td><code class="CONSTANT">STEREO | SAP</code></td><td>receiving stereo audio and a secondary audio
program</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td><code class="CONSTANT">MONO | STEREO</code></td><td>receiving mono or stereo audio, the hardware cannot
distinguish</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td><code class="CONSTANT">LANG1 | LANG2</code></td><td>receiving bilingual audio</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td><code class="CONSTANT">MONO | STEREO | LANG1 | LANG2</code></td><td>receiving mono, stereo or bilingual
audio</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td colspan="2"><p>When the
<code class="CONSTANT">V4L2_TUNER_CAP_STEREO</code>,
<code class="CONSTANT">_LANG1</code>, <code class="CONSTANT">_LANG2</code> or
<code class="CONSTANT">_SAP</code> flag is cleared in the
<code class="STRUCTFIELD">capability</code> field, the corresponding
<code class="CONSTANT">V4L2_TUNER_SUB_</code> flag must not be set
here.</p><p>This field is valid only if this is the tuner of the
current video input, or when the structure refers to a radio
tuner.</p></td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">audmode</code></td><td colspan="2"><p>The selected audio mode, see
<a href="#TUNER-AUDMODE">Table 5</a> for valid values. The audio mode does
not affect audio subprogram detection, and like a <a href="#CONTROL">control</a> it does not automatically change
unless the requested mode is invalid or unsupported. See <a href="#TUNER-MATRIX">Table 6</a> for possible results when
the selected and received audio programs do not
match.</p><p>Currently this is the only field of struct
<code class="STRUCTNAME">v4l2_tuner</code> applications can
change.</p></td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">signal</code></td><td colspan="2">The signal strength if known, ranging
from 0 to 65535. Higher values indicate a better signal.</td></tr><tr><td>__s32</td><td><code class="STRUCTFIELD">afc</code></td><td colspan="2">Automatic frequency control: When the
<code class="STRUCTFIELD">afc</code> value is negative, the frequency is too
low, when positive too high.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code>[4]</td><td colspan="2">Reserved for future extensions. Drivers and
applications must set the array to zero.</td></tr></tbody></table></div><div class="TABLE"><a name="V4L2-TUNER-TYPE"></a><p><b>Table 2. enum v4l2_tuner_type</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_TUNER_RADIO</code></td><td>1</td><td>&nbsp;</td></tr><tr><td><code class="CONSTANT">V4L2_TUNER_ANALOG_TV</code></td><td>2</td><td>&nbsp;</td></tr></tbody></table></div><div class="TABLE"><a name="TUNER-CAPABILITY"></a><p><b>Table 3. Tuner and Modulator Capability Flags</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_TUNER_CAP_LOW</code></td><td>0x0001</td><td>When set, tuning frequencies are expressed in units of
62.5&nbsp;Hz, otherwise in units of 62.5&nbsp;kHz.</td></tr><tr><td><code class="CONSTANT">V4L2_TUNER_CAP_NORM</code></td><td>0x0002</td><td>This is a multi-standard tuner; the video standard
can or must be switched. (B/G PAL tuners for example are typically not
      considered multi-standard because the video standard is automatically
      determined from the frequency band.) The set of supported video
      standards is available from the struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a> pointing to this tuner,
      see the description of ioctl <a href="#VIDIOC-ENUMINPUT"><code class="CONSTANT">VIDIOC_ENUMINPUT</code></a> for details. Only
      <code class="CONSTANT">V4L2_TUNER_ANALOG_TV</code> tuners can have this capability.</td></tr><tr><td><code class="CONSTANT">V4L2_TUNER_CAP_STEREO</code></td><td>0x0010</td><td>Stereo audio reception is supported.</td></tr><tr><td><code class="CONSTANT">V4L2_TUNER_CAP_LANG1</code></td><td>0x0040</td><td>Reception of the primary language of a bilingual
audio program is supported. Bilingual audio is a feature of
two-channel systems, transmitting the primary language monaural on the
main audio carrier and a secondary language monaural on a second
carrier. Only
      <code class="CONSTANT">V4L2_TUNER_ANALOG_TV</code> tuners can have this capability.</td></tr><tr><td><code class="CONSTANT">V4L2_TUNER_CAP_LANG2</code></td><td>0x0020</td><td>Reception of the secondary language of a bilingual
audio program is supported. Only
      <code class="CONSTANT">V4L2_TUNER_ANALOG_TV</code> tuners can have this capability.</td></tr><tr><td><code class="CONSTANT">V4L2_TUNER_CAP_SAP</code></td><td>0x0020</td><td><p>Reception of a secondary audio program is
supported. This is a feature of the BTSC system which accompanies the
NTSC video standard. Two audio carriers are available for mono or
stereo transmissions of a primary language, and an independent third
carrier for a monaural secondary language. Only
      <code class="CONSTANT">V4L2_TUNER_ANALOG_TV</code> tuners can have this capability.</p><p>Note the
<code class="CONSTANT">V4L2_TUNER_CAP_LANG2</code> and
<code class="CONSTANT">V4L2_TUNER_CAP_SAP</code> flags are synonyms.
<code class="CONSTANT">V4L2_TUNER_CAP_SAP</code> applies when the tuner
supports the <code class="CONSTANT">V4L2_STD_NTSC_M</code> video
standard.</p></td></tr></tbody></table></div><div class="TABLE"><a name="TUNER-RXSUBCHANS"></a><p><b>Table 4. Tuner Audio Reception Flags</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_TUNER_SUB_MONO</code></td><td>0x0001</td><td>The tuner receives a mono audio signal.</td></tr><tr><td><code class="CONSTANT">V4L2_TUNER_SUB_STEREO</code></td><td>0x0002</td><td>The tuner receives a stereo audio signal.</td></tr><tr><td><code class="CONSTANT">V4L2_TUNER_SUB_LANG1</code></td><td>0x0008</td><td>The tuner receives the primary language of a
bilingual audio signal. Drivers must clear this flag when the current
video standard is <code class="CONSTANT">V4L2_STD_NTSC_M</code>.</td></tr><tr><td><code class="CONSTANT">V4L2_TUNER_SUB_LANG2</code></td><td>0x0004</td><td>The tuner receives the secondary language of a
bilingual audio signal (or a second audio program).</td></tr><tr><td><code class="CONSTANT">V4L2_TUNER_SUB_SAP</code></td><td>0x0004</td><td>The tuner receives a Second Audio Program. Note the
<code class="CONSTANT">V4L2_TUNER_SUB_LANG2</code> and
<code class="CONSTANT">V4L2_TUNER_SUB_SAP</code> flags are synonyms. The
<code class="CONSTANT">V4L2_TUNER_SUB_SAP</code> flag applies when the
current video standard is <code class="CONSTANT">V4L2_STD_NTSC_M</code>.</td></tr></tbody></table></div><div class="TABLE"><a name="TUNER-AUDMODE"></a><p><b>Table 5. Tuner Audio Modes</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_TUNER_MODE_MONO</code></td><td>0</td><td>Play mono audio. When the tuner receives a stereo
signal this a down-mix of the left and right channel. When the tuner
receives a bilingual or SAP signal this mode selects the primary
language.</td></tr><tr><td><code class="CONSTANT">V4L2_TUNER_MODE_STEREO</code></td><td>1</td><td><p>Play stereo audio. When the tuner receives
bilingual audio it may play different languages on the left and right
channel or the primary language on both channels. behave as in mono
mode.</p><p>Playing different languages in this mode is
deprecated. New drivers should do this only in
<code class="CONSTANT">MODE_LANG1_LANG2</code>.</p><p>When the tuner
receives no stereo signal or does not support stereo reception the
driver shall fall back to <code class="CONSTANT">MODE_MONO</code>.</p></td></tr><tr><td><code class="CONSTANT">V4L2_TUNER_MODE_LANG1</code></td><td>3</td><td>Play the primary language, mono or stereo. Only
<code class="CONSTANT">V4L2_TUNER_ANALOG_TV</code> tuners support this
mode.</td></tr><tr><td><code class="CONSTANT">V4L2_TUNER_MODE_LANG2</code></td><td>2</td><td>Play the secondary language, mono. When the tuner
receives no bilingual audio or SAP, or their reception is not
supported the driver shall fall back to mono or stereo mode. Only
<code class="CONSTANT">V4L2_TUNER_ANALOG_TV</code> tuners support this
mode.</td></tr><tr><td><code class="CONSTANT">V4L2_TUNER_MODE_SAP</code></td><td>2</td><td>Play the Second Audio Program. When the tuner
receives no bilingual audio or SAP, or their reception is not
supported the driver shall fall back to mono or stereo mode. Only
<code class="CONSTANT">V4L2_TUNER_ANALOG_TV</code> tuners support this mode.
Note the <code class="CONSTANT">V4L2_TUNER_MODE_LANG2</code> and
<code class="CONSTANT">V4L2_TUNER_MODE_SAP</code> are synonyms.</td></tr><tr><td><code class="CONSTANT">V4L2_TUNER_MODE_LANG1_LANG2</code></td><td>4</td><td>Play the primary language on the left channel, the
secondary language on the right channel. When the tuner receives no
bilingual audio or SAP, it shall fall back to
<code class="CONSTANT">MODE_LANG1</code> or <code class="CONSTANT">MODE_MONO</code>.
Only <code class="CONSTANT">V4L2_TUNER_ANALOG_TV</code> tuners support this
mode.</td></tr></tbody></table></div><div class="TABLE"><a name="TUNER-MATRIX"></a><p><b>Table 6. Tuner Audio Matrix</b></p><table frame="border" class="CALSTABLE" border="1" width="100%"><colgroup><col align="LEFT" width="20%"><col title="C2" width="20%"><col width="20%"><col width="20%"><col><col title="C6" width="20%"></colgroup><thead><tr><th>&nbsp;</th><th colspan="5" align="CENTER">Selected
<code class="CONSTANT">V4L2_TUNER_MODE_</code></th></tr><tr><th>Received <code class="CONSTANT">V4L2_TUNER_SUB_</code></th><th><code class="CONSTANT">MONO</code></th><th><code class="CONSTANT">STEREO</code></th><th><code class="CONSTANT">LANG1</code></th><th><code class="CONSTANT">LANG2 = SAP</code></th><th><code class="CONSTANT">LANG1_LANG2</code><a name="AEN12723" href="#FTN.AEN12723"><span class="footnote">[a]</span></a></th></tr></thead><tbody valign="TOP"><tr><td><code class="CONSTANT">MONO</code></td><td>Mono</td><td>Mono/Mono</td><td>Mono</td><td>Mono</td><td>Mono/Mono</td></tr><tr><td><code class="CONSTANT">MONO | SAP</code></td><td>Mono</td><td>Mono/Mono</td><td>Mono</td><td>SAP</td><td>Mono/SAP (preferred) or Mono/Mono</td></tr><tr><td><code class="CONSTANT">STEREO</code></td><td>L+R</td><td>L/R</td><td>Stereo L/R (preferred) or Mono L+R</td><td>Stereo L/R (preferred) or Mono L+R</td><td>L/R (preferred) or L+R/L+R</td></tr><tr><td><code class="CONSTANT">STEREO | SAP</code></td><td>L+R</td><td>L/R</td><td>Stereo L/R (preferred) or Mono L+R</td><td>SAP</td><td>L+R/SAP (preferred) or L/R or L+R/L+R</td></tr><tr><td><code class="CONSTANT">LANG1 | LANG2</code></td><td>Language&nbsp;1</td><td>Lang1/Lang2 (deprecated<a name="AEN12763" href="#FTN.AEN12763"><span class="footnote">[b]</span></a>) or
Lang1/Lang1</td><td>Language&nbsp;1</td><td>Language&nbsp;2</td><td>Lang1/Lang2 (preferred) or Lang1/Lang1</td></tr></tbody><tbody><tr><td colspan="6">Notes:<br><a name="FTN.AEN12723">a. </a>This 
mode has been added in Linux 2.6.17 and may not be supported by older
drivers.<br><a name="FTN.AEN12763">b. </a>Playback of
both languages in <code class="CONSTANT">MODE_STEREO</code> is deprecated. In
the future drivers should produce only the primary language in this
mode. Applications should request
<code class="CONSTANT">MODE_LANG1_LANG2</code> to record both languages or a
stereo signal.<br></td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN12770"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The struct&nbsp;<a href="#V4L2-TUNER">v4l2_tuner</a> <code class="STRUCTFIELD">index</code> is
out of bounds.</p></dd></dl></div></div><h1><a name="VIDIOC-LOG-STATUS"></a>ioctl VIDIOC_LOG_STATUS</h1><div class="REFNAMEDIV"><a name="AEN12788"></a><h2>Name</h2>VIDIOC_LOG_STATUS&nbsp;--&nbsp;Log driver status information</div><div class="REFSYNOPSISDIV"><a name="AEN12791"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN12792"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN12800"></a><h2>Description</h2><p>As the video/audio devices become more complicated it
becomes harder to debug problems. When this ioctl is called the driver
will output the current device status to the kernel log. This is
particular useful when dealing with problems like no sound, no video
and incorrectly tuned channels. Also many modern devices autodetect
video and audio standards and this ioctl will report what the device
thinks what the standard is. Mismatches may give an indication where
the problem is.</p><p>This ioctl is optional and not all drivers support it. It
was introduced in Linux 2.6.15.</p></div><div class="REFSECT1"><a name="AEN12804"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The driver does not support this ioctl.</p></dd></dl></div></div><h1><a name="VIDIOC-OVERLAY"></a>ioctl VIDIOC_OVERLAY</h1><div class="REFNAMEDIV"><a name="AEN12820"></a><h2>Name</h2>VIDIOC_OVERLAY&nbsp;--&nbsp;Start or stop video overlay</div><div class="REFSYNOPSISDIV"><a name="AEN12823"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN12824"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, const int *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN12834"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_OVERLAY</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN12854"></a><h2>Description</h2><p>This ioctl is part of the <a href="#OVERLAY">video
    overlay</a> I/O method. Applications call
    <code class="CONSTANT">VIDIOC_OVERLAY</code> to start or stop the
    overlay. It takes a pointer to an integer which must be set to
    zero by the application to stop overlay, to one to start.</p><p>Drivers do not support <a href="#VIDIOC-STREAMON"><code class="CONSTANT">VIDIOC_STREAMON</code></a> or
<a href="#VIDIOC-STREAMON"><code class="CONSTANT">VIDIOC_STREAMOFF</code></a> with <code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_OVERLAY</code>.</p></div><div class="REFSECT1"><a name="AEN12865"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>Video overlay is not supported, or the
parameters have not been set up. See <a href="#OVERLAY">Section 4.2</a> for the necessary steps.</p></dd></dl></div></div><h1><a name="VIDIOC-QBUF"></a>ioctl VIDIOC_QBUF, VIDIOC_DQBUF</h1><div class="REFNAMEDIV"><a name="AEN12882"></a><h2>Name</h2>VIDIOC_QBUF, VIDIOC_DQBUF&nbsp;--&nbsp;Exchange a buffer with the driver</div><div class="REFSYNOPSISDIV"><a name="AEN12886"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN12887"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_buffer *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN12897"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_QBUF, VIDIOC_DQBUF</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN12917"></a><h2>Description</h2><p>Applications call the <code class="CONSTANT">VIDIOC_QBUF</code> ioctl
to enqueue an empty (capturing) or filled (output) buffer in the
driver's incoming queue. The semantics depend on the selected I/O
method.</p><p>To enqueue a <a href="#MMAP">memory mapped</a>
buffer applications set the <code class="STRUCTFIELD">type</code> field of a
struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a> to the same buffer type as previously struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a>
<code class="STRUCTFIELD">type</code> and struct&nbsp;<a href="#V4L2-REQUESTBUFFERS">v4l2_requestbuffers</a>
<code class="STRUCTFIELD">type</code>, the <code class="STRUCTFIELD">memory</code>
field to <code class="CONSTANT">V4L2_MEMORY_MMAP</code> and the
<code class="STRUCTFIELD">index</code> field. Valid index numbers range from
zero to the number of buffers allocated with <a href="#VIDIOC-REQBUFS"><code class="CONSTANT">VIDIOC_REQBUFS</code></a>
(struct&nbsp;<a href="#V4L2-REQUESTBUFFERS">v4l2_requestbuffers</a> <code class="STRUCTFIELD">count</code>) minus one. The
contents of the struct <code class="STRUCTNAME">v4l2_buffer</code> returned
by a <a href="#VIDIOC-QUERYBUF"><code class="CONSTANT">VIDIOC_QUERYBUF</code></a> ioctl will do as well. When the buffer is
intended for output (<code class="STRUCTFIELD">type</code> is
<code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_OUTPUT</code> or
<code class="CONSTANT">V4L2_BUF_TYPE_VBI_OUTPUT</code>) applications must also
initialize the <code class="STRUCTFIELD">bytesused</code>,
<code class="STRUCTFIELD">field</code> and
<code class="STRUCTFIELD">timestamp</code> fields. See <a href="#BUFFER">Section 3.5</a> for details. When
<code class="CONSTANT">VIDIOC_QBUF</code> is called with a pointer to this
structure the driver sets the
<code class="CONSTANT">V4L2_BUF_FLAG_MAPPED</code> and
<code class="CONSTANT">V4L2_BUF_FLAG_QUEUED</code> flags and clears the
<code class="CONSTANT">V4L2_BUF_FLAG_DONE</code> flag in the
<code class="STRUCTFIELD">flags</code> field, or it returns an
<span class="ERRORCODE">EINVAL</span> error code.</p><p>To enqueue a <a href="#USERP">user pointer</a>
buffer applications set the <code class="STRUCTFIELD">type</code> field of a
struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a> to the same buffer type as previously struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a>
<code class="STRUCTFIELD">type</code> and struct&nbsp;<a href="#V4L2-REQUESTBUFFERS">v4l2_requestbuffers</a>
<code class="STRUCTFIELD">type</code>, the <code class="STRUCTFIELD">memory</code>
field to <code class="CONSTANT">V4L2_MEMORY_USERPTR</code> and the
<code class="STRUCTFIELD">m.userptr</code> field to the address of the
buffer and <code class="STRUCTFIELD">length</code> to its size. When the
buffer is intended for output additional fields must be set as above.
When <code class="CONSTANT">VIDIOC_QBUF</code> is called with a pointer to this
structure the driver sets the <code class="CONSTANT">V4L2_BUF_FLAG_QUEUED</code>
flag and clears the <code class="CONSTANT">V4L2_BUF_FLAG_MAPPED</code> and
<code class="CONSTANT">V4L2_BUF_FLAG_DONE</code> flags in the
<code class="STRUCTFIELD">flags</code> field, or it returns an error code.
This ioctl locks the memory pages of the buffer in physical memory,
they cannot be swapped out to disk. Buffers remain locked until
dequeued, until the <a href="#VIDIOC-STREAMON"><code class="CONSTANT">VIDIOC_STREAMOFF</code></a> or <a href="#VIDIOC-REQBUFS"><code class="CONSTANT">VIDIOC_REQBUFS</code></a> ioctl are
called, or until the device is closed.</p><p>Applications call the <code class="CONSTANT">VIDIOC_DQBUF</code>
ioctl to dequeue a filled (capturing) or displayed (output) buffer
from the driver's outgoing queue. They just set the
<code class="STRUCTFIELD">type</code> and <code class="STRUCTFIELD">memory</code>
fields of a struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a> as above, when <code class="CONSTANT">VIDIOC_DQBUF</code>
is called with a pointer to this structure the driver fills the
remaining fields or returns an error code.</p><p>By default <code class="CONSTANT">VIDIOC_DQBUF</code> blocks when no
buffer is in the outgoing queue. When the
<code class="CONSTANT">O_NONBLOCK</code> flag was given to the <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>
function, <code class="CONSTANT">VIDIOC_DQBUF</code> returns immediately
with an <span class="ERRORCODE">EAGAIN</span> error code when no buffer is available.</p><p>The <code class="STRUCTNAME">v4l2_buffer</code> structure is
specified in <a href="#BUFFER">Section 3.5</a>.</p></div><div class="REFSECT1"><a name="AEN12989"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EAGAIN</span></dt><dd><p>Non-blocking I/O has been selected using
<code class="CONSTANT">O_NONBLOCK</code> and no buffer was in the outgoing
queue.</p></dd><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The buffer <code class="STRUCTFIELD">type</code> is not
supported, or the <code class="STRUCTFIELD">index</code> is out of bounds,
or no buffers have been allocated yet, or the
<code class="STRUCTFIELD">userptr</code> or
<code class="STRUCTFIELD">length</code> are invalid.</p></dd><dt><span class="ERRORCODE">ENOMEM</span></dt><dd><p>Not enough physical or virtual memory was available to
enqueue a user pointer buffer.</p></dd><dt><span class="ERRORCODE">EIO</span></dt><dd><p><code class="CONSTANT">VIDIOC_DQBUF</code> failed due to an
internal error. Can also indicate temporary problems like signal
loss. Note the driver might dequeue an (empty) buffer despite
returning an error, or even stop capturing.</p></dd></dl></div></div><h1><a name="VIDIOC-QUERYBUF"></a>ioctl VIDIOC_QUERYBUF</h1><div class="REFNAMEDIV"><a name="AEN13026"></a><h2>Name</h2>VIDIOC_QUERYBUF&nbsp;--&nbsp;Query the status of a buffer</div><div class="REFSYNOPSISDIV"><a name="AEN13029"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN13030"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_buffer *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN13040"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_QUERYBUF</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN13060"></a><h2>Description</h2><p>This ioctl is part of the <a href="#MMAP">memory
mapping</a> I/O method. It can be used to query the status of a
buffer at any time after buffers have been allocated with the
<a href="#VIDIOC-REQBUFS"><code class="CONSTANT">VIDIOC_REQBUFS</code></a> ioctl.</p><p>Applications set the <code class="STRUCTFIELD">type</code> field
    of a struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a> to the same buffer type as previously
struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a> <code class="STRUCTFIELD">type</code> and struct&nbsp;<a href="#V4L2-REQUESTBUFFERS">v4l2_requestbuffers</a>
<code class="STRUCTFIELD">type</code>, and the <code class="STRUCTFIELD">index</code>
    field. Valid index numbers range from zero
to the number of buffers allocated with <a href="#VIDIOC-REQBUFS"><code class="CONSTANT">VIDIOC_REQBUFS</code></a>
    (struct&nbsp;<a href="#V4L2-REQUESTBUFFERS">v4l2_requestbuffers</a> <code class="STRUCTFIELD">count</code>) minus one.
After calling <code class="CONSTANT">VIDIOC_QUERYBUF</code> with a pointer to
    this structure drivers return an error code or fill the rest of
the structure.</p><p>In the <code class="STRUCTFIELD">flags</code> field the
<code class="CONSTANT">V4L2_BUF_FLAG_MAPPED</code>,
<code class="CONSTANT">V4L2_BUF_FLAG_QUEUED</code> and
<code class="CONSTANT">V4L2_BUF_FLAG_DONE</code> flags will be valid. The
<code class="STRUCTFIELD">memory</code> field will be set to
<code class="CONSTANT">V4L2_MEMORY_MMAP</code>, the <code class="STRUCTFIELD">m.offset</code>
contains the offset of the buffer from the start of the device memory,
the <code class="STRUCTFIELD">length</code> field its size. The driver may
or may not set the remaining fields and flags, they are meaningless in
this context.</p><p>The <code class="STRUCTNAME">v4l2_buffer</code> structure is
    specified in <a href="#BUFFER">Section 3.5</a>.</p></div><div class="REFSECT1"><a name="AEN13091"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The buffer <code class="STRUCTFIELD">type</code> is not
supported, or the <code class="STRUCTFIELD">index</code> is out of bounds.</p></dd></dl></div></div><h1><a name="VIDIOC-QUERYCAP"></a>ioctl VIDIOC_QUERYCAP</h1><div class="REFNAMEDIV"><a name="AEN13109"></a><h2>Name</h2>VIDIOC_QUERYCAP&nbsp;--&nbsp;Query device capabilities</div><div class="REFSYNOPSISDIV"><a name="AEN13112"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN13113"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_capability *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN13123"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_QUERYCAP</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN13143"></a><h2>Description</h2><p>All V4L2 devices support the
<code class="CONSTANT">VIDIOC_QUERYCAP</code> ioctl. It is used to identify
kernel devices compatible with this specification and to obtain
information about driver and hardware capabilities. The ioctl takes a
pointer to a struct&nbsp;<a href="#V4L2-CAPABILITY">v4l2_capability</a> which is filled by the driver. When the
driver is not compatible with this specification the ioctl returns an
<span class="ERRORCODE">EINVAL</span> error code.</p><div class="TABLE"><a name="V4L2-CAPABILITY"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_capability</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u8</td><td><code class="STRUCTFIELD">driver</code>[16]</td><td><p>Name of the driver, a unique NUL-terminated
ASCII string. For example: "bttv". Driver specific applications can
use this information to verify the driver identity. It is also useful
to work around known bugs, or to identify drivers in error reports.
The driver version is stored in the <code class="STRUCTFIELD">version</code>
field.</p><p>Storing strings in fixed sized arrays is bad
practice but unavoidable here. Drivers and applications should take
precautions to never read or write beyond the end of the array and to
make sure the strings are properly NUL-terminated.</p></td></tr><tr><td>__u8</td><td><code class="STRUCTFIELD">card</code>[32]</td><td>Name of the device, a NUL-terminated ASCII string.
For example: "Yoyodyne TV/FM". One driver may support different brands
or models of video hardware. This information is intended for users,
for example in a menu of available devices. Since multiple TV cards of
the same brand may be installed which are supported by the same
driver, this name should be combined with the character device file
name (e.&nbsp;g. <tt class="FILENAME">/dev/video2</tt>) or the
<code class="STRUCTFIELD">bus_info</code> string to avoid
ambiguities.</td></tr><tr><td>__u8</td><td><code class="STRUCTFIELD">bus_info</code>[32]</td><td>Location of the device in the system, a
NUL-terminated ASCII string. For example: "PCI Slot 4". This
information is intended for users, to distinguish multiple
identical devices. If no such information is available the field may
simply count the devices controlled by the driver, or contain the
empty string (<code class="STRUCTFIELD">bus_info</code>[0] = 0).</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">version</code></td><td><p>Version number of the driver. Together with
the <code class="STRUCTFIELD">driver</code> field this identifies a
particular driver. The version number is formatted using the
<code class="CONSTANT">KERNEL_VERSION()</code> macro:</p></td></tr><tr><td colspan="3"><p></p><pre class="PROGRAMLISTING">#define KERNEL_VERSION(a,b,c) (((a) &lt;&lt; 16) + ((b) &lt;&lt; 8) + (c))

__u32 version = KERNEL_VERSION(0, 8, 1);

printf ("Version: %u.%u.%u\n",
        (version &gt;&gt; 16) &amp; 0xFF,
        (version &gt;&gt; 8) &amp; 0xFF,
         version &amp; 0xFF);</pre><p></p></td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">capabilities</code></td><td>Device capabilities, see <a href="#DEVICE-CAPABILITIES">Table 2</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code>[4]</td><td>Reserved for future extensions. Drivers must set
this array to zero.</td></tr></tbody></table></div><div class="TABLE"><a name="DEVICE-CAPABILITIES"></a><p><b>Table 2. Device Capabilities Flags</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_CAP_VIDEO_CAPTURE</code></td><td>0x00000001</td><td>The device supports the <a href="#CAPTURE">Video Capture</a> interface.</td></tr><tr><td><code class="CONSTANT">V4L2_CAP_VIDEO_OUTPUT</code></td><td>0x00000002</td><td>The device supports the <a href="#OUTPUT">Video Output</a> interface.</td></tr><tr><td><code class="CONSTANT">V4L2_CAP_VIDEO_OVERLAY</code></td><td>0x00000004</td><td>The device supports the <a href="#OVERLAY">Video Overlay</a> interface. A video overlay device
typically stores captured images directly in the video memory of a
graphics card, with hardware clipping and scaling.</td></tr><tr><td><code class="CONSTANT">V4L2_CAP_VBI_CAPTURE</code></td><td>0x00000010</td><td>The device supports the <a href="#RAW-VBI">Raw
VBI Capture</a> interface, providing Teletext and Closed Caption
data.</td></tr><tr><td><code class="CONSTANT">V4L2_CAP_VBI_OUTPUT</code></td><td>0x00000020</td><td>The device supports the <a href="#RAW-VBI">Raw VBI Output</a> interface.</td></tr><tr><td><code class="CONSTANT">V4L2_CAP_SLICED_VBI_CAPTURE</code></td><td>0x00000040</td><td>The device supports the <a href="#SLICED">Sliced VBI Capture</a> interface.</td></tr><tr><td><code class="CONSTANT">V4L2_CAP_SLICED_VBI_OUTPUT</code></td><td>0x00000080</td><td>The device supports the <a href="#SLICED">Sliced VBI Output</a> interface.</td></tr><tr><td><code class="CONSTANT">V4L2_CAP_RDS_CAPTURE</code></td><td>0x00000100</td><td>[to be defined]</td></tr><tr><td><code class="CONSTANT">V4L2_CAP_VIDEO_OUTPUT_OVERLAY</code></td><td>0x00000200</td><td>The device supports the <a href="#OSD">Video
Output Overlay</a> (OSD) interface. Unlike the <i class="WORDASWORD">Video
Overlay</i> interface, this is a secondary function of video
output devices and overlays an image onto an outgoing video signal.
When the driver sets this flag, it must clear the
<code class="CONSTANT">V4L2_CAP_VIDEO_OVERLAY</code> flag and vice
versa.<a name="AEN13265" href="#FTN.AEN13265"><span class="footnote">[a]</span></a></td></tr><tr><td><code class="CONSTANT">V4L2_CAP_TUNER</code></td><td>0x00010000</td><td>The device has some sort of tuner or modulator to
receive or emit RF-modulated video signals. For more information about
tuner and modulator programming see
<a href="#TUNER">Section 1.6</a>.</td></tr><tr><td><code class="CONSTANT">V4L2_CAP_AUDIO</code></td><td>0x00020000</td><td>The device has audio inputs or outputs. It may or
may not support audio recording or playback, in PCM or compressed
formats. PCM audio support must be implemented as ALSA or OSS
interface. For more information on audio inputs and outputs see <a href="#AUDIO">Section 1.5</a>.</td></tr><tr><td><code class="CONSTANT">V4L2_CAP_RADIO</code></td><td>0x00040000</td><td>This is a radio receiver.</td></tr><tr><td><code class="CONSTANT">V4L2_CAP_READWRITE</code></td><td>0x01000000</td><td>The device supports the <a href="#RW">read()</a> and/or <a href="#RW">write()</a>
I/O methods.</td></tr><tr><td><code class="CONSTANT">V4L2_CAP_ASYNCIO</code></td><td>0x02000000</td><td>The device supports the <a href="#ASYNC">asynchronous</a> I/O methods.</td></tr><tr><td><code class="CONSTANT">V4L2_CAP_STREAMING</code></td><td>0x04000000</td><td>The device supports the <a href="#MMAP">streaming</a> I/O method.</td></tr></tbody><tbody><tr><td colspan="3">Notes:<br><a name="FTN.AEN13265">a. </a>The struct&nbsp;<a href="#V4L2-FRAMEBUFFER">v4l2_framebuffer</a> lacks an
enum&nbsp;<a href="#V4L2-BUF-TYPE">v4l2_buf_type</a> field, therefore the type of overlay is implied by the
driver capabilities.<br></td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN13305"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The device is not compatible with this
specification.</p></dd></dl></div></div><h1><a name="VIDIOC-QUERYCTRL"></a>ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERYMENU</h1><div class="REFNAMEDIV"><a name="AEN13321"></a><h2>Name</h2>VIDIOC_QUERYCTRL, VIDIOC_QUERYMENU&nbsp;--&nbsp;Enumerate controls and menu control items</div><div class="REFSYNOPSISDIV"><a name="AEN13325"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN13326"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_queryctrl *argp);</code></p><p></p></div><div class="FUNCSYNOPSIS"><p></p><a name="AEN13336"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_querymenu *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN13346"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_QUERYCTRL, VIDIOC_QUERYMENU</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN13366"></a><h2>Description</h2><p>To query the attributes of a control applications set the
<code class="STRUCTFIELD">id</code> field of a struct&nbsp;<a href="#V4L2-QUERYCTRL">v4l2_queryctrl</a> and call the
<code class="CONSTANT">VIDIOC_QUERYCTRL</code> ioctl with a pointer to this
structure. The driver fills the rest of the structure or returns an
<span class="ERRORCODE">EINVAL</span> error code when the <code class="STRUCTFIELD">id</code> is invalid.</p><p>It is possible to enumerate controls by calling
<code class="CONSTANT">VIDIOC_QUERYCTRL</code> with successive
<code class="STRUCTFIELD">id</code> values starting from
<code class="CONSTANT">V4L2_CID_BASE</code> up to and exclusive
<code class="CONSTANT">V4L2_CID_BASE_LASTP1</code>. Drivers may return
<span class="ERRORCODE">EINVAL</span> if a control in this range is not
supported. Further applications can enumerate private controls, which
are not defined in this specification, by starting at
<code class="CONSTANT">V4L2_CID_PRIVATE_BASE</code> and incrementing
<code class="STRUCTFIELD">id</code> until the driver returns
<span class="ERRORCODE">EINVAL</span>.</p><p>In both cases, when the driver sets the
<code class="CONSTANT">V4L2_CTRL_FLAG_DISABLED</code> flag in the
<code class="STRUCTFIELD">flags</code> field this control is permanently
disabled and should be ignored by the application.<a name="AEN13386" href="#FTN.AEN13386"><span class="footnote">[24]</span></a></p><p>When the application ORs <code class="STRUCTFIELD">id</code> with
<code class="CONSTANT">V4L2_CTRL_FLAG_NEXT_CTRL</code> the driver returns the
next supported control, or <span class="ERRORCODE">EINVAL</span> if there is
none. Drivers which do not support this flag yet always return
<span class="ERRORCODE">EINVAL</span>.</p><p>Additional information is required for menu controls, the
name of menu items. To query them applications set the
<code class="STRUCTFIELD">id</code> and <code class="STRUCTFIELD">index</code>
fields of struct&nbsp;<a href="#V4L2-QUERYMENU">v4l2_querymenu</a> and call the
<code class="CONSTANT">VIDIOC_QUERYMENU</code> ioctl with a pointer to this
structure. The driver fills the rest of the structure or returns an
<span class="ERRORCODE">EINVAL</span> error code when the <code class="STRUCTFIELD">id</code> or
<code class="STRUCTFIELD">index</code> is invalid. Menu items are enumerated
by calling <code class="CONSTANT">VIDIOC_QUERYMENU</code> with successive
<code class="STRUCTFIELD">index</code> values from struct&nbsp;<a href="#V4L2-QUERYCTRL">v4l2_queryctrl</a>
<code class="STRUCTFIELD">minimum</code> (0) to
<code class="STRUCTFIELD">maximum</code>, inclusive.</p><p>See also the examples in <a href="#CONTROL">Section 1.8</a>.</p><div class="TABLE"><a name="V4L2-QUERYCTRL"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_queryctrl</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">id</code></td><td>Identifies the control, set by the application. See
<a href="#CONTROL-ID">Table 1-1</a> for predefined IDs. When the ID is ORed
with V4L2_CTRL_FLAG_NEXT_CTRL the driver clears the flag and returns
the first control with a higher ID. Drivers which do not support this
flag yet always return an <span class="ERRORCODE">EINVAL</span> error code.</td></tr><tr><td>enum&nbsp;<a href="#V4L2-CTRL-TYPE">v4l2_ctrl_type</a></td><td><code class="STRUCTFIELD">type</code></td><td>Type of control, see <a href="#V4L2-CTRL-TYPE">Table 3</a>.</td></tr><tr><td>__u8</td><td><code class="STRUCTFIELD">name</code>[32]</td><td>Name of the control, a NUL-terminated ASCII
string. This information is intended for the user.</td></tr><tr><td>__s32</td><td><code class="STRUCTFIELD">minimum</code></td><td>Minimum value, inclusive. This field gives a lower
bound for <code class="CONSTANT">V4L2_CTRL_TYPE_INTEGER</code> controls. It may
not be valid for any other type of control, including
<code class="CONSTANT">V4L2_CTRL_TYPE_INTEGER64</code> controls. Note this is a
signed value.</td></tr><tr><td>__s32</td><td><code class="STRUCTFIELD">maximum</code></td><td>Maximum value, inclusive. This field gives an upper
bound for <code class="CONSTANT">V4L2_CTRL_TYPE_INTEGER</code> controls and the
highest valid index for <code class="CONSTANT">V4L2_CTRL_TYPE_MENU</code>
controls. It may not be valid for any other type of control, including
<code class="CONSTANT">V4L2_CTRL_TYPE_INTEGER64</code> controls. Note this is a
signed value.</td></tr><tr><td>__s32</td><td><code class="STRUCTFIELD">step</code></td><td><p>This field gives a step size for
<code class="CONSTANT">V4L2_CTRL_TYPE_INTEGER</code> controls. It may not be
valid for any other type of control, including
<code class="CONSTANT">V4L2_CTRL_TYPE_INTEGER64</code>
controls.</p><p>Generally drivers should not scale hardware
control values. It may be necessary for example when the
<code class="STRUCTFIELD">name</code> or <code class="STRUCTFIELD">id</code> imply
a particular unit and the hardware actually accepts only multiples of
said unit. If so, drivers must take care values are properly rounded
when scaling, such that errors will not accumulate on repeated
read-write cycles.</p><p>This field gives the smallest change of
an integer control actually affecting hardware. Often the information
is needed when the user can change controls by keyboard or GUI
buttons, rather than a slider. When for example a hardware register
accepts values 0-511 and the driver reports 0-65535, step should be
128.</p><p>Note although signed, the step value is supposed to
be always positive.</p></td></tr><tr><td>__s32</td><td><code class="STRUCTFIELD">default_value</code></td><td>The default value of a
<code class="CONSTANT">V4L2_CTRL_TYPE_INTEGER</code>,
<code class="CONSTANT">_BOOLEAN</code> or <code class="CONSTANT">_MENU</code> control.
Not valid for other types of controls. Drivers reset controls only
when the driver is loaded, not later, in particular not when the
func-open; is called.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">flags</code></td><td>Control flags, see <a href="#CONTROL-FLAGS">Table 4</a>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code>[2]</td><td>Reserved for future extensions. Drivers must set
the array to zero.</td></tr></tbody></table></div><div class="TABLE"><a name="V4L2-QUERYMENU"></a><p><b>Table 2. struct <code class="STRUCTNAME">v4l2_querymenu</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">id</code></td><td>Identifies the control, set by the application
from the respective struct&nbsp;<a href="#V4L2-QUERYCTRL">v4l2_queryctrl</a>
<code class="STRUCTFIELD">id</code>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">index</code></td><td>Index of the menu item, starting at zero, set by
            the application.</td></tr><tr><td>__u8</td><td><code class="STRUCTFIELD">name</code>[32]</td><td>Name of the menu item, a NUL-terminated ASCII
string. This information is intended for the user.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code></td><td>Reserved for future extensions. Drivers must set
the array to zero.</td></tr></tbody></table></div><div class="TABLE"><a name="V4L2-CTRL-TYPE"></a><p><b>Table 3. enum v4l2_ctrl_type</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col width="30%"><col align="CENTER" width="5%"><col align="CENTER" width="5%"><col align="CENTER" width="5%"><col width="55%"></colgroup><thead><tr><th>Type</th><th><code class="STRUCTFIELD">minimum</code></th><th><code class="STRUCTFIELD">step</code></th><th><code class="STRUCTFIELD">maximum</code></th><th>Description</th></tr></thead><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_CTRL_TYPE_INTEGER</code></td><td>any</td><td>any</td><td>any</td><td>An integer-valued control ranging from minimum to
maximum inclusive. The step value indicates the increment between
values which are actually different on the hardware.</td></tr><tr><td><code class="CONSTANT">V4L2_CTRL_TYPE_BOOLEAN</code></td><td>0</td><td>1</td><td>1</td><td>A boolean-valued control. Zero corresponds to
"disabled", and one means "enabled".</td></tr><tr><td><code class="CONSTANT">V4L2_CTRL_TYPE_MENU</code></td><td>0</td><td>1</td><td>N-1</td><td>The control has a menu of N choices. The names of
the menu items can be enumerated with the
<code class="CONSTANT">VIDIOC_QUERYMENU</code> ioctl.</td></tr><tr><td><code class="CONSTANT">V4L2_CTRL_TYPE_BUTTON</code></td><td>0</td><td>0</td><td>0</td><td>A control which performs an action when set.
Drivers must ignore the value passed with
<code class="CONSTANT">VIDIOC_S_CTRL</code> and return an <span class="ERRORCODE">EINVAL</span> error code on a
<code class="CONSTANT">VIDIOC_G_CTRL</code> attempt.</td></tr><tr><td><code class="CONSTANT">V4L2_CTRL_TYPE_INTEGER64</code></td><td>n/a</td><td>n/a</td><td>n/a</td><td>A 64-bit integer valued control. Minimum, maximum
and step size cannot be queried.</td></tr><tr><td><code class="CONSTANT">V4L2_CTRL_TYPE_CTRL_CLASS</code></td><td>n/a</td><td>n/a</td><td>n/a</td><td>This is not a control. When
<code class="CONSTANT">VIDIOC_QUERYCTRL</code> is called with a control ID
equal to a control class code (see <a href="#CTRL-CLASS">Table 3</a>), the
ioctl returns the name of the control class and this control type.
Older drivers which do not support this feature return an
<span class="ERRORCODE">EINVAL</span> error code.</td></tr></tbody></table></div><div class="TABLE"><a name="CONTROL-FLAGS"></a><p><b>Table 4. Control Flags</b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="38%"><col title="C2" width="12%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_CTRL_FLAG_DISABLED</code></td><td>0x0001</td><td>This control is permanently disabled and should be
ignored by the application. Any attempt to change the control will
result in an <span class="ERRORCODE">EINVAL</span> error code.</td></tr><tr><td><code class="CONSTANT">V4L2_CTRL_FLAG_GRABBED</code></td><td>0x0002</td><td>This control is temporarily unchangeable, for
example because another application took over control of the
respective resource. Such controls may be displayed specially in a
user interface. Attempts to change the control may result in an
<span class="ERRORCODE">EBUSY</span> error code.</td></tr><tr><td><code class="CONSTANT">V4L2_CTRL_FLAG_READ_ONLY</code></td><td>0x0004</td><td>This control is permanently readable only. Any
attempt to change the control will result in an <span class="ERRORCODE">EINVAL</span> error code.</td></tr><tr><td><code class="CONSTANT">V4L2_CTRL_FLAG_UPDATE</code></td><td>0x0008</td><td>A hint that changing this control may affect the
value of other controls within the same control class. Applications
should update their user interface accordingly.</td></tr><tr><td><code class="CONSTANT">V4L2_CTRL_FLAG_INACTIVE</code></td><td>0x0010</td><td>This control is not applicable to the current
configuration and should be displayed accordingly in a user interface.
For example the flag may be set on a MPEG audio level 2 bitrate
control when MPEG audio encoding level 1 was selected with another
control.</td></tr><tr><td><code class="CONSTANT">V4L2_CTRL_FLAG_SLIDER</code></td><td>0x0020</td><td>A hint that this control is best represented as a
slider-like element in a user interface.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN13624"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The struct&nbsp;<a href="#V4L2-QUERYCTRL">v4l2_queryctrl</a> <code class="STRUCTFIELD">id</code>
is invalid. The struct&nbsp;<a href="#V4L2-QUERYMENU">v4l2_querymenu</a> <code class="STRUCTFIELD">id</code> or
<code class="STRUCTFIELD">index</code> is invalid.</p></dd></dl></div></div><h1><a name="VIDIOC-QUERYSTD"></a>ioctl VIDIOC_QUERYSTD</h1><div class="REFNAMEDIV"><a name="AEN13645"></a><h2>Name</h2>VIDIOC_QUERYSTD&nbsp;--&nbsp;Sense the video standard received by the current
input</div><div class="REFSYNOPSISDIV"><a name="AEN13648"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN13649"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, v4l2_std_id *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN13659"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_QUERYSTD</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN13679"></a><h2>Description</h2><p>The hardware may be able to detect the current video
standard automatically. To do so, applications call <code class="CONSTANT">VIDIOC_QUERYSTD</code> with a pointer to a <a href="#V4L2-STD-ID">v4l2_std_id</a> type. The
driver stores here a set of candidates, this can be a single flag or a
set of supported standards if for example the hardware can only
distinguish between 50 and 60 Hz systems. When detection is not
possible or fails, the set must contain all standards supported by the
current video input or output.</p></div><div class="REFSECT1"><a name="AEN13684"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>This ioctl is not supported.</p></dd></dl></div></div><h1><a name="VIDIOC-REQBUFS"></a>ioctl VIDIOC_REQBUFS</h1><div class="REFNAMEDIV"><a name="AEN13700"></a><h2>Name</h2>VIDIOC_REQBUFS&nbsp;--&nbsp;Initiate Memory Mapping or User Pointer I/O</div><div class="REFSYNOPSISDIV"><a name="AEN13703"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN13704"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, struct v4l2_requestbuffers *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN13714"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_REQBUFS</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN13734"></a><h2>Description</h2><p>This ioctl is used to initiate <a href="#MMAP">memory
mapped</a> or <a href="#USERP">user pointer</a>
I/O. Memory mapped buffers are located in device memory and must be
allocated with this ioctl before they can be mapped into the
application's address space. User buffers are allocated by
applications themselves, and this ioctl is merely used to switch the
driver into user pointer I/O mode.</p><p>To allocate device buffers applications initialize three
fields of a <code class="STRUCTNAME">v4l2_requestbuffers</code> structure.
They set the <code class="STRUCTFIELD">type</code> field to the respective
stream or buffer type, the <code class="STRUCTFIELD">count</code> field to
the desired number of buffers, and <code class="STRUCTFIELD">memory</code>
must be set to <code class="CONSTANT">V4L2_MEMORY_MMAP</code>. When the ioctl
is called with a pointer to this structure the driver attempts to
allocate the requested number of buffers and stores the actual number
allocated in the <code class="STRUCTFIELD">count</code> field. It can be
smaller than the number requested, even zero, when the driver runs out
of free memory. A larger number is possible when the driver requires
more buffers to function correctly.<a name="AEN13746" href="#FTN.AEN13746"><span class="footnote">[25]</span></a> When memory mapping I/O is not supported the ioctl
returns an <span class="ERRORCODE">EINVAL</span> error code.</p><p>Applications can call <code class="CONSTANT">VIDIOC_REQBUFS</code>
again to change the number of buffers, however this cannot succeed
when any buffers are still mapped. A <code class="STRUCTFIELD">count</code>
value of zero frees all buffers, after aborting or finishing any DMA
in progress, an implicit <a href="#VIDIOC-STREAMON"><code class="CONSTANT">VIDIOC_STREAMOFF</code></a>. </p><p>To negotiate user pointer I/O, applications initialize only
the <code class="STRUCTFIELD">type</code> field and set
<code class="STRUCTFIELD">memory</code> to
<code class="CONSTANT">V4L2_MEMORY_USERPTR</code>. When the ioctl is called
with a pointer to this structure the driver prepares for user pointer
I/O, when this I/O method is not supported the ioctl returns an
<span class="ERRORCODE">EINVAL</span> error code.</p><div class="TABLE"><a name="V4L2-REQUESTBUFFERS"></a><p><b>Table 1. struct <code class="STRUCTNAME">v4l2_requestbuffers</code></b></p><table frame="void" class="CALSTABLE" border="0" width="100%"><colgroup><col title="C1" width="25%"><col title="C2" width="25%"><col title="C3" width="50%"></colgroup><tbody valign="TOP"><tr><td>__u32</td><td><code class="STRUCTFIELD">count</code></td><td>The number of buffers requested or granted. This
field is only used when <code class="STRUCTFIELD">memory</code> is set to
<code class="CONSTANT">V4L2_MEMORY_MMAP</code>.</td></tr><tr><td>enum&nbsp;<a href="#V4L2-BUF-TYPE">v4l2_buf_type</a></td><td><code class="STRUCTFIELD">type</code></td><td>Type of the stream or buffers, this is the same
as the struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a> <code class="STRUCTFIELD">type</code> field. See <a href="#V4L2-BUF-TYPE">Table 3-2</a> for valid values.</td></tr><tr><td>enum&nbsp;<a href="#V4L2-MEMORY">v4l2_memory</a></td><td><code class="STRUCTFIELD">memory</code></td><td>Applications set this field to
<code class="CONSTANT">V4L2_MEMORY_MMAP</code> or
<code class="CONSTANT">V4L2_MEMORY_USERPTR</code>.</td></tr><tr><td>__u32</td><td><code class="STRUCTFIELD">reserved</code>[2]</td><td>A place holder for future extensions and custom
(driver defined) buffer types <code class="CONSTANT">V4L2_BUF_TYPE_PRIVATE</code> and
higher.</td></tr></tbody></table></div></div><div class="REFSECT1"><a name="AEN13798"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EBUSY</span></dt><dd><p>The driver supports multiple opens and I/O is already
in progress, or reallocation of buffers was attempted although one or
more are still mapped.</p></dd><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The buffer type (<code class="STRUCTFIELD">type</code> field) or the
requested I/O method (<code class="STRUCTFIELD">memory</code>) is not
supported.</p></dd></dl></div></div><h1><a name="VIDIOC-STREAMON"></a>ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF</h1><div class="REFNAMEDIV"><a name="AEN13821"></a><h2>Name</h2>VIDIOC_STREAMON, VIDIOC_STREAMOFF&nbsp;--&nbsp;Start or stop streaming I/O</div><div class="REFSYNOPSISDIV"><a name="AEN13825"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN13826"></a><p><code><code class="FUNCDEF">int ioctl</code>(int fd, int request, const int *argp);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN13836"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">request</code></dt><dd><p>VIDIOC_STREAMON, VIDIOC_STREAMOFF</p></dd><dt><code class="PARAMETER">argp</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN13856"></a><h2>Description</h2><p>The <code class="CONSTANT">VIDIOC_STREAMON</code> and
<code class="CONSTANT">VIDIOC_STREAMOFF</code> ioctl start and stop the capture
or output process during streaming (<a href="#MMAP">memory
mapping</a> or <a href="#USERP">user pointer</a>) I/O.</p><p>Specifically the capture hardware is disabled and no input
buffers are filled (if there are any empty buffers in the incoming
queue) until <code class="CONSTANT">VIDIOC_STREAMON</code> has been called.
Accordingly the output hardware is disabled, no video signal is
produced until <code class="CONSTANT">VIDIOC_STREAMON</code> has been called.
The ioctl will succeed only when at least one output buffer is in the
incoming queue.</p><p>The <code class="CONSTANT">VIDIOC_STREAMOFF</code> ioctl, apart of
aborting or finishing any DMA in progress, unlocks any user pointer
buffers locked in physical memory, and it removes all buffers from the
incoming and outgoing queues. That means all images captured but not
dequeued yet will be lost, likewise all images enqueued for output but
not transmitted yet. I/O returns to the same state as after calling
<a href="#VIDIOC-REQBUFS"><code class="CONSTANT">VIDIOC_REQBUFS</code></a> and can be restarted accordingly.</p><p>Both ioctls take a pointer to an integer, the desired buffer or
stream type. This is the same as struct&nbsp;<a href="#V4L2-REQUESTBUFFERS">v4l2_requestbuffers</a>
<code class="STRUCTFIELD">type</code>.</p><p>Note applications can be preempted for unknown periods right
before or after the <code class="CONSTANT">VIDIOC_STREAMON</code> or
<code class="CONSTANT">VIDIOC_STREAMOFF</code> calls, there is no notion of
starting or stopping "now". Buffer timestamps can be used to
synchronize with other events.</p></div><div class="REFSECT1"><a name="AEN13876"></a><h2>Return Value</h2><p>On success <span class="RETURNVALUE">0</span> is returned, on error <span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>Streaming I/O is not supported, the buffer
<code class="STRUCTFIELD">type</code> is not supported, or no buffers have
been allocated (memory mapping) or enqueued (output) yet.</p></dd></dl></div></div><h1><a name="FUNC-MMAP"></a>V4L2 mmap()</h1><div class="REFNAMEDIV"><a name="AEN13893"></a><h2>Name</h2>v4l2-mmap&nbsp;--&nbsp;Map device memory into application address space</div><div class="REFSYNOPSISDIV"><a name="AEN13896"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN13897"></a><pre class="FUNCSYNOPSISINFO">#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt;</pre><p><code><code class="FUNCDEF">void *mmap</code>(void *start, size_t length, int prot, int flags, int fd, off_t offset);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN13914"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">start</code></dt><dd><p>Map the buffer to this address in the 
application's address space. When the <code class="CONSTANT">MAP_FIXED</code>
flag is specified, <code class="PARAMETER">start</code> must be a multiple of the
pagesize and mmap will fail when the specified address
cannot be used. Use of this option is discouraged; applications should
just specify a <code class="CONSTANT">NULL</code> pointer here.</p></dd><dt><code class="PARAMETER">length</code></dt><dd><p>Length of the memory area to map. This must be the
same value as returned by the driver in the struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a>
<code class="STRUCTFIELD">length</code> field.</p></dd><dt><code class="PARAMETER">prot</code></dt><dd><p>The <code class="PARAMETER">prot</code> argument describes the
desired memory protection. Regardless of the device type and the
direction of data exchange it should be set to
<code class="CONSTANT">PROT_READ</code> | <code class="CONSTANT">PROT_WRITE</code>,
permitting read and write access to image buffers. Drivers should
support at least this combination of flags. Note the Linux
<tt class="FILENAME">video-buf</tt> kernel module, which is used by the
bttv, saa7134, saa7146, cx88 and vivi driver supports only
<code class="CONSTANT">PROT_READ</code> | <code class="CONSTANT">PROT_WRITE</code>. When
the driver does not support the desired protection the
<code class="FUNCTION">mmap()</code> function fails.</p><p>Note device memory accesses (e.&nbsp;g. the memory on a
graphics card with video capturing hardware) may incur a performance
penalty compared to main memory accesses, or reads may be
significantly slower than writes or vice versa. Other I/O methods may
be more efficient in this case.</p></dd><dt><code class="PARAMETER">flags</code></dt><dd><p>The <code class="PARAMETER">flags</code> parameter
specifies the type of the mapped object, mapping options and whether
modifications made to the mapped copy of the page are private to the
process or are to be shared with other references.</p><p><code class="CONSTANT">MAP_FIXED</code> requests that the
driver selects no other address than the one specified. If the
specified address cannot be used, <code class="FUNCTION">mmap()</code> will fail. If
<code class="CONSTANT">MAP_FIXED</code> is specified,
<code class="PARAMETER">start</code> must be a multiple of the pagesize. Use
of this option is discouraged.</p><p>One of the <code class="CONSTANT">MAP_SHARED</code> or
<code class="CONSTANT">MAP_PRIVATE</code> flags must be set.
<code class="CONSTANT">MAP_SHARED</code> allows applications to share the
mapped memory with other (e.&nbsp;g. child-) processes. Note the Linux
<tt class="FILENAME">video-buf</tt> module which is used by the bttv,
saa7134, saa7146, cx88 and vivi driver supports only
<code class="CONSTANT">MAP_SHARED</code>. <code class="CONSTANT">MAP_PRIVATE</code>
requests copy-on-write semantics. V4L2 applications should not set the
<code class="CONSTANT">MAP_PRIVATE</code>, <code class="CONSTANT">MAP_DENYWRITE</code>,
<code class="CONSTANT">MAP_EXECUTABLE</code> or <code class="CONSTANT">MAP_ANON</code>
flag.</p></dd><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">offset</code></dt><dd><p>Offset of the buffer in device memory. This must be the
same value as returned by the driver in the struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a>
<code class="STRUCTFIELD">m</code> union <code class="STRUCTFIELD">offset</code> field.</p></dd></dl></div></div><div class="REFSECT1"><a name="AEN13982"></a><h2>Description</h2><p>The <code class="FUNCTION">mmap()</code> function asks to map
<code class="PARAMETER">length</code> bytes starting at
<code class="PARAMETER">offset</code> in the memory of the device specified by
<code class="PARAMETER">fd</code> into the application address space,
preferably at address <code class="PARAMETER">start</code>. This latter
address is a hint only, and is usually specified as 0.</p><p>Suitable length and offset parameters are queried with the
<a href="#VIDIOC-QUERYBUF"><code class="CONSTANT">VIDIOC_QUERYBUF</code></a> ioctl. Buffers must be allocated with the
<a href="#VIDIOC-REQBUFS"><code class="CONSTANT">VIDIOC_REQBUFS</code></a> ioctl before they can be queried.</p><p>To unmap buffers the <a href="#FUNC-MUNMAP"><code class="FUNCTION">munmap()</code></a> function is used.</p></div><div class="REFSECT1"><a name="AEN13998"></a><h2>Return Value</h2><p>On success <code class="FUNCTION">mmap()</code> returns a pointer to
the mapped buffer. On error <code class="CONSTANT">MAP_FAILED</code> (-1) is
returned, and the <code class="VARNAME">errno</code> variable is set
appropriately. Possible error codes are:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EBADF</span></dt><dd><p><code class="PARAMETER">fd</code> is not a valid file
descriptor.</p></dd><dt><span class="ERRORCODE">EACCES</span></dt><dd><p><code class="PARAMETER">fd</code> is
not open for reading and writing.</p></dd><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The <code class="PARAMETER">start</code> or
<code class="PARAMETER">length</code> or <code class="PARAMETER">offset</code> are not
suitable. (E.&nbsp;g. they are too large, or not aligned on a
<code class="CONSTANT">PAGESIZE</code> boundary.)</p><p>The <code class="PARAMETER">flags</code> or
<code class="PARAMETER">prot</code> value is not supported.</p><p>No buffers have been allocated with the
<a href="#VIDIOC-REQBUFS"><code class="CONSTANT">VIDIOC_REQBUFS</code></a> ioctl.</p></dd><dt><span class="ERRORCODE">ENOMEM</span></dt><dd><p>Not enough physical or virtual memory was available to
complete the request.</p></dd></dl></div></div><h1><a name="FUNC-MUNMAP"></a>V4L2 munmap()</h1><div class="REFNAMEDIV"><a name="AEN14041"></a><h2>Name</h2>v4l2-munmap&nbsp;--&nbsp;Unmap device memory</div><div class="REFSYNOPSISDIV"><a name="AEN14044"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN14045"></a><pre class="FUNCSYNOPSISINFO">#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt;</pre><p><code><code class="FUNCDEF">int munmap</code>(void *start, size_t length);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN14054"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">start</code></dt><dd><p>Address of the mapped buffer as returned by the
<a href="#FUNC-MMAP"><code class="FUNCTION">mmap()</code></a> function.</p></dd><dt><code class="PARAMETER">length</code></dt><dd><p>Length of the mapped buffer. This must be the same
value as given to <code class="FUNCTION">mmap()</code> and returned by the
driver in the struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a> <code class="STRUCTFIELD">length</code>
field.</p></dd></dl></div></div><div class="REFSECT1"><a name="AEN14072"></a><h2>Description</h2><p>Unmaps a previously with the <a href="#FUNC-MMAP"><code class="FUNCTION">mmap()</code></a> function mapped
buffer and frees it, if possible. </p></div><div class="REFSECT1"><a name="AEN14077"></a><h2>Return Value</h2><p>On success <code class="FUNCTION">munmap()</code> returns 0, on
failure -1 and the <code class="VARNAME">errno</code> variable is set
appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The <code class="PARAMETER">start</code> or
<code class="PARAMETER">length</code> is incorrect, or no buffers have been
mapped yet.</p></dd></dl></div></div><h1><a name="FUNC-OPEN"></a>V4L2 open()</h1><div class="REFNAMEDIV"><a name="AEN14094"></a><h2>Name</h2>v4l2-open&nbsp;--&nbsp;Open a V4L2 device</div><div class="REFSYNOPSISDIV"><a name="AEN14097"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN14098"></a><pre class="FUNCSYNOPSISINFO">#include &lt;fcntl.h&gt;</pre><p><code><code class="FUNCDEF">int open</code>(const char *device_name, int flags);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN14107"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">device_name</code></dt><dd><p>Device to be opened.</p></dd><dt><code class="PARAMETER">flags</code></dt><dd><p>Open flags. Access mode must be
<code class="CONSTANT">O_RDWR</code>. This is just a technicality, input devices
still support only reading and output devices only writing.</p><p>When the <code class="CONSTANT">O_NONBLOCK</code> flag is
given, the read() function and the <a href="#VIDIOC-QBUF"><code class="CONSTANT">VIDIOC_DQBUF</code></a> ioctl will return
the <span class="ERRORCODE">EAGAIN</span> error code when no data is available or no buffer is in the driver
outgoing queue, otherwise these functions block until data becomes
available. All V4L2 drivers exchanging data with applications must
support the <code class="CONSTANT">O_NONBLOCK</code> flag.</p><p>Other flags have no effect.</p></dd></dl></div></div><div class="REFSECT1"><a name="AEN14128"></a><h2>Description</h2><p>To open a V4L2 device applications call
<code class="FUNCTION">open()</code> with the desired device name. This
function has no side effects; all data format parameters, current
input or output, control values or other properties remain unchanged.
At the first <code class="FUNCTION">open()</code> call after loading the driver
they will be reset to default values, drivers are never in an
undefined state.</p></div><div class="REFSECT1"><a name="AEN14133"></a><h2>Return Value</h2><p>On success <code class="FUNCTION">open</code> returns the new file
descriptor. On error -1 is returned, and the <code class="VARNAME">errno</code>
variable is set appropriately. Possible error codes are:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EACCES</span></dt><dd><p>The caller has no permission to access the
device.</p></dd><dt><span class="ERRORCODE">EBUSY</span></dt><dd><p>The driver does not support multiple opens and the
device is already in use.</p></dd><dt><span class="ERRORCODE">ENXIO</span></dt><dd><p>No device corresponding to this device special file
exists.</p></dd><dt><span class="ERRORCODE">ENOMEM</span></dt><dd><p>Not enough kernel memory was available to complete the
request.</p></dd><dt><span class="ERRORCODE">EMFILE</span></dt><dd><p>The  process  already  has  the  maximum number of
files open.</p></dd><dt><span class="ERRORCODE">ENFILE</span></dt><dd><p>The limit on the total number of files open on the
system has been reached.</p></dd></dl></div></div><h1><a name="FUNC-POLL"></a>V4L2 poll()</h1><div class="REFNAMEDIV"><a name="AEN14173"></a><h2>Name</h2>v4l2-poll&nbsp;--&nbsp;Wait for some event on a file descriptor</div><div class="REFSYNOPSISDIV"><a name="AEN14176"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN14177"></a><pre class="FUNCSYNOPSISINFO">#include &lt;sys/poll.h&gt;</pre><p><code><code class="FUNCDEF">int poll</code>(struct pollfd *ufds, unsigned int nfds, int timeout);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN14188"></a><h2>Description</h2><p>With the <code class="FUNCTION">poll()</code> function applications
can suspend execution until the driver has captured data or is ready
to accept data for output.</p><p>When streaming I/O has been negotiated this function waits
until a buffer has been filled or displayed and can be dequeued with
the <a href="#VIDIOC-QBUF"><code class="CONSTANT">VIDIOC_DQBUF</code></a> ioctl. When buffers are already in the outgoing
queue of the driver the function returns immediately.</p><p>On success <code class="FUNCTION">poll()</code> returns the number of
file descriptors that have been selected (that is, file descriptors
for which the <code class="STRUCTFIELD">revents</code> field of the
respective <code class="STRUCTNAME">pollfd</code> structure is non-zero).
Capture devices set the <code class="CONSTANT">POLLIN</code> and
<code class="CONSTANT">POLLRDNORM</code> flags in the
<code class="STRUCTFIELD">revents</code> field, output devices the
<code class="CONSTANT">POLLOUT</code> and <code class="CONSTANT">POLLWRNORM</code>
flags. When the function timed out it returns a value of zero, on
failure it returns <span class="RETURNVALUE">-1</span> and the
<code class="VARNAME">errno</code> variable is set appropriately. When the
application did not call <a href="#VIDIOC-QBUF"><code class="CONSTANT">VIDIOC_QBUF</code></a> or <a href="#VIDIOC-STREAMON"><code class="CONSTANT">VIDIOC_STREAMON</code></a> yet the
<code class="FUNCTION">poll()</code> function succeeds, but sets the
<code class="CONSTANT">POLLERR</code> flag in the
<code class="STRUCTFIELD">revents</code> field.</p><p>When use of the <code class="FUNCTION">read()</code> function has
been negotiated and the driver does not capture yet, the
<code class="FUNCTION">poll</code> function starts capturing. When that fails
it returns a <code class="CONSTANT">POLLERR</code> as above. Otherwise it waits
until data has been captured and can be read. When the driver captures
continuously (as opposed to, for example, still images) the function
may return immediately.</p><p>When use of the <code class="FUNCTION">write()</code> function has
been negotiated the <code class="FUNCTION">poll</code> function just waits
until the driver is ready for a non-blocking
<code class="FUNCTION">write()</code> call.</p><p>All drivers implementing the <code class="FUNCTION">read()</code> or
<code class="FUNCTION">write()</code> function or streaming I/O must also
support the <code class="FUNCTION">poll()</code> function.</p><p>For more details see the
<code class="FUNCTION">poll()</code> manual page.</p></div><div class="REFSECT1"><a name="AEN14227"></a><h2>Return Value</h2><p>On success, <code class="FUNCTION">poll()</code> returns the number
structures which have non-zero <code class="STRUCTFIELD">revents</code>
fields, or zero if the call timed out. On error
<span class="RETURNVALUE">-1</span> is returned, and the
<code class="VARNAME">errno</code> variable is set appropriately:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EBADF</span></dt><dd><p>One or more of the <code class="PARAMETER">ufds</code> members
specify an invalid file descriptor.</p></dd><dt><span class="ERRORCODE">EBUSY</span></dt><dd><p>The driver does not support multiple read or write
streams and the device is already in use.</p></dd><dt><span class="ERRORCODE">EFAULT</span></dt><dd><p><code class="PARAMETER">ufds</code> references an inaccessible
memory area.</p></dd><dt><span class="ERRORCODE">EINTR</span></dt><dd><p>The call was interrupted by a signal.</p></dd><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The <code class="PARAMETER">nfds</code> argument is greater
than <code class="CONSTANT">OPEN_MAX</code>.</p></dd></dl></div></div><h1><a name="FUNC-READ"></a>V4L2 read()</h1><div class="REFNAMEDIV"><a name="AEN14268"></a><h2>Name</h2>v4l2-read&nbsp;--&nbsp;Read from a V4L2 device</div><div class="REFSYNOPSISDIV"><a name="AEN14271"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN14272"></a><pre class="FUNCSYNOPSISINFO">#include &lt;unistd.h&gt;</pre><p><code><code class="FUNCDEF">ssize_t read</code>(int fd, void *buf, size_t count);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN14283"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">buf</code></dt><dd><p></p></dd><dt><code class="PARAMETER">count</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN14303"></a><h2>Description</h2><p><code class="FUNCTION">read()</code> attempts to read up to
<code class="PARAMETER">count</code> bytes from file descriptor
<code class="PARAMETER">fd</code> into the buffer starting at
<code class="PARAMETER">buf</code>. The layout of the data in the buffer is
discussed in the respective device interface section, see ##. If <code class="PARAMETER">count</code> is zero,
<code class="FUNCTION">read()</code> returns zero and has no other results. If
<code class="PARAMETER">count</code> is greater than
<code class="CONSTANT">SSIZE_MAX</code>, the result is unspecified. Regardless
of the <code class="PARAMETER">count</code> value each
<code class="FUNCTION">read()</code> call will provide at most one frame (two
fields) worth of data.</p><p>By default <code class="FUNCTION">read()</code> blocks until data
becomes available. When the <code class="CONSTANT">O_NONBLOCK</code> flag was
given to the <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a> function it
returns immediately with an <span class="ERRORCODE">EAGAIN</span> error code when no data is available. The
<a href="#FUNC-SELECT"><code class="FUNCTION">select()</code></a> or <a href="#FUNC-POLL"><code class="FUNCTION">poll()</code></a> functions
can always be used to suspend execution until data becomes available. All
drivers supporting the <code class="FUNCTION">read()</code> function must also
support <code class="FUNCTION">select()</code> and
<code class="FUNCTION">poll()</code>.</p><p>Drivers can implement read functionality in different
ways, using a single or multiple buffers and discarding the oldest or
newest frames once the internal buffers are filled.</p><p><code class="FUNCTION">read()</code> never returns a "snapshot" of a
buffer being filled. Using a single buffer the driver will stop
capturing when the application starts reading the buffer until the
read is finished. Thus only the period of the vertical blanking
interval is available for reading, or the capture rate must fall below
the nominal frame rate of the video standard.</p><p>The behavior of
<code class="FUNCTION">read()</code> when called during the active picture
period or the vertical blanking separating the top and bottom field
depends on the discarding policy. A driver discarding the oldest
frames keeps capturing into an internal buffer, continuously
overwriting the previously, not read frame, and returns the frame
being received at the time of the <code class="FUNCTION">read()</code> call as
soon as it is complete.</p><p>A driver discarding the newest frames stops capturing until
the next <code class="FUNCTION">read()</code> call. The frame being received at
<code class="FUNCTION">read()</code> time is discarded, returning the following
frame instead. Again this implies a reduction of the capture rate to
one half or less of the nominal frame rate. An example of this model
is the video read mode of the bttv driver, initiating a DMA to user
memory when <code class="FUNCTION">read()</code> is called and returning when
the DMA finished.</p><p>In the multiple buffer model drivers maintain a ring of
internal buffers, automatically advancing to the next free buffer.
This allows continuous capturing when the application can empty the
buffers fast enough. Again, the behavior when the driver runs out of
free buffers depends on the discarding policy.</p><p>Applications can get and set the number of buffers used
internally by the driver with the <a href="#VIDIOC-G-PARM"><code class="CONSTANT">VIDIOC_G_PARM</code></a> and <a href="#VIDIOC-G-PARM"><code class="CONSTANT">VIDIOC_S_PARM</code></a>
ioctls. They are optional, however. The discarding policy is not
reported and cannot be changed. For minimum requirements see <a href="#DEVICES">Chapter 4</a>.</p></div><div class="REFSECT1"><a name="AEN14346"></a><h2>Return Value</h2><p>On success, the number of bytes read is returned. It is not
an error if this number is smaller than the number of bytes requested,
or the amount of data required for one frame. This may happen for
example because <code class="FUNCTION">read()</code> was interrupted by a
signal. On error, -1 is returned, and the <code class="VARNAME">errno</code>
variable is set appropriately. In this case the next read will start
at the beginning of a new frame. Possible error codes are:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EAGAIN</span></dt><dd><p>Non-blocking I/O has been selected using
O_NONBLOCK and no data was immediately available for reading.</p></dd><dt><span class="ERRORCODE">EBADF</span></dt><dd><p><code class="PARAMETER">fd</code> is not a valid file
descriptor or is not open for reading, or the process already has the
maximum number of files open.</p></dd><dt><span class="ERRORCODE">EBUSY</span></dt><dd><p>The driver does not support multiple read streams and the
device is already in use.</p></dd><dt><span class="ERRORCODE">EFAULT</span></dt><dd><p><code class="PARAMETER">buf</code> references an inaccessible
memory area.</p></dd><dt><span class="ERRORCODE">EINTR</span></dt><dd><p>The call was interrupted by a signal before any
data was read.</p></dd><dt><span class="ERRORCODE">EIO</span></dt><dd><p>I/O error. This indicates some hardware problem or a
failure to communicate with a remote device (USB camera etc.).</p></dd><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The <code class="FUNCTION">read()</code> function is not
supported by this driver, not on this device, or generally not on this
type of device.</p></dd></dl></div></div><h1><a name="FUNC-SELECT"></a>V4L2 select()</h1><div class="REFNAMEDIV"><a name="AEN14394"></a><h2>Name</h2>v4l2-select&nbsp;--&nbsp;Synchronous I/O multiplexing</div><div class="REFSYNOPSISDIV"><a name="AEN14397"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN14398"></a><pre class="FUNCSYNOPSISINFO">#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;</pre><p><code><code class="FUNCDEF">int select</code>(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN14413"></a><h2>Description</h2><p>With the <code class="FUNCTION">select()</code> function applications
can suspend execution until the driver has captured data or is ready
to accept data for output.</p><p>When streaming I/O has been negotiated this function waits
until a buffer has been filled or displayed and can be dequeued with
the <a href="#VIDIOC-QBUF"><code class="CONSTANT">VIDIOC_DQBUF</code></a> ioctl. When buffers are already in the outgoing
queue of the driver the function returns immediately.</p><p>On success <code class="FUNCTION">select()</code> returns the total
number of bits set in the <code class="STRUCTNAME">fd_set</code>s. When the
function timed out it returns a value of zero. On failure it returns
<span class="RETURNVALUE">-1</span> and the <code class="VARNAME">errno</code>
variable is set appropriately. When the application did not call
<a href="#VIDIOC-QBUF"><code class="CONSTANT">VIDIOC_QBUF</code></a> or <a href="#VIDIOC-STREAMON"><code class="CONSTANT">VIDIOC_STREAMON</code></a> yet the
<code class="FUNCTION">select()</code> function succeeds, setting the bit of
the file descriptor in <code class="PARAMETER">readfds</code> or
<code class="PARAMETER">writefds</code>, but subsequent <a href="#VIDIOC-QBUF"><code class="CONSTANT">VIDIOC_DQBUF</code></a> calls
will fail.<a name="AEN14434" href="#FTN.AEN14434"><span class="footnote">[26]</span></a></p><p>When use of the <code class="FUNCTION">read()</code> function has
been negotiated and the driver does not capture yet, the
<code class="FUNCTION">select()</code> function starts capturing. When that
fails, <code class="FUNCTION">select()</code> returns successful and a
subsequent <code class="FUNCTION">read()</code> call, which also attempts to
start capturing, will return an appropriate error code. When the
driver captures continuously (as opposed to, for example, still
images) and data is already available the
<code class="FUNCTION">select()</code> function returns immediately.</p><p>When use of the <code class="FUNCTION">write()</code> function has
been negotiated the <code class="FUNCTION">select()</code> function just waits
until the driver is ready for a non-blocking
<code class="FUNCTION">write()</code> call.</p><p>All drivers implementing the <code class="FUNCTION">read()</code> or
<code class="FUNCTION">write()</code> function or streaming I/O must also
support the <code class="FUNCTION">select()</code> function.</p><p>For more details see the <code class="FUNCTION">select()</code>
manual page.</p></div><div class="REFSECT1"><a name="AEN14457"></a><h2>Return Value</h2><p>On success, <code class="FUNCTION">select()</code> returns the number
of descriptors contained in the three returned descriptor sets, which
will be zero if the timeout expired. On error
<span class="RETURNVALUE">-1</span> is returned, and the
<code class="VARNAME">errno</code> variable is set appropriately; the sets and
<code class="PARAMETER">timeout</code> are undefined. Possible error codes
are:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EBADF</span></dt><dd><p>One or more of the file descriptor sets specified a
file descriptor that is not open.</p></dd><dt><span class="ERRORCODE">EBUSY</span></dt><dd><p>The driver does not support multiple read or write
streams and the device is already in use.</p></dd><dt><span class="ERRORCODE">EFAULT</span></dt><dd><p>The <code class="PARAMETER">readfds</code>,
<code class="PARAMETER">writefds</code>, <code class="PARAMETER">exceptfds</code> or
<code class="PARAMETER">timeout</code> pointer references an inaccessible memory
area.</p></dd><dt><span class="ERRORCODE">EINTR</span></dt><dd><p>The call was interrupted by a signal.</p></dd><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The <code class="PARAMETER">nfds</code> argument is less than
zero or greater than <code class="CONSTANT">FD_SETSIZE</code>.</p></dd></dl></div></div><h1><a name="FUNC-WRITE"></a>V4L2 write()</h1><div class="REFNAMEDIV"><a name="AEN14500"></a><h2>Name</h2>v4l2-write&nbsp;--&nbsp;Write to a V4L2 device</div><div class="REFSYNOPSISDIV"><a name="AEN14503"></a><h2>Synopsis</h2><div class="FUNCSYNOPSIS"><p></p><a name="AEN14504"></a><pre class="FUNCSYNOPSISINFO">#include &lt;unistd.h&gt;</pre><p><code><code class="FUNCDEF">ssize_t write</code>(int fd, void *buf, size_t count);</code></p><p></p></div></div><div class="REFSECT1"><a name="AEN14515"></a><h2>Arguments</h2><p></p><div class="VARIABLELIST"><dl><dt><code class="PARAMETER">fd</code></dt><dd><p>File descriptor returned by <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a>.</p></dd><dt><code class="PARAMETER">buf</code></dt><dd><p></p></dd><dt><code class="PARAMETER">count</code></dt><dd><p></p></dd></dl></div></div><div class="REFSECT1"><a name="AEN14535"></a><h2>Description</h2><p><code class="FUNCTION">write()</code> writes up to
<code class="PARAMETER">count</code> bytes to the device referenced by the
file descriptor <code class="PARAMETER">fd</code> from the buffer starting at
<code class="PARAMETER">buf</code>. When the hardware outputs are not active
yet, this function enables them. When <code class="PARAMETER">count</code> is
zero, <code class="FUNCTION">write()</code> returns
<span class="RETURNVALUE">0</span> without any other effect.</p><p>When the application does not provide more data in time, the
previous video frame, raw VBI image, sliced VPS or WSS data is
displayed again. Sliced Teletext or Closed Caption data is not
repeated, the driver inserts a blank line instead.</p></div><div class="REFSECT1"><a name="AEN14546"></a><h2>Return Value</h2><p>On success, the number of bytes written are returned. Zero
indicates nothing was written. On error, <span class="RETURNVALUE">-1</span>
is returned, and the <code class="VARNAME">errno</code> variable is set
appropriately. In this case the next write will start at the beginning
of a new frame. Possible error codes are:</p><p></p><div class="VARIABLELIST"><dl><dt><span class="ERRORCODE">EAGAIN</span></dt><dd><p>Non-blocking I/O has been selected using the <a href="#FUNC-OPEN"><code class="CONSTANT">O_NONBLOCK</code></a> flag and no
buffer space was available to write the data immediately.</p></dd><dt><span class="ERRORCODE">EBADF</span></dt><dd><p><code class="PARAMETER">fd</code> is not a valid file
descriptor or is not open for writing.</p></dd><dt><span class="ERRORCODE">EBUSY</span></dt><dd><p>The driver does not support multiple write streams and the
device is already in use.</p></dd><dt><span class="ERRORCODE">EFAULT</span></dt><dd><p><code class="PARAMETER">buf</code> references an inaccessible
memory area.</p></dd><dt><span class="ERRORCODE">EINTR</span></dt><dd><p>The call was interrupted by a signal before any
data was written.</p></dd><dt><span class="ERRORCODE">EIO</span></dt><dd><p>I/O error. This indicates some hardware problem.</p></dd><dt><span class="ERRORCODE">EINVAL</span></dt><dd><p>The <code class="FUNCTION">write()</code> function is not
supported by this driver, not on this device, or generally not on this
type of device.</p></dd></dl></div></div></div><div class="CHAPTER"><hr><h1><a name="DRIVER"></a>Chapter 5. V4L2 Driver Programming</h1><p>to do</p></div><div class="CHAPTER"><hr><h1><a name="COMPAT"></a>Chapter 6. Changes</h1><p>The following chapters document the evolution of the V4L2 API,
errata or extensions. They are also intended to help application and
driver writers to port or update their code.</p><div class="SECTION"><hr><h2 class="SECTION"><a name="DIFF-V4L">6.1. Differences between V4L and V4L2</a></h2><p>The Video For Linux API was first introduced in Linux 2.1 to
unify and replace various TV and radio device related interfaces,
developed independently by driver writers in prior years. Starting
with Linux 2.5 the much improved V4L2 API replaces the V4L API,
although existing drivers will continue to support V4L applications in
the future, either directly or through the V4L2 compatibility layer in
the <tt class="FILENAME">videodev</tt> kernel module translating ioctls on
the fly. For a transition period not all drivers will support the V4L2
API.</p><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN14602">6.1.1. Opening and Closing Devices</a></h3><p>For compatibility reasons the character device file names
recommended for V4L2 video capture, overlay, radio, teletext and raw
vbi capture devices did not change from those used by V4L. They are
listed in <a href="#DEVICES">Chapter 4</a> and below in <a href="#V4L-DEV">Table 6-1</a>.</p><p>The V4L <tt class="FILENAME">videodev</tt> module automatically
assigns minor numbers to drivers in load order, depending on the
registered device type. We recommend that V4L2 drivers by default
register devices with the same numbers, but the system administrator
can assign arbitrary minor numbers using driver module options. The
major device number remains 81.</p><div class="TABLE"><a name="V4L-DEV"></a><p><b>Table 6-1. V4L Device Types, Names and Numbers</b></p><table class="CALSTABLE" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Device Type</th><th>File Name</th><th>Minor Numbers</th></tr></thead><tbody valign="TOP"><tr><td>Video capture and overlay</td><td><p><tt class="FILENAME">/dev/video</tt> and
<tt class="FILENAME">/dev/bttv0</tt><sup>a</sup>,
<tt class="FILENAME">/dev/video0</tt> to
<tt class="FILENAME">/dev/video63</tt></p></td><td>0-63</td></tr><tr><td>Radio receiver</td><td><p><tt class="FILENAME">/dev/radio</tt><sup>b</sup>, <tt class="FILENAME">/dev/radio0</tt> to
<tt class="FILENAME">/dev/radio63</tt></p></td><td>64-127</td></tr><tr><td>Teletext decoder</td><td><p><tt class="FILENAME">/dev/vtx</tt>,
<tt class="FILENAME">/dev/vtx0</tt> to
<tt class="FILENAME">/dev/vtx31</tt></p></td><td>192-223</td></tr><tr><td>Raw VBI capture</td><td><p><tt class="FILENAME">/dev/vbi</tt>,
<tt class="FILENAME">/dev/vbi0</tt> to
<tt class="FILENAME">/dev/vbi31</tt></p></td><td>224-255</td></tr></tbody><tbody><tr><td colspan="3">Notes:<br><a name="FTN.AEN14624">a. </a>According to
Documentation/devices.txt these should be symbolic links to
<tt class="FILENAME">/dev/video0</tt>. Note the original bttv interface is
not compatible with V4L or V4L2.<br><a name="FTN.AEN14635">b. </a>According to
<tt class="FILENAME">Documentation/devices.txt</tt> a symbolic link to
<tt class="FILENAME">/dev/radio0</tt>.<br></td></tr></tbody></table></div><p>V4L prohibits (or used to prohibit) multiple opens of a
device file. V4L2 drivers <span class="emphasis"><i class="EMPHASIS">may</i></span> support multiple
opens, see <a href="#OPEN">Section 1.1</a> for details and consequences.</p><p>V4L drivers respond to V4L2 ioctls with an <span class="ERRORCODE">EINVAL</span> error code. The
compatibility layer in the V4L2 <tt class="FILENAME">videodev</tt> module
can translate V4L ioctl requests to their V4L2 counterpart, however a
V4L2 driver usually needs more preparation to become fully V4L
compatible. This is covered in more detail in <a href="#DRIVER">Chapter 5</a>.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN14665">6.1.2. Querying Capabilities</a></h3><p>The V4L <code class="CONSTANT">VIDIOCGCAP</code> ioctl is
equivalent to V4L2's <a href="#VIDIOC-QUERYCAP"><code class="CONSTANT">VIDIOC_QUERYCAP</code></a>.</p><p>The <code class="STRUCTFIELD">name</code> field in struct
<code class="STRUCTNAME">video_capability</code> became
<code class="STRUCTFIELD">card</code> in struct&nbsp;<a href="#V4L2-CAPABILITY">v4l2_capability</a>,
<code class="STRUCTFIELD">type</code> was replaced by
<code class="STRUCTFIELD">capabilities</code>. Note V4L2 does not
distinguish between device types like this, better think of basic
video input, video output and radio devices supporting a set of
related functions like video capturing, video overlay and VBI
capturing. See <a href="#OPEN">Section 1.1</a> for an
introduction.</p><div class="INFORMALTABLE"><p></p><a name="AEN14679"></a><table class="CALSTABLE" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>struct
<code class="STRUCTNAME">video_capability</code>
<code class="STRUCTFIELD">type</code></th><th>struct&nbsp;<a href="#V4L2-CAPABILITY">v4l2_capability</a>
<code class="STRUCTFIELD">capabilities</code> flags</th><th>Purpose</th></tr></thead><tbody valign="TOP"><tr><td><code class="CONSTANT">VID_TYPE_CAPTURE</code></td><td><code class="CONSTANT">V4L2_CAP_VIDEO_CAPTURE</code></td><td>The <a href="#CAPTURE">video
capture</a> interface is supported.</td></tr><tr><td><code class="CONSTANT">VID_TYPE_TUNER</code></td><td><code class="CONSTANT">V4L2_CAP_TUNER</code></td><td>The device has a <a href="#TUNER">tuner or
modulator</a>.</td></tr><tr><td><code class="CONSTANT">VID_TYPE_TELETEXT</code></td><td><code class="CONSTANT">V4L2_CAP_VBI_CAPTURE</code></td><td>The <a href="#RAW-VBI">raw VBI
capture</a> interface is supported.</td></tr><tr><td><code class="CONSTANT">VID_TYPE_OVERLAY</code></td><td><code class="CONSTANT">V4L2_CAP_VIDEO_OVERLAY</code></td><td>The <a href="#OVERLAY">video
overlay</a> interface is supported.</td></tr><tr><td><code class="CONSTANT">VID_TYPE_CHROMAKEY</code></td><td><code class="CONSTANT">V4L2_FBUF_CAP_CHROMAKEY</code> in
field <code class="STRUCTFIELD">capability</code> of
struct&nbsp;<a href="#V4L2-FRAMEBUFFER">v4l2_framebuffer</a></td><td>Whether chromakey overlay is supported. For
more information on overlay see
<a href="#OVERLAY">Section 4.2</a>.</td></tr><tr><td><code class="CONSTANT">VID_TYPE_CLIPPING</code></td><td><code class="CONSTANT">V4L2_FBUF_CAP_LIST_CLIPPING</code> 
and <code class="CONSTANT">V4L2_FBUF_CAP_BITMAP_CLIPPING</code> in field
<code class="STRUCTFIELD">capability</code> of struct&nbsp;<a href="#V4L2-FRAMEBUFFER">v4l2_framebuffer</a></td><td>Whether clipping the overlaid image is
supported, see <a href="#OVERLAY">Section 4.2</a>.</td></tr><tr><td><code class="CONSTANT">VID_TYPE_FRAMERAM</code></td><td><code class="CONSTANT">V4L2_FBUF_CAP_EXTERNOVERLAY</code> 
<span class="emphasis"><i class="EMPHASIS">not set</i></span> in field
<code class="STRUCTFIELD">capability</code> of struct&nbsp;<a href="#V4L2-FRAMEBUFFER">v4l2_framebuffer</a></td><td>Whether overlay overwrites frame buffer memory,
see <a href="#OVERLAY">Section 4.2</a>.</td></tr><tr><td><code class="CONSTANT">VID_TYPE_SCALES</code></td><td><code class="CONSTANT">-</code></td><td>This flag indicates if the hardware can scale
images. The V4L2 API implies the scale factor by setting the cropping
dimensions and image size with the <a href="#VIDIOC-G-CROP"><code class="CONSTANT">VIDIOC_S_CROP</code></a> and <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a>
ioctl, respectively. The driver returns the closest sizes possible.
For more information on cropping and scaling see <a href="#CROP">Section 1.11</a>.</td></tr><tr><td><code class="CONSTANT">VID_TYPE_MONOCHROME</code></td><td><code class="CONSTANT">-</code></td><td>Applications can enumerate the supported image
formats with the <a href="#VIDIOC-ENUM-FMT"><code class="CONSTANT">VIDIOC_ENUM_FMT</code></a> ioctl to determine if the device
supports grey scale capturing only. For more information on image
formats see <a href="#PIXFMT">Chapter 2</a>.</td></tr><tr><td><code class="CONSTANT">VID_TYPE_SUBCAPTURE</code></td><td><code class="CONSTANT">-</code></td><td>Applications can call the <a href="#VIDIOC-G-CROP"><code class="CONSTANT">VIDIOC_G_CROP</code></a> ioctl
to determine if the device supports capturing a subsection of the full
picture ("cropping" in V4L2). If not, the ioctl returns the <span class="ERRORCODE">EINVAL</span> error code.
For more information on cropping and scaling see <a href="#CROP">Section 1.11</a>.</td></tr><tr><td><code class="CONSTANT">VID_TYPE_MPEG_DECODER</code></td><td><code class="CONSTANT">-</code></td><td>Applications can enumerate the supported image
formats with the <a href="#VIDIOC-ENUM-FMT"><code class="CONSTANT">VIDIOC_ENUM_FMT</code></a> ioctl to determine if the device
supports MPEG streams.</td></tr><tr><td><code class="CONSTANT">VID_TYPE_MPEG_ENCODER</code></td><td><code class="CONSTANT">-</code></td><td>See above.</td></tr><tr><td><code class="CONSTANT">VID_TYPE_MJPEG_DECODER</code></td><td><code class="CONSTANT">-</code></td><td>See above.</td></tr><tr><td><code class="CONSTANT">VID_TYPE_MJPEG_ENCODER</code></td><td><code class="CONSTANT">-</code></td><td>See above.</td></tr></tbody></table><p></p></div><p></p><p>The <code class="STRUCTFIELD">audios</code> field was replaced
by <code class="STRUCTFIELD">capabilities</code> flag
<code class="CONSTANT">V4L2_CAP_AUDIO</code>, indicating
<span class="emphasis"><i class="EMPHASIS">if</i></span> the device has any audio inputs or outputs. To
determine their number applications can enumerate audio inputs with
the <a href="#VIDIOC-G-AUDIO"><code class="CONSTANT">VIDIOC_G_AUDIO</code></a> ioctl. The audio ioctls are described in <a href="#AUDIO">Section 1.5</a>.</p><p>The <code class="STRUCTFIELD">maxwidth</code>,
<code class="STRUCTFIELD">maxheight</code>,
<code class="STRUCTFIELD">minwidth</code> and
<code class="STRUCTFIELD">minheight</code> fields were removed. Calling the
<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> or <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_TRY_FMT</code></a> ioctl with the desired dimensions
returns the closest size possible, taking into account the current
video standard, cropping and scaling limitations.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN14821">6.1.3. Video Sources</a></h3><p>V4L provides the <code class="CONSTANT">VIDIOCGCHAN</code> and
<code class="CONSTANT">VIDIOCSCHAN</code> ioctl using struct
<code class="STRUCTNAME">video_channel</code> to enumerate
the video inputs of a V4L device. The equivalent V4L2 ioctls
are <a href="#VIDIOC-ENUMINPUT"><code class="CONSTANT">VIDIOC_ENUMINPUT</code></a>, <a href="#VIDIOC-G-INPUT"><code class="CONSTANT">VIDIOC_G_INPUT</code></a> and <a href="#VIDIOC-G-INPUT"><code class="CONSTANT">VIDIOC_S_INPUT</code></a>
using struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a> as discussed in <a href="#VIDEO">Section 1.4</a>.</p><p>The <code class="STRUCTFIELD">channel</code> field counting
inputs was renamed to <code class="STRUCTFIELD">index</code>, the video
input types were renamed as follows: </p><div class="INFORMALTABLE"><p></p><a name="AEN14838"></a><table class="CALSTABLE" border="1"><colgroup><col><col></colgroup><thead><tr><th>struct <code class="STRUCTNAME">video_channel</code>
<code class="STRUCTFIELD">type</code></th><th>struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a>
<code class="STRUCTFIELD">type</code></th></tr></thead><tbody valign="TOP"><tr><td><code class="CONSTANT">VIDEO_TYPE_TV</code></td><td><code class="CONSTANT">V4L2_INPUT_TYPE_TUNER</code></td></tr><tr><td><code class="CONSTANT">VIDEO_TYPE_CAMERA</code></td><td><code class="CONSTANT">V4L2_INPUT_TYPE_CAMERA</code></td></tr></tbody></table><p></p></div><p></p><p>Unlike the <code class="STRUCTFIELD">tuners</code> field
expressing the number of tuners of this input, V4L2 assumes each video
input is connected to at most one tuner. However a tuner can have more
than one input, i.&nbsp;e. RF connectors, and a device can have multiple
tuners. The index number of the tuner associated with the input, if
any, is stored in field <code class="STRUCTFIELD">tuner</code> of
struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a>. Enumeration of tuners is discussed in <a href="#TUNER">Section 1.6</a>.</p><p>The redundant <code class="CONSTANT">VIDEO_VC_TUNER</code> flag was
dropped. Video inputs associated with a tuner are of type
<code class="CONSTANT">V4L2_INPUT_TYPE_TUNER</code>. The
<code class="CONSTANT">VIDEO_VC_AUDIO</code> flag was replaced by the
<code class="STRUCTFIELD">audioset</code> field. V4L2 considers devices with
up to 32 audio inputs. Each set bit in the
<code class="STRUCTFIELD">audioset</code> field represents one audio input
this video input combines with. For information about audio inputs and
how to switch between them see <a href="#AUDIO">Section 1.5</a>.</p><p>The <code class="STRUCTFIELD">norm</code> field describing the
supported video standards was replaced by
<code class="STRUCTFIELD">std</code>. The V4L specification mentions a flag
<code class="CONSTANT">VIDEO_VC_NORM</code> indicating whether the standard can
be changed. This flag was a later addition together with the
<code class="STRUCTFIELD">norm</code> field and has been removed in the
meantime. V4L2 has a similar, albeit more comprehensive approach
to video standards, see <a href="#STANDARD">Section 1.7</a> for more
information.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN14877">6.1.4. Tuning</a></h3><p>The V4L <code class="CONSTANT">VIDIOCGTUNER</code> and
<code class="CONSTANT">VIDIOCSTUNER</code> ioctl and struct
<code class="STRUCTNAME">video_tuner</code> can be used to enumerate the
tuners of a V4L TV or radio device. The equivalent V4L2 ioctls are
<a href="#VIDIOC-G-TUNER"><code class="CONSTANT">VIDIOC_G_TUNER</code></a> and <a href="#VIDIOC-G-TUNER"><code class="CONSTANT">VIDIOC_S_TUNER</code></a> using struct&nbsp;<a href="#V4L2-TUNER">v4l2_tuner</a>. Tuners are
covered in <a href="#TUNER">Section 1.6</a>.</p><p>The <code class="STRUCTFIELD">tuner</code> field counting tuners
was renamed to <code class="STRUCTFIELD">index</code>. The fields
<code class="STRUCTFIELD">name</code>, <code class="STRUCTFIELD">rangelow</code>
and <code class="STRUCTFIELD">rangehigh</code> remained unchanged.</p><p>The <code class="CONSTANT">VIDEO_TUNER_PAL</code>,
<code class="CONSTANT">VIDEO_TUNER_NTSC</code> and
<code class="CONSTANT">VIDEO_TUNER_SECAM</code> flags indicating the supported
video standards were dropped. This information is now contained in the
associated struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a>. No replacement exists for the
<code class="CONSTANT">VIDEO_TUNER_NORM</code> flag indicating whether the
video standard can be switched. The <code class="STRUCTFIELD">mode</code>
field to select a different video standard was replaced by a whole new
set of ioctls and structures described in <a href="#STANDARD">Section 1.7</a>.
Due to its ubiquity it should be mentioned the BTTV driver supports
several standards in addition to the regular
<code class="CONSTANT">VIDEO_MODE_PAL</code> (0),
<code class="CONSTANT">VIDEO_MODE_NTSC</code>,
<code class="CONSTANT">VIDEO_MODE_SECAM</code> and
<code class="CONSTANT">VIDEO_MODE_AUTO</code> (3). Namely N/PAL Argentina,
M/PAL, N/PAL, and NTSC Japan with numbers 3-6 (sic).</p><p>The <code class="CONSTANT">VIDEO_TUNER_STEREO_ON</code> flag
indicating stereo reception became
<code class="CONSTANT">V4L2_TUNER_SUB_STEREO</code> in field
<code class="STRUCTFIELD">rxsubchans</code>. This field also permits the
detection of monaural and bilingual audio, see the definition of
struct&nbsp;<a href="#V4L2-TUNER">v4l2_tuner</a> for details. Presently no replacement exists for the
<code class="CONSTANT">VIDEO_TUNER_RDS_ON</code> and
<code class="CONSTANT">VIDEO_TUNER_MBS_ON</code> flags.</p><p> The <code class="CONSTANT">VIDEO_TUNER_LOW</code> flag was renamed
to <code class="CONSTANT">V4L2_TUNER_CAP_LOW</code> in the struct&nbsp;<a href="#V4L2-TUNER">v4l2_tuner</a>
<code class="STRUCTFIELD">capability</code> field.</p><p>The <code class="CONSTANT">VIDIOCGFREQ</code> and
<code class="CONSTANT">VIDIOCSFREQ</code> ioctl to change the tuner frequency
where renamed to <a href="#VIDIOC-G-FREQUENCY"><code class="CONSTANT">VIDIOC_G_FREQUENCY</code></a> and  <a href="#VIDIOC-G-FREQUENCY"><code class="CONSTANT">VIDIOC_S_FREQUENCY</code></a>. They
take a pointer to a struct&nbsp;<a href="#V4L2-FREQUENCY">v4l2_frequency</a> instead of an unsigned long
integer.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="V4L-IMAGE-PROPERTIES">6.1.5. Image Properties</a></h3><p>V4L2 has no equivalent of the
<code class="CONSTANT">VIDIOCGPICT</code> and <code class="CONSTANT">VIDIOCSPICT</code>
ioctl and struct <code class="STRUCTNAME">video_picture</code>. The following
fields where replaced by V4L2 controls accessible with the
<a href="#VIDIOC-QUERYCTRL"><code class="CONSTANT">VIDIOC_QUERYCTRL</code></a>, <a href="#VIDIOC-G-CTRL"><code class="CONSTANT">VIDIOC_G_CTRL</code></a> and <a href="#VIDIOC-G-CTRL"><code class="CONSTANT">VIDIOC_S_CTRL</code></a> ioctls:</p><div class="INFORMALTABLE"><p></p><a name="AEN14939"></a><table class="CALSTABLE" border="1"><colgroup><col><col></colgroup><thead><tr><th>struct <code class="STRUCTNAME">video_picture</code></th><th>V4L2 Control ID</th></tr></thead><tbody valign="TOP"><tr><td><code class="STRUCTFIELD">brightness</code></td><td><code class="CONSTANT">V4L2_CID_BRIGHTNESS</code></td></tr><tr><td><code class="STRUCTFIELD">hue</code></td><td><code class="CONSTANT">V4L2_CID_HUE</code></td></tr><tr><td><code class="STRUCTFIELD">colour</code></td><td><code class="CONSTANT">V4L2_CID_SATURATION</code></td></tr><tr><td><code class="STRUCTFIELD">contrast</code></td><td><code class="CONSTANT">V4L2_CID_CONTRAST</code></td></tr><tr><td><code class="STRUCTFIELD">whiteness</code></td><td><code class="CONSTANT">V4L2_CID_WHITENESS</code></td></tr></tbody></table><p></p></div><p></p><p>The V4L picture controls are assumed to range from 0 to
65535 with no particular reset value. The V4L2 API permits arbitrary
limits and defaults which can be queried with the <a href="#VIDIOC-QUERYCTRL"><code class="CONSTANT">VIDIOC_QUERYCTRL</code></a>
ioctl. For general information about controls see <a href="#CONTROL">Section 1.8</a>.</p><p>The <code class="STRUCTFIELD">depth</code> (average number of
bits per pixel) of a video image is implied by the selected image
format. V4L2 does not explicitely provide such information assuming
applications recognizing the format are aware of the image depth and
others need not know. The <code class="STRUCTFIELD">palette</code> field
moved into the struct&nbsp;<a href="#V4L2-PIX-FORMAT">v4l2_pix_format</a>:</p><div class="INFORMALTABLE"><p></p><a name="AEN14980"></a><table class="CALSTABLE" border="1"><colgroup><col><col></colgroup><thead><tr><th>struct <code class="STRUCTNAME">video_picture</code>
<code class="STRUCTFIELD">palette</code></th><th>struct&nbsp;<a href="#V4L2-PIX-FORMAT">v4l2_pix_format</a>
<code class="STRUCTFIELD">pixfmt</code></th></tr></thead><tbody valign="TOP"><tr><td><code class="CONSTANT">VIDEO_PALETTE_GREY</code></td><td><p><a href="#V4L2-PIX-FMT-GREY"><code class="CONSTANT">V4L2_PIX_FMT_GREY</code></a></p></td></tr><tr><td><code class="CONSTANT">VIDEO_PALETTE_HI240</code></td><td><p><a href="#PIXFMT-RESERVED"><code class="CONSTANT">V4L2_PIX_FMT_HI240</code></a><sup>a</sup></p></td></tr><tr><td><code class="CONSTANT">VIDEO_PALETTE_RGB565</code></td><td><p><a href="#PIXFMT-RGB"><code class="CONSTANT">V4L2_PIX_FMT_RGB565</code></a></p></td></tr><tr><td><code class="CONSTANT">VIDEO_PALETTE_RGB555</code></td><td><p><a href="#PIXFMT-RGB"><code class="CONSTANT">V4L2_PIX_FMT_RGB555</code></a></p></td></tr><tr><td><code class="CONSTANT">VIDEO_PALETTE_RGB24</code></td><td><p><a href="#PIXFMT-RGB"><code class="CONSTANT">V4L2_PIX_FMT_BGR24</code></a></p></td></tr><tr><td><code class="CONSTANT">VIDEO_PALETTE_RGB32</code></td><td><p><a href="#PIXFMT-RGB"><code class="CONSTANT">V4L2_PIX_FMT_BGR32</code></a><sup>b</sup></p></td></tr><tr><td><code class="CONSTANT">VIDEO_PALETTE_YUV422</code></td><td><p><a href="#V4L2-PIX-FMT-YUYV"><code class="CONSTANT">V4L2_PIX_FMT_YUYV</code></a></p></td></tr><tr><td><p><code class="CONSTANT">VIDEO_PALETTE_YUYV</code><sup>c</sup></p></td><td><p><a href="#V4L2-PIX-FMT-YUYV"><code class="CONSTANT">V4L2_PIX_FMT_YUYV</code></a></p></td></tr><tr><td><code class="CONSTANT">VIDEO_PALETTE_UYVY</code></td><td><p><a href="#V4L2-PIX-FMT-UYVY"><code class="CONSTANT">V4L2_PIX_FMT_UYVY</code></a></p></td></tr><tr><td><code class="CONSTANT">VIDEO_PALETTE_YUV420</code></td><td>None</td></tr><tr><td><code class="CONSTANT">VIDEO_PALETTE_YUV411</code></td><td><p><a href="#V4L2-PIX-FMT-Y41P"><code class="CONSTANT">V4L2_PIX_FMT_Y41P</code></a><sup>d</sup></p></td></tr><tr><td><code class="CONSTANT">VIDEO_PALETTE_RAW</code></td><td><p>None<sup>e</sup></p></td></tr><tr><td><code class="CONSTANT">VIDEO_PALETTE_YUV422P</code></td><td><p><a href="#V4L2-PIX-FMT-YUV422P"><code class="CONSTANT">V4L2_PIX_FMT_YUV422P</code></a></p></td></tr><tr><td><code class="CONSTANT">VIDEO_PALETTE_YUV411P</code></td><td><p><a href="#V4L2-PIX-FMT-YUV411P"><code class="CONSTANT">V4L2_PIX_FMT_YUV411P</code></a><sup>f</sup></p></td></tr><tr><td><code class="CONSTANT">VIDEO_PALETTE_YUV420P</code></td><td><p><a href="#V4L2-PIX-FMT-YVU420"><code class="CONSTANT">V4L2_PIX_FMT_YVU420</code></a></p></td></tr><tr><td><code class="CONSTANT">VIDEO_PALETTE_YUV410P</code></td><td><p><a href="#V4L2-PIX-FMT-YVU410"><code class="CONSTANT">V4L2_PIX_FMT_YVU410</code></a></p></td></tr></tbody><tbody><tr><td colspan="2">Notes:<br><a name="FTN.AEN15005">a. </a>This is a custom format used by the BTTV
driver, not one of the V4L2 standard formats.<br><a name="FTN.AEN15035">b. </a>Presumably
 all V4L RGB formats are
little-endian, although some drivers might interpret them according to 
machine endianess. V4L2 defines little-endian, big-endian and red/blue
swapped variants. For details see <a href="#PIXFMT-RGB">Section 2.4</a>.<br><a name="FTN.AEN15049">c. </a><code class="CONSTANT">VIDEO_PALETTE_YUV422</code>
and <code class="CONSTANT">VIDEO_PALETTE_YUYV</code> are the same formats. Some
V4L drivers respond to one, some to the other.<br><a name="FTN.AEN15075">d. </a>Not to be confused with
<code class="CONSTANT">V4L2_PIX_FMT_YUV411P</code>, which is a planar
format.<br><a name="FTN.AEN15083">e. </a>V4L explains this
as: "RAW capture (BT848)"<br><a name="FTN.AEN15099">f. </a>Not to be confused with
<code class="CONSTANT">V4L2_PIX_FMT_Y41P</code>, which is a packed
format.<br></td></tr></tbody></table><p></p></div><p></p><p>V4L2 image formats are defined in <a href="#PIXFMT">Chapter 2</a>. The image format can be selected with the
<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN15120">6.1.6. Audio</a></h3><p>The <code class="CONSTANT">VIDIOCGAUDIO</code> and
<code class="CONSTANT">VIDIOCSAUDIO</code> ioctl and struct
<code class="STRUCTNAME">video_audio</code> are used to enumerate the
audio inputs of a V4L device. The equivalent V4L2 ioctls are
<a href="#VIDIOC-G-AUDIO"><code class="CONSTANT">VIDIOC_G_AUDIO</code></a> and <a href="#VIDIOC-G-AUDIO"><code class="CONSTANT">VIDIOC_S_AUDIO</code></a> using struct&nbsp;<a href="#V4L2-AUDIO">v4l2_audio</a> as
discussed in <a href="#AUDIO">Section 1.5</a>.</p><p>The <code class="STRUCTFIELD">audio</code> "channel number"
field counting audio inputs was renamed to
<code class="STRUCTFIELD">index</code>.</p><p>On <code class="CONSTANT">VIDIOCSAUDIO</code> the
<code class="STRUCTFIELD">mode</code> field selects <span class="emphasis"><i class="EMPHASIS">one</i></span>
of the <code class="CONSTANT">VIDEO_SOUND_MONO</code>,
<code class="CONSTANT">VIDEO_SOUND_STEREO</code>,
<code class="CONSTANT">VIDEO_SOUND_LANG1</code> or
<code class="CONSTANT">VIDEO_SOUND_LANG2</code> audio demodulation modes. When
the current audio standard is BTSC
<code class="CONSTANT">VIDEO_SOUND_LANG2</code> refers to SAP and
<code class="CONSTANT">VIDEO_SOUND_LANG1</code> is meaningless. Also
undocumented in the V4L specification, there is no way to query the
selected mode. On <code class="CONSTANT">VIDIOCGAUDIO</code> the driver returns
the <span class="emphasis"><i class="EMPHASIS">actually received</i></span> audio programmes in this
field. In the V4L2 API this information is stored in the struct&nbsp;<a href="#V4L2-TUNER">v4l2_tuner</a>
<code class="STRUCTFIELD">rxsubchans</code> and
<code class="STRUCTFIELD">audmode</code> fields, respectively. See <a href="#TUNER">Section 1.6</a> for more information on tuners. Related to audio
modes struct&nbsp;<a href="#V4L2-AUDIO">v4l2_audio</a> also reports if this is a mono or stereo
input, regardless if the source is a tuner.</p><p>The following fields where replaced by V4L2 controls
accessible with the <a href="#VIDIOC-QUERYCTRL"><code class="CONSTANT">VIDIOC_QUERYCTRL</code></a>, <a href="#VIDIOC-G-CTRL"><code class="CONSTANT">VIDIOC_G_CTRL</code></a> and
<a href="#VIDIOC-G-CTRL"><code class="CONSTANT">VIDIOC_S_CTRL</code></a> ioctls:</p><div class="INFORMALTABLE"><p></p><a name="AEN15159"></a><table class="CALSTABLE" border="1"><colgroup><col><col></colgroup><thead><tr><th>struct
<code class="STRUCTNAME">video_audio</code></th><th>V4L2 Control ID</th></tr></thead><tbody valign="TOP"><tr><td><code class="STRUCTFIELD">volume</code></td><td><code class="CONSTANT">V4L2_CID_AUDIO_VOLUME</code></td></tr><tr><td><code class="STRUCTFIELD">bass</code></td><td><code class="CONSTANT">V4L2_CID_AUDIO_BASS</code></td></tr><tr><td><code class="STRUCTFIELD">treble</code></td><td><code class="CONSTANT">V4L2_CID_AUDIO_TREBLE</code></td></tr><tr><td><code class="STRUCTFIELD">balance</code></td><td><code class="CONSTANT">V4L2_CID_AUDIO_BALANCE</code></td></tr></tbody></table><p></p></div><p></p><p>To determine which of these controls are supported by a
driver V4L provides the <code class="STRUCTFIELD">flags</code>
<code class="CONSTANT">VIDEO_AUDIO_VOLUME</code>,
<code class="CONSTANT">VIDEO_AUDIO_BASS</code>,
<code class="CONSTANT">VIDEO_AUDIO_TREBLE</code> and
<code class="CONSTANT">VIDEO_AUDIO_BALANCE</code>. In the V4L2 API the
<a href="#VIDIOC-QUERYCTRL"><code class="CONSTANT">VIDIOC_QUERYCTRL</code></a> ioctl reports if the respective control is
supported. Accordingly the <code class="CONSTANT">VIDEO_AUDIO_MUTABLE</code>
and <code class="CONSTANT">VIDEO_AUDIO_MUTE</code> flags where replaced by the
boolean <code class="CONSTANT">V4L2_CID_AUDIO_MUTE</code> control.</p><p>All V4L2 controls have a <code class="STRUCTFIELD">step</code>
attribute replacing the struct <code class="STRUCTNAME">video_audio</code>
<code class="STRUCTFIELD">step</code> field. The V4L audio controls are
assumed to range from 0 to 65535 with no particular reset value. The
V4L2 API permits arbitrary limits and defaults which can be queried
with the <a href="#VIDIOC-QUERYCTRL"><code class="CONSTANT">VIDIOC_QUERYCTRL</code></a> ioctl. For general information about
controls see <a href="#CONTROL">Section 1.8</a>.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN15205">6.1.7. Frame Buffer Overlay</a></h3><p>The V4L2 ioctls equivalent to
<code class="CONSTANT">VIDIOCGFBUF</code> and <code class="CONSTANT">VIDIOCSFBUF</code>
are <a href="#VIDIOC-G-FBUF"><code class="CONSTANT">VIDIOC_G_FBUF</code></a> and <a href="#VIDIOC-G-FBUF"><code class="CONSTANT">VIDIOC_S_FBUF</code></a>. The
<code class="STRUCTFIELD">base</code> field of struct
<code class="STRUCTNAME">video_buffer</code> remained unchanged, except V4L2
defines a flag to indicate non-destructive overlays instead of a
<code class="CONSTANT">NULL</code> pointer. All other fields moved into the
struct&nbsp;<a href="#V4L2-PIX-FORMAT">v4l2_pix_format</a> <code class="STRUCTFIELD">fmt</code> substructure of
struct&nbsp;<a href="#V4L2-FRAMEBUFFER">v4l2_framebuffer</a>. The <code class="STRUCTFIELD">depth</code> field was
replaced by <code class="STRUCTFIELD">pixelformat</code>. See <a href="#PIXFMT-RGB">Section 2.4</a> for a list of RGB formats and their
respective color depths.</p><p>Instead of the special ioctls
<code class="CONSTANT">VIDIOCGWIN</code> and <code class="CONSTANT">VIDIOCSWIN</code>
V4L2 uses the general-purpose data format negotiation ioctls
<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_G_FMT</code></a> and <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a>. They take a pointer to a
struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a> as argument. Here the <code class="STRUCTFIELD">win</code>
member of the <code class="STRUCTFIELD">fmt</code> union is used, a
struct&nbsp;<a href="#V4L2-WINDOW">v4l2_window</a>.</p><p>The <code class="STRUCTFIELD">x</code>,
<code class="STRUCTFIELD">y</code>, <code class="STRUCTFIELD">width</code> and
<code class="STRUCTFIELD">height</code> fields of struct
<code class="STRUCTNAME">video_window</code> moved into struct&nbsp;<a href="#V4L2-RECT">v4l2_rect</a>
substructure <code class="STRUCTFIELD">w</code> of struct
<code class="STRUCTNAME">v4l2_window</code>. The
<code class="STRUCTFIELD">chromakey</code>,
<code class="STRUCTFIELD">clips</code>, and
<code class="STRUCTFIELD">clipcount</code> fields remained unchanged. Struct
<code class="STRUCTNAME">video_clip</code> was renamed to struct&nbsp;<a href="#V4L2-CLIP">v4l2_clip</a>, also
containing a struct <code class="STRUCTNAME">v4l2_rect</code>, but the
semantics are still the same.</p><p>The <code class="CONSTANT">VIDEO_WINDOW_INTERLACE</code> flag was
dropped. Instead applications must set the
<code class="STRUCTFIELD">field</code> field to
<code class="CONSTANT">V4L2_FIELD_ANY</code> or
<code class="CONSTANT">V4L2_FIELD_INTERLACED</code>. The
<code class="CONSTANT">VIDEO_WINDOW_CHROMAKEY</code> flag moved into
struct&nbsp;<a href="#V4L2-FRAMEBUFFER">v4l2_framebuffer</a>, under the new name
<code class="CONSTANT">V4L2_FBUF_FLAG_CHROMAKEY</code>.</p><p>In V4L, storing a bitmap pointer in
<code class="STRUCTFIELD">clips</code> and setting
<code class="STRUCTFIELD">clipcount</code> to
<code class="CONSTANT">VIDEO_CLIP_BITMAP</code> (-1) requests bitmap
clipping, using a fixed size bitmap of 1024 ¡Á 625 bits. Struct
<code class="STRUCTNAME">v4l2_window</code> has a separate
<code class="STRUCTFIELD">bitmap</code> pointer field for this purpose and
the bitmap size is determined by <code class="STRUCTFIELD">w.width</code> and
<code class="STRUCTFIELD">w.height</code>.</p><p>The <code class="CONSTANT">VIDIOCCAPTURE</code> ioctl to enable or
disable overlay was renamed to <a href="#VIDIOC-OVERLAY"><code class="CONSTANT">VIDIOC_OVERLAY</code></a>.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN15269">6.1.8. Cropping</a></h3><p>To capture only a subsection of the full picture V4L
defines the <code class="CONSTANT">VIDIOCGCAPTURE</code> and
<code class="CONSTANT">VIDIOCSCAPTURE</code> ioctls using struct
<code class="STRUCTNAME">video_capture</code>. The equivalent V4L2 ioctls are
<a href="#VIDIOC-G-CROP"><code class="CONSTANT">VIDIOC_G_CROP</code></a> and <a href="#VIDIOC-G-CROP"><code class="CONSTANT">VIDIOC_S_CROP</code></a> using struct&nbsp;<a href="#V4L2-CROP">v4l2_crop</a>, and the related
<a href="#VIDIOC-CROPCAP"><code class="CONSTANT">VIDIOC_CROPCAP</code></a> ioctl. This is a rather complex matter, see
<a href="#CROP">Section 1.11</a> for details.</p><p>The <code class="STRUCTFIELD">x</code>,
<code class="STRUCTFIELD">y</code>, <code class="STRUCTFIELD">width</code> and
<code class="STRUCTFIELD">height</code> fields moved into struct&nbsp;<a href="#V4L2-RECT">v4l2_rect</a>
substructure <code class="STRUCTFIELD">c</code> of struct
<code class="STRUCTNAME">v4l2_crop</code>. The
<code class="STRUCTFIELD">decimation</code> field was dropped. In the V4L2
API the scaling factor is implied by the size of the cropping
rectangle and the size of the captured or overlaid image.</p><p>The <code class="CONSTANT">VIDEO_CAPTURE_ODD</code>
and <code class="CONSTANT">VIDEO_CAPTURE_EVEN</code> flags to capture only the
odd or even field, respectively, were replaced by
<code class="CONSTANT">V4L2_FIELD_TOP</code> and
<code class="CONSTANT">V4L2_FIELD_BOTTOM</code> in the field named
<code class="STRUCTFIELD">field</code> of struct&nbsp;<a href="#V4L2-PIX-FORMAT">v4l2_pix_format</a> and
struct&nbsp;<a href="#V4L2-WINDOW">v4l2_window</a>. These structures are used to select a capture or
overlay format with the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN15302">6.1.9. Reading Images, Memory Mapping</a></h3><div class="SECTION"><h4 class="SECTION"><a name="AEN15304">6.1.9.1. Capturing using the read method</a></h4><p>There is no essential difference between reading images
from a V4L or V4L2 device using the <a href="#FUNC-READ"><code class="FUNCTION">read()</code></a> function, however V4L2
drivers are not required to support this I/O method. Applications can
determine if the function is available with the <a href="#VIDIOC-QUERYCAP"><code class="CONSTANT">VIDIOC_QUERYCAP</code></a>
ioctl. All V4L2 devices exchanging data with applications must support
the <a href="#FUNC-SELECT"><code class="FUNCTION">select()</code></a> and <a href="#FUNC-POLL"><code class="FUNCTION">poll()</code></a> functions.</p><p>To select an image format and size, V4L provides the
<code class="CONSTANT">VIDIOCSPICT</code> and <code class="CONSTANT">VIDIOCSWIN</code>
ioctls. V4L2 uses the general-purpose data format negotiation ioctls
<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_G_FMT</code></a> and <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a>. They take a pointer to a
struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a> as argument, here the struct&nbsp;<a href="#V4L2-PIX-FORMAT">v4l2_pix_format</a> named
<code class="STRUCTFIELD">pix</code> of its <code class="STRUCTFIELD">fmt</code>
union is used.</p><p>For more information about the V4L2 read interface see
<a href="#RW">Section 3.1</a>.</p></div><div class="SECTION"><hr><h4 class="SECTION"><a name="AEN15328">6.1.9.2. Capturing using memory mapping</a></h4><p>Applications can read from V4L devices by mapping
buffers in device memory, or more often just buffers allocated in
DMA-able system memory, into their address space. This avoids the data
copying overhead of the read method. V4L2 supports memory mapping as
well, with a few differences.</p><div class="INFORMALTABLE"><p></p><a name="AEN15331"></a><table class="CALSTABLE" border="1"><colgroup><col><col></colgroup><thead><tr><th>V4L</th><th>V4L2</th></tr></thead><tbody valign="TOP"><tr><td>&nbsp;</td><td>The image format must be selected before
buffers are allocated, with the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl. When no format
is selected the driver may use the last, possibly by another
application requested format.</td></tr><tr><td><p>Applications cannot change the number of
buffers. The it is built into the driver, unless it has a module
option to change the number when the driver module is
loaded.</p></td><td><p>The <a href="#VIDIOC-REQBUFS"><code class="CONSTANT">VIDIOC_REQBUFS</code></a> ioctl allocates the
desired number of buffers, this is a required step in the initialization
sequence.</p></td></tr><tr><td><p>Drivers map all buffers as one contiguous
range of memory. The <code class="CONSTANT">VIDIOCGMBUF</code> ioctl is
available to query the number of buffers, the offset of each buffer
from the start of the virtual file, and the overall amount of memory
used, which can be used as arguments for the <a href="#FUNC-MMAP"><code class="FUNCTION">mmap()</code></a>
function.</p></td><td><p>Buffers are individually mapped. The
offset and size of each buffer can be determined with the
<a href="#VIDIOC-QUERYBUF"><code class="CONSTANT">VIDIOC_QUERYBUF</code></a> ioctl.</p></td></tr><tr><td><p>The <code class="CONSTANT">VIDIOCMCAPTURE</code>
ioctl prepares a buffer for capturing. It also determines the image
format for this buffer. The ioctl returns immediately, eventually with
an <span class="ERRORCODE">EAGAIN</span> error code if no video signal had been detected. When the driver
supports more than one buffer applications can call the ioctl multiple
times and thus have multiple outstanding capture
requests.</p><p>The <code class="CONSTANT">VIDIOCSYNC</code> ioctl
suspends execution until a particular buffer has been
filled.</p></td><td><p>Drivers maintain an incoming and outgoing
queue. <a href="#VIDIOC-QBUF"><code class="CONSTANT">VIDIOC_QBUF</code></a> enqueues any empty buffer into the incoming
queue. Filled buffers are dequeued from the outgoing queue with the
<a href="#VIDIOC-QBUF"><code class="CONSTANT">VIDIOC_DQBUF</code></a> ioctl. To wait until filled buffers become available this
function, <a href="#FUNC-SELECT"><code class="FUNCTION">select()</code></a> or <a href="#FUNC-POLL"><code class="FUNCTION">poll()</code></a> can be used. The
<a href="#VIDIOC-STREAMON"><code class="CONSTANT">VIDIOC_STREAMON</code></a> ioctl must be called once after enqueuing one or
more buffers to start capturing. Its counterpart
<a href="#VIDIOC-STREAMON"><code class="CONSTANT">VIDIOC_STREAMOFF</code></a> stops capturing and dequeues all buffers from both
queues. Applications can query the signal status, if known, with the 
<a href="#VIDIOC-ENUMINPUT"><code class="CONSTANT">VIDIOC_ENUMINPUT</code></a> ioctl.</p></td></tr></tbody></table><p></p></div><p>For a more in-depth discussion of memory mapping and
examples, see <a href="#MMAP">Section 3.2</a>.</p></div></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN15385">6.1.10. Reading Raw VBI Data</a></h3><p>Originally the V4L API did not specify a raw VBI capture
interface, only the device file <tt class="FILENAME">/dev/vbi</tt> was
reserved for this purpose. The only driver supporting this interface
was the BTTV driver, de-facto defining the V4L VBI interface. Reading
from the device yields a raw VBI image with the following
parameters:</p><div class="INFORMALTABLE"><p></p><a name="AEN15389"></a><table class="CALSTABLE" border="1"><colgroup><col><col></colgroup><thead><tr><th>struct&nbsp;<a href="#V4L2-VBI-FORMAT">v4l2_vbi_format</a></th><th>V4L, BTTV driver</th></tr></thead><tbody valign="TOP"><tr><td>sampling_rate</td><td>28636363&nbsp;Hz NTSC (or any other 525-line
standard); 35468950&nbsp;Hz PAL and SECAM (625-line standards)</td></tr><tr><td>offset</td><td>?</td></tr><tr><td>samples_per_line</td><td>2048</td></tr><tr><td>sample_format</td><td>V4L2_PIX_FMT_GREY. The last four bytes (a
machine endianess integer) contain a frame counter.</td></tr><tr><td>start[]</td><td>10, 273 NTSC; 22, 335 PAL and SECAM</td></tr><tr><td>count[]</td><td><p>16, 16<sup>a</sup></p></td></tr><tr><td>flags</td><td>0</td></tr></tbody><tbody><tr><td colspan="2">Notes:<br><a name="FTN.AEN15416">a. </a>Old driver
versions used different values, eventually the custom
<code class="CONSTANT">BTTV_VBISIZE</code> ioctl was added to query the
correct values.<br></td></tr></tbody></table><p></p></div><p></p><p>Undocumented in the V4L specification, in Linux 2.3 the
<code class="CONSTANT">VIDIOCGVBIFMT</code> and
<code class="CONSTANT">VIDIOCSVBIFMT</code> ioctls using struct
<code class="STRUCTNAME">vbi_format</code> were added to determine the VBI
image parameters. These ioctls are only partially compatible with the
V4L2 VBI interface specified in <a href="#RAW-VBI">Section 4.7</a>.</p><p>An <code class="STRUCTFIELD">offset</code> field does not
exist, <code class="STRUCTFIELD">sample_format</code> is supposed to be
<code class="CONSTANT">VIDEO_PALETTE_RAW</code>, equivalent to 
<code class="CONSTANT">V4L2_PIX_FMT_GREY</code>. The remaining fields are
probably equivalent to struct&nbsp;<a href="#V4L2-VBI-FORMAT">v4l2_vbi_format</a>.</p><p>Apparently only the Zoran (ZR 36120) driver implements
these ioctls. The semantics differ from those specified for V4L2 in two
ways. The parameters are reset on <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a> and
<code class="CONSTANT">VIDIOCSVBIFMT</code> always returns an <span class="ERRORCODE">EINVAL</span> error code if the
parameters are invalid.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN15438">6.1.11. Miscellaneous</a></h3><p>V4L2 has no equivalent of the
<code class="CONSTANT">VIDIOCGUNIT</code> ioctl. Applications can find the VBI
device associated with a video capture device (or vice versa) by
reopening the device and requesting VBI data. For details see
<a href="#OPEN">Section 1.1</a>.</p><p>No replacement exists for <code class="CONSTANT">VIDIOCKEY</code>,
and the V4L functions for microcode programming. A new interface for
MPEG compression and playback devices is documented in <a href="#EXTENDED-CONTROLS">Section 1.9</a>.</p></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="HIST-V4L2">6.2. Changes of the V4L2 API</a></h2><p>Soon after the V4L API was added to the kernel it was
criticised as too inflexible. In August 1998 Bill Dirks proposed a
number of improvements and began to work on documentation, example
drivers and applications. With the help of other volunteers this
eventually became the V4L2 API, not just an extension but a
replacement for the V4L API. However it took another four years and
two stable kernel releases until the new API was finally accepted for
inclusion into the kernel in its present form.</p><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN15449">6.2.1. Early Versions</a></h3><p>1998-08-20: First version.</p><p>1998-08-27: The <a href="#FUNC-SELECT"><code class="FUNCTION">select()</code></a> function was introduced.</p><p>1998-09-10: New video standard interface.</p><p>1998-09-18: The <code class="CONSTANT">VIDIOC_NONCAP</code> ioctl
was replaced by the otherwise meaningless <code class="CONSTANT">O_TRUNC</code>
<a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a> flag, and the aliases <code class="CONSTANT">O_NONCAP</code> and
<code class="CONSTANT">O_NOIO</code> were defined. Applications can set this
flag if they intend to access controls only, as opposed to capture
applications which need exclusive access. The
<code class="CONSTANT">VIDEO_STD_XXX</code> identifiers are now ordinals
instead of flags, and the <code class="FUNCTION">video_std_construct()</code>
helper function takes id and transmission arguments.</p><p>1998-09-28: Revamped video standard. Made video controls
individually enumerable.</p><p>1998-10-02: The <code class="STRUCTFIELD">id</code> field was
removed from struct <code class="STRUCTNAME">video_standard</code> and the
color subcarrier fields were renamed. The <a href="#VIDIOC-QUERYSTD"><code class="CONSTANT">VIDIOC_QUERYSTD</code></a> ioctl was
renamed to <a href="#VIDIOC-ENUMSTD"><code class="CONSTANT">VIDIOC_ENUMSTD</code></a>, <a href="#VIDIOC-G-INPUT"><code class="CONSTANT">VIDIOC_G_INPUT</code></a> to <a href="#VIDIOC-ENUMINPUT"><code class="CONSTANT">VIDIOC_ENUMINPUT</code></a>. A
first draft of the Codec API was released.</p><p>1998-11-08: Many minor changes. Most symbols have been
renamed. Some material changes to struct&nbsp;<a href="#V4L2-CAPABILITY">v4l2_capability</a>.</p><p>1998-11-12: The read/write directon of some ioctls was misdefined.</p><p>1998-11-14: <code class="CONSTANT">V4L2_PIX_FMT_RGB24</code>
changed to <code class="CONSTANT">V4L2_PIX_FMT_BGR24</code>, and
<code class="CONSTANT">V4L2_PIX_FMT_RGB32</code> changed to
<code class="CONSTANT">V4L2_PIX_FMT_BGR32</code>. Audio controls are now
accessible with the <a href="#VIDIOC-G-CTRL"><code class="CONSTANT">VIDIOC_G_CTRL</code></a> and <a href="#VIDIOC-G-CTRL"><code class="CONSTANT">VIDIOC_S_CTRL</code></a> ioctls under
names starting with <code class="CONSTANT">V4L2_CID_AUDIO</code>. The
<code class="CONSTANT">V4L2_MAJOR</code> define was removed from
<tt class="FILENAME">videodev.h</tt> since it was only used once in the
<tt class="FILENAME">videodev</tt> kernel module. The
<code class="CONSTANT">YUV422</code> and <code class="CONSTANT">YUV411</code> planar
image formats were added.</p><p>1998-11-28: A few ioctl symbols changed. Interfaces for codecs and
video output devices were added.</p><p>1999-01-14: A raw VBI capture interface was added.</p><p>1999-01-19: The <code class="CONSTANT">VIDIOC_NEXTBUF</code> ioctl
      was removed.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN15499">6.2.2. V4L2 Version 0.16 1999-01-31</a></h3><p>1999-01-27: There is now one QBUF ioctl, VIDIOC_QWBUF and VIDIOC_QRBUF
are gone. VIDIOC_QBUF takes a v4l2_buffer as a parameter. Added
digital zoom (cropping) controls.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN15502">6.2.3. V4L2 Version 0.18 1999-03-16</a></h3><p>Added a v4l to V4L2 ioctl compatibility layer to
videodev.c. Driver writers, this changes how you implement your ioctl
handler. See the Driver Writer's Guide. Added some more control id
codes.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN15505">6.2.4. V4L2 Version 0.19 1999-06-05</a></h3><p>1999-03-18: Fill in the category and catname fields of
v4l2_queryctrl objects before passing them to the driver. Required a
minor change to the VIDIOC_QUERYCTRL handlers in the sample
drivers.</p><p>1999-03-31: Better compatibility for v4l memory capture
ioctls. Requires changes to drivers to fully support new compatibility
features, see Driver Writer's Guide and v4l2cap.c. Added new control
IDs: V4L2_CID_HFLIP, _VFLIP. Changed V4L2_PIX_FMT_YUV422P to _YUV422P,
and _YUV411P to _YUV411P.</p><p>1999-04-04: Added a few more control IDs.</p><p>1999-04-07: Added the button control type.</p><p>1999-05-02: Fixed a typo in videodev.h, and added the
V4L2_CTRL_FLAG_GRAYED (later V4L2_CTRL_FLAG_GRABBED) flag.</p><p>1999-05-20: Definition of VIDIOC_G_CTRL was wrong causing
a malfunction of this ioctl.</p><p>1999-06-05: Changed the value of
V4L2_CID_WHITENESS.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN15514">6.2.5. V4L2 Version 0.20 (1999-09-10)</a></h3><p>Version 0.20 introduced a number of changes which were
<span class="emphasis"><i class="EMPHASIS">not backward compatible</i></span> with 0.19 and earlier
versions. Purpose of these changes was to simplify the API, while
making it more extensible and following common Linux driver API
conventions.</p><p></p><ol type="1"><li><p>Some typos in <code class="CONSTANT">V4L2_FMT_FLAG</code>
symbols were fixed. struct&nbsp;<a href="#V4L2-CLIP">v4l2_clip</a> was changed for compatibility with
v4l. (1999-08-30)</p></li><li><p><code class="CONSTANT">V4L2_TUNER_SUB_LANG1</code> was added.
(1999-09-05)</p></li><li><p>All ioctl() commands that used an integer argument now
take a pointer to an integer. Where it makes sense, ioctls will return
the actual new value in the integer pointed to by the argument, a
common convention in the V4L2 API. The affected ioctls are:
VIDIOC_PREVIEW, VIDIOC_STREAMON, VIDIOC_STREAMOFF, VIDIOC_S_FREQ,
VIDIOC_S_INPUT, VIDIOC_S_OUTPUT, VIDIOC_S_EFFECT. For example
</p><pre class="PROGRAMLISTING">err = ioctl (fd, VIDIOC_XXX, V4L2_XXX);</pre> becomes <pre class="PROGRAMLISTING">int a = V4L2_XXX; err = ioctl(fd, VIDIOC_XXX, &amp;a);</pre>
          <p></p></li><li><p>All the different get- and set-format commands were
swept into one <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_G_FMT</code></a> and <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl taking a union
and a type field selecting the union member as parameter. Purpose is to
simplify the API by eliminating several ioctls and to allow new and
driver private data streams without adding new ioctls.</p><p>This change obsoletes the following ioctls:
<code class="CONSTANT">VIDIOC_S_INFMT</code>,
<code class="CONSTANT">VIDIOC_G_INFMT</code>,
<code class="CONSTANT">VIDIOC_S_OUTFMT</code>,
<code class="CONSTANT">VIDIOC_G_OUTFMT</code>,
<code class="CONSTANT">VIDIOC_S_VBIFMT</code> and
<code class="CONSTANT">VIDIOC_G_VBIFMT</code>. The image format structure
<code class="STRUCTNAME">v4l2_format</code> was renamed to struct&nbsp;<a href="#V4L2-PIX-FORMAT">v4l2_pix_format</a>,
while struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a> is now the envelopping structure for all format
negotiations.</p></li><li><p>Similar to the changes above, the
<code class="CONSTANT">VIDIOC_G_PARM</code> and
<code class="CONSTANT">VIDIOC_S_PARM</code> ioctls were merged with
<code class="CONSTANT">VIDIOC_G_OUTPARM</code> and
<code class="CONSTANT">VIDIOC_S_OUTPARM</code>. A
<code class="STRUCTFIELD">type</code> field in the new struct&nbsp;<a href="#V4L2-STREAMPARM">v4l2_streamparm</a>
selects the respective union member.</p><p>This change obsoletes the
<code class="CONSTANT">VIDIOC_G_OUTPARM</code> and
<code class="CONSTANT">VIDIOC_S_OUTPARM</code> ioctls.</p></li><li><p>Control enumeration was simplified, and two new
control flags were introduced and one dropped. The
<code class="STRUCTFIELD">catname</code> field was replaced by a
<code class="STRUCTFIELD">group</code> field.</p><p>Drivers can now flag unsupported and temporarily
unavailable controls with <code class="CONSTANT">V4L2_CTRL_FLAG_DISABLED</code>
and <code class="CONSTANT">V4L2_CTRL_FLAG_GRABBED</code> respectively. The
<code class="STRUCTFIELD">group</code> name indicates a possibly narrower
classification than the <code class="STRUCTFIELD">category</code>. In other
words, there may be multiple groups within a category. Controls within
a group would typically be drawn within a group box. Controls in
different categories might have a greater separation, or may even
appear in separate windows.</p></li><li><p>The struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a> <code class="STRUCTFIELD">timestamp</code>
was changed to a 64 bit integer, containing the sampling or output
time of the frame in nanoseconds. Additionally timestamps will be in
absolute system time, not starting from zero at the beginning of a
stream. The data type name for timestamps is stamp_t, defined as a
signed 64-bit integer. Output devices should not send a buffer out
until the time in the timestamp field has arrived. I would like to
follow SGI's lead, and adopt a multimedia timestamping system like
their UST (Unadjusted System Time). See
http://reality.sgi.com/cpirazzi_engr/lg/time/intro.html. [This link is
no longer valid.] UST uses timestamps that are 64-bit signed integers
(not struct timeval's) and given in nanosecond units. The UST clock
starts at zero when the system is booted and runs continuously and
uniformly. It takes a little over 292 years for UST to overflow. There
is no way to set the UST clock. The regular Linux time-of-day clock
can be changed periodically, which would cause errors if it were being
used for timestamping a multimedia stream. A real UST style clock will
require some support in the kernel that is not there yet. But in
anticipation, I will change the timestamp field to a 64-bit integer,
and I will change the v4l2_masterclock_gettime() function (used only
by drivers) to return a 64-bit integer.</p></li><li><p>A <code class="STRUCTFIELD">sequence</code> field was added
to struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a>. The <code class="STRUCTFIELD">sequence</code> field counts
captured frames, it is ignored by output devices. When a capture
driver drops a frame, the sequence number of that frame is
skipped.</p></li></ol></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN15575">6.2.6. V4L2 Version 0.20 incremental changes</a></h3><p>1999-12-23: In struct&nbsp;<a href="#V4L2-VBI-FORMAT">v4l2_vbi_format</a> the
<code class="STRUCTFIELD">reserved1</code> field became
<code class="STRUCTFIELD">offset</code>. Previously drivers were required to
clear the <code class="STRUCTFIELD">reserved1</code> field.</p><p>2000-01-13: The
      <code class="CONSTANT">V4L2_FMT_FLAG_NOT_INTERLACED</code> flag was added.</p><p>2000-07-31: The <tt class="FILENAME">linux/poll.h</tt> header
is now included by <tt class="FILENAME">videodev.h</tt> for compatibility
with the original <tt class="FILENAME">videodev.h</tt> file.</p><p>2000-11-20: <code class="CONSTANT">V4L2_TYPE_VBI_OUTPUT</code> and
<code class="CONSTANT">V4L2_PIX_FMT_Y41P</code> were added.</p><p>2000-11-25: <code class="CONSTANT">V4L2_TYPE_VBI_INPUT</code> was
added.</p><p>2000-12-04: A couple typos in symbol names were fixed.</p><p>2001-01-18: To avoid namespace conflicts the
<code class="CONSTANT">fourcc</code> macro defined in the
<tt class="FILENAME">videodev.h</tt> header file was renamed to
<code class="CONSTANT">v4l2_fourcc</code>.</p><p>2001-01-25: A possible driver-level compatibility problem
between the <tt class="FILENAME">videodev.h</tt> file in Linux 2.4.0 and
the <tt class="FILENAME">videodev.h</tt> file included in the
<tt class="FILENAME">videodevX</tt> patch was fixed. Users of an earlier
version of <tt class="FILENAME">videodevX</tt> on Linux 2.4.0 should
recompile their V4L and V4L2 drivers.</p><p>2001-01-26: A possible kernel-level incompatibility
between the <tt class="FILENAME">videodev.h</tt> file in the
<tt class="FILENAME">videodevX</tt> patch and the
<tt class="FILENAME">videodev.h</tt> file in Linux 2.2.x with devfs patches
applied was fixed.</p><p>2001-03-02: Certain V4L ioctls which pass data in both
direction although they are defined with read-only parameter, did not
work correctly through the backward compatibility layer.
[Solution?]</p><p>2001-04-13: Big endian 16-bit RGB formats were added.</p><p>2001-09-17: New YUV formats and the <a href="#VIDIOC-G-FREQUENCY"><code class="CONSTANT">VIDIOC_G_FREQUENCY</code></a> and
<a href="#VIDIOC-G-FREQUENCY"><code class="CONSTANT">VIDIOC_S_FREQUENCY</code></a> ioctls were added. (The old
<code class="CONSTANT">VIDIOC_G_FREQ</code> and
<code class="CONSTANT">VIDIOC_S_FREQ</code> ioctls did not take multiple tuners
into account.)</p><p>2000-09-18: <code class="CONSTANT">V4L2_BUF_TYPE_VBI</code> was
added. This may <span class="emphasis"><i class="EMPHASIS">break compatibility</i></span> as the
<a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_G_FMT</code></a> and <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctls may fail now if the struct
<code class="STRUCTNAME">v4l2_fmt</code> <code class="STRUCTFIELD">type</code>
field does not contain <code class="CONSTANT">V4L2_BUF_TYPE_VBI</code>. In the
documentation of the struct&nbsp;<a href="#V4L2-VBI-FORMAT">v4l2_vbi_format</a>
<code class="STRUCTFIELD">offset</code> field the ambiguous phrase "rising
edge" was changed to "leading edge".</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN15628">6.2.7. V4L2 Version 0.20 2000-11-23</a></h3><p>A number of changes were made to the raw VBI
interface.</p><p></p><ol type="1"><li><p>Figures clarifying the line numbering scheme were
added to the V4L2 API specification. The
<code class="STRUCTFIELD">start</code>[0] and
<code class="STRUCTFIELD">start</code>[1] fields no longer count line
numbers beginning at zero. Rationale: a) The previous definition was
unclear. b) The <code class="STRUCTFIELD">start</code>[] values are ordinal
numbers. c) There is no point in inventing a new line numbering
scheme. We now use line number as defined by ITU-R, period.
Compatibility: Add one to the start values. Applications depending on
the previous semantics may not function correctly.</p></li><li><p>The restriction "count[0] &gt; 0 and count[1] &gt; 0"
has been relaxed  to "(count[0] + count[1]) &gt; 0". Rationale:
Drivers may allocate resources at scan line granularity and some data
services are transmitted only on the first field. The comment that
both <code class="STRUCTFIELD">count</code> values will usually be equal is
misleading and pointless and has been removed. This change
<span class="emphasis"><i class="EMPHASIS">breaks compatibility</i></span> with earlier versions:
Drivers may return EINVAL, applications may not function
correctly.</p></li><li><p>Drivers are again permitted to return negative
(unknown) start values as proposed earlier. Why this feature was
dropped is unclear. This change may <span class="emphasis"><i class="EMPHASIS">break
compatibility</i></span> with applications depending on the start
values being positive. The use of <code class="CONSTANT">EBUSY</code> and
<code class="CONSTANT">EINVAL</code> error codes with the <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a> ioctl
was clarified. The <span class="ERRORCODE">EBUSY</span> error code was finally documented, and the
<code class="STRUCTFIELD">reserved2</code> field which was previously
mentioned only in the <tt class="FILENAME">videodev.h</tt> header
file.</p></li><li><p>New buffer types
<code class="CONSTANT">V4L2_TYPE_VBI_INPUT</code> and
<code class="CONSTANT">V4L2_TYPE_VBI_OUTPUT</code> were added. The former is an
alias for the old <code class="CONSTANT">V4L2_TYPE_VBI</code>, the latter was
missing in the <tt class="FILENAME">videodev.h</tt> file.</p></li></ol></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN15657">6.2.8. V4L2 Version 0.20 2002-07-25</a></h3><p>Added sliced VBI interface proposal.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN15660">6.2.9. V4L2 in Linux 2.5.46, 2002-10</a></h3><p>Around October-November 2002, prior to an announced
feature freeze of Linux 2.5, the API was revised, drawing from
experience with V4L2 0.20. This unnamed version was finally merged
into Linux 2.5.46.</p><p></p><ol type="1"><li><p>As specified in <a href="#RELATED">Section 1.1.2</a>, drivers
must make related device functions available under all minor device
numbers.</p></li><li><p>The <a href="#FUNC-OPEN"><code class="FUNCTION">open()</code></a> function requires access mode
<code class="CONSTANT">O_RDWR</code> regardless of the device type. All V4L2
drivers exchanging data with applications must support the
<code class="CONSTANT">O_NONBLOCK</code> flag. The <code class="CONSTANT">O_NOIO</code>
flag, a V4L2 symbol which aliased the meaningless
<code class="CONSTANT">O_TRUNC</code> to indicate accesses without data
exchange (panel applications) was dropped. Drivers must stay in "panel
mode" until the application attempts to initiate a data exchange, see
<a href="#OPEN">Section 1.1</a>.</p></li><li><p>The struct&nbsp;<a href="#V4L2-CAPABILITY">v4l2_capability</a> changed dramatically. Note that
also the size of the structure changed, which is encoded in the ioctl
request code, thus older V4L2 devices will respond with an <span class="ERRORCODE">EINVAL</span> error code to
the new <a href="#VIDIOC-QUERYCAP"><code class="CONSTANT">VIDIOC_QUERYCAP</code></a> ioctl.</p><p>There are new fields to identify the driver, a new (as
of yet unspecified) device function
<code class="CONSTANT">V4L2_CAP_RDS_CAPTURE</code>, the
<code class="CONSTANT">V4L2_CAP_AUDIO</code> flag indicates if the device has
any audio connectors, another I/O capability
<code class="CONSTANT">V4L2_CAP_ASYNCIO</code> can be flagged. In response to
these changes the <code class="STRUCTFIELD">type</code> field became a bit
set and was merged into the <code class="STRUCTFIELD">flags</code> field.
<code class="CONSTANT">V4L2_FLAG_TUNER</code> was renamed to
<code class="CONSTANT">V4L2_CAP_TUNER</code>,
<code class="CONSTANT">V4L2_CAP_VIDEO_OVERLAY</code> replaced
<code class="CONSTANT">V4L2_FLAG_PREVIEW</code> and
<code class="CONSTANT">V4L2_CAP_VBI_CAPTURE</code> and
<code class="CONSTANT">V4L2_CAP_VBI_OUTPUT</code> replaced
<code class="CONSTANT">V4L2_FLAG_DATA_SERVICE</code>.
<code class="CONSTANT">V4L2_FLAG_READ</code> and
<code class="CONSTANT">V4L2_FLAG_WRITE</code> were merged into
<code class="CONSTANT">V4L2_CAP_READWRITE</code>.</p><p>The redundant fields
<code class="STRUCTFIELD">inputs</code>, <code class="STRUCTFIELD">outputs</code>
and <code class="STRUCTFIELD">audios</code> were removed. These properties
can be determined as described in <a href="#VIDEO">Section 1.4</a> and <a href="#AUDIO">Section 1.5</a>.</p><p>The somewhat volatile and therefore barely useful
fields <code class="STRUCTFIELD">maxwidth</code>,
<code class="STRUCTFIELD">maxheight</code>,
<code class="STRUCTFIELD">minwidth</code>,
<code class="STRUCTFIELD">minheight</code>,
<code class="STRUCTFIELD">maxframerate</code> were removed. This information
is available as described in <a href="#FORMAT">Section 1.10</a> and
<a href="#STANDARD">Section 1.7</a>.</p><p><code class="CONSTANT">V4L2_FLAG_SELECT</code> was removed. We
believe the select() function is important enough to require support
of it in all V4L2 drivers exchanging data with applications. The
redundant <code class="CONSTANT">V4L2_FLAG_MONOCHROME</code> flag was removed,
this information is available as described in <a href="#FORMAT">Section 1.10</a>.</p></li><li><p>In struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a> the
<code class="STRUCTFIELD">assoc_audio</code> field and the
<code class="STRUCTFIELD">capability</code> field and its only flag
<code class="CONSTANT">V4L2_INPUT_CAP_AUDIO</code> was replaced by the new
<code class="STRUCTFIELD">audioset</code> field. Instead of linking one
video input to one audio input this field reports all audio inputs
this video input combines with.</p><p>New fields are <code class="STRUCTFIELD">tuner</code>
(reversing the former link from tuners to video inputs),
<code class="STRUCTFIELD">std</code> and
<code class="STRUCTFIELD">status</code>.</p><p>Accordingly struct&nbsp;<a href="#V4L2-OUTPUT">v4l2_output</a> lost its
<code class="STRUCTFIELD">capability</code> and
<code class="STRUCTFIELD">assoc_audio</code> fields.
<code class="STRUCTFIELD">audioset</code>,
<code class="STRUCTFIELD">modulator</code> and
<code class="STRUCTFIELD">std</code> where added instead.</p></li><li><p>The struct&nbsp;<a href="#V4L2-AUDIO">v4l2_audio</a> field
<code class="STRUCTFIELD">audio</code> was renamed to
<code class="STRUCTFIELD">index</code>, for consistency with other
structures. A new capability flag
<code class="CONSTANT">V4L2_AUDCAP_STEREO</code> was added to indicated if the
audio input in question supports stereo sound.
<code class="CONSTANT">V4L2_AUDCAP_EFFECTS</code> and the corresponding
<code class="CONSTANT">V4L2_AUDMODE</code> flags where removed. This can be
easily implemented using controls. (However the same applies to AVL
which is still there.)</p><p>Again for consistency the struct&nbsp;<a href="#V4L2-AUDIOOUT">v4l2_audioout</a> field
<code class="STRUCTFIELD">audio</code> was renamed to
<code class="STRUCTFIELD">index</code>.</p></li><li><p>The struct&nbsp;<a href="#V4L2-TUNER">v4l2_tuner</a>
<code class="STRUCTFIELD">input</code> field was replaced by an
<code class="STRUCTFIELD">index</code> field, permitting devices with
multiple tuners. The link between video inputs and tuners is now
reversed, inputs point to their tuner. The
<code class="STRUCTFIELD">std</code> substructure became a
simple set (more about this below) and moved into struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a>. A
<code class="STRUCTFIELD">type</code> field was added.</p><p>Accordingly in struct&nbsp;<a href="#V4L2-MODULATOR">v4l2_modulator</a> the
<code class="STRUCTFIELD">output</code> was replaced by an
<code class="STRUCTFIELD">index</code> field.</p><p>In struct&nbsp;<a href="#V4L2-FREQUENCY">v4l2_frequency</a> the
<code class="STRUCTFIELD">port</code> field was replaced by a
<code class="STRUCTFIELD">tuner</code> field containing the respective tuner
or modulator index number. A tuner <code class="STRUCTFIELD">type</code>
field was added and the <code class="STRUCTFIELD">reserved</code> field
became larger for future extensions (satellite tuners in
particular).</p></li><li><p>The idea of completely transparent video standards was
dropped. Experience showed that applications must be able to work with
video standards beyond presenting the user a menu. Instead of
enumerating supported standards with an ioctl applications can now
refer to standards by <a href="#V4L2-STD-ID">v4l2_std_id</a> and symbols defined in the
<tt class="FILENAME">videodev2.h</tt> header file. For details see <a href="#STANDARD">Section 1.7</a>. The <a href="#VIDIOC-G-STD"><code class="CONSTANT">VIDIOC_G_STD</code></a> and
<a href="#VIDIOC-G-STD"><code class="CONSTANT">VIDIOC_S_STD</code></a> now take a pointer to this type as argument.
<a href="#VIDIOC-QUERYSTD"><code class="CONSTANT">VIDIOC_QUERYSTD</code></a> was added to autodetect the received standard, if
the hardware has this capability. In struct&nbsp;<a href="#V4L2-STANDARD">v4l2_standard</a> an
<code class="STRUCTFIELD">index</code> field was added for <a href="#VIDIOC-ENUMSTD"><code class="CONSTANT">VIDIOC_ENUMSTD</code></a>.
A <a href="#V4L2-STD-ID">v4l2_std_id</a> field named <code class="STRUCTFIELD">id</code> was added as
machine readable identifier, also replacing the
<code class="STRUCTFIELD">transmission</code> field. The misleading
<code class="STRUCTFIELD">framerate</code> field was renamed
to <code class="STRUCTFIELD">frameperiod</code>. The now obsolete
<code class="STRUCTFIELD">colorstandard</code> information, originally
needed to distguish between variations of standards, were
removed.</p><p>Struct <code class="STRUCTNAME">v4l2_enumstd</code> ceased to
be. <a href="#VIDIOC-ENUMSTD"><code class="CONSTANT">VIDIOC_ENUMSTD</code></a> now takes a pointer to a struct&nbsp;<a href="#V4L2-STANDARD">v4l2_standard</a>
directly. The information which standards are supported by a
particular video input or output moved into struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a> and
struct&nbsp;<a href="#V4L2-OUTPUT">v4l2_output</a> fields named <code class="STRUCTFIELD">std</code>,
respectively.</p></li><li><p>The struct&nbsp;<a href="#V4L2-QUERYCTRL">v4l2_queryctrl</a> fields
<code class="STRUCTFIELD">category</code> and
<code class="STRUCTFIELD">group</code> did not catch on and/or were not
implemented as expected and therefore removed.</p></li><li><p>The <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_TRY_FMT</code></a> ioctl was added to negotiate data
formats as with <a href="#VIDIOC-G-FMT"><code class="CONSTANT">VIDIOC_S_FMT</code></a>, but without the overhead of
programming the hardware and regardless of I/O in progress.</p><p>In struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a> the <code class="STRUCTFIELD">fmt</code>
union was extended to contain struct&nbsp;<a href="#V4L2-WINDOW">v4l2_window</a>. All image format
negotiations are now possible with <code class="CONSTANT">VIDIOC_G_FMT</code>,
<code class="CONSTANT">VIDIOC_S_FMT</code> and
<code class="CONSTANT">VIDIOC_TRY_FMT</code>; ioctl. The
<code class="CONSTANT">VIDIOC_G_WIN</code> and
<code class="CONSTANT">VIDIOC_S_WIN</code> ioctls to prepare for a video
overlay were removed. The <code class="STRUCTFIELD">type</code> field
changed to type enum&nbsp;<a href="#V4L2-BUF-TYPE">v4l2_buf_type</a> and the buffer type names changed as
follows.</p><div class="INFORMALTABLE"><p></p><a name="AEN15815"></a><table class="CALSTABLE" border="1"><colgroup><col><col></colgroup><thead><tr><th>Old defines</th><th>enum&nbsp;<a href="#V4L2-BUF-TYPE">v4l2_buf_type</a></th></tr></thead><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_BUF_TYPE_CAPTURE</code></td><td><code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_CAPTURE</code></td></tr><tr><td><code class="CONSTANT">V4L2_BUF_TYPE_CODECIN</code></td><td>Omitted for now</td></tr><tr><td><code class="CONSTANT">V4L2_BUF_TYPE_CODECOUT</code></td><td>Omitted for now</td></tr><tr><td><code class="CONSTANT">V4L2_BUF_TYPE_EFFECTSIN</code></td><td>Omitted for now</td></tr><tr><td><code class="CONSTANT">V4L2_BUF_TYPE_EFFECTSIN2</code></td><td>Omitted for now</td></tr><tr><td><code class="CONSTANT">V4L2_BUF_TYPE_EFFECTSOUT</code></td><td>Omitted for now</td></tr><tr><td><code class="CONSTANT">V4L2_BUF_TYPE_VIDEOOUT</code></td><td><code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_OUTPUT</code></td></tr><tr><td><code class="CONSTANT">-</code></td><td><code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_OVERLAY</code></td></tr><tr><td><code class="CONSTANT">-</code></td><td><code class="CONSTANT">V4L2_BUF_TYPE_VBI_CAPTURE</code></td></tr><tr><td><code class="CONSTANT">-</code></td><td><code class="CONSTANT">V4L2_BUF_TYPE_VBI_OUTPUT</code></td></tr><tr><td><code class="CONSTANT">-</code></td><td><code class="CONSTANT">V4L2_BUF_TYPE_SLICED_VBI_CAPTURE</code></td></tr><tr><td><code class="CONSTANT">-</code></td><td><code class="CONSTANT">V4L2_BUF_TYPE_SLICED_VBI_OUTPUT</code></td></tr><tr><td><code class="CONSTANT">V4L2_BUF_TYPE_PRIVATE_BASE</code></td><td><code class="CONSTANT">V4L2_BUF_TYPE_PRIVATE</code></td></tr></tbody></table><p></p></div><p></p></li><li><p>In struct&nbsp;<a href="#V4L2-FMTDESC">v4l2_fmtdesc</a> a enum&nbsp;<a href="#V4L2-BUF-TYPE">v4l2_buf_type</a> field named
<code class="STRUCTFIELD">type</code> was added as in struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a>. The
<code class="CONSTANT">VIDIOC_ENUM_FBUFFMT</code> ioctl is no longer needed and
was removed. These calls can be replaced by <a href="#VIDIOC-ENUM-FMT"><code class="CONSTANT">VIDIOC_ENUM_FMT</code></a> with
type <code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_OVERLAY</code>.</p></li><li><p>In struct&nbsp;<a href="#V4L2-PIX-FORMAT">v4l2_pix_format</a> the
<code class="STRUCTFIELD">depth</code> field was removed, assuming
applications which recognize the format by its four-character-code
already know the color depth, and others do not care about it. The
same rationale lead to the removal of the
<code class="CONSTANT">V4L2_FMT_FLAG_COMPRESSED</code> flag. The
<code class="CONSTANT">V4L2_FMT_FLAG_SWCONVECOMPRESSED</code> flag was removed
because drivers are not supposed to convert images in kernel space. A
user library of conversion functions should be provided instead. The
<code class="CONSTANT">V4L2_FMT_FLAG_BYTESPERLINE</code> flag was redundant.
Applications can set the <code class="STRUCTFIELD">bytesperline</code> field
to zero to get a reasonable default. Since the remaining flags were
replaced as well, the <code class="STRUCTFIELD">flags</code> field itself
was removed.</p><p>The interlace flags were replaced by a enum&nbsp;<a href="#V4L2-FIELD">v4l2_field</a>
value in a newly added <code class="STRUCTFIELD">field</code>
field.</p><div class="INFORMALTABLE"><p></p><a name="AEN15905"></a><table class="CALSTABLE" border="1"><colgroup><col><col></colgroup><thead><tr><th>Old flag</th><th>enum&nbsp;<a href="#V4L2-FIELD">v4l2_field</a></th></tr></thead><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_FMT_FLAG_NOT_INTERLACED</code></td><td>?</td></tr><tr><td><code class="CONSTANT">V4L2_FMT_FLAG_INTERLACED</code> 
= <code class="CONSTANT">V4L2_FMT_FLAG_COMBINED</code></td><td><code class="CONSTANT">V4L2_FIELD_INTERLACED</code></td></tr><tr><td><code class="CONSTANT">V4L2_FMT_FLAG_TOPFIELD</code>
= <code class="CONSTANT">V4L2_FMT_FLAG_ODDFIELD</code></td><td><code class="CONSTANT">V4L2_FIELD_TOP</code></td></tr><tr><td><code class="CONSTANT">V4L2_FMT_FLAG_BOTFIELD</code>
= <code class="CONSTANT">V4L2_FMT_FLAG_EVENFIELD</code></td><td><code class="CONSTANT">V4L2_FIELD_BOTTOM</code></td></tr><tr><td><code class="CONSTANT">-</code></td><td><code class="CONSTANT">V4L2_FIELD_SEQ_TB</code></td></tr><tr><td><code class="CONSTANT">-</code></td><td><code class="CONSTANT">V4L2_FIELD_SEQ_BT</code></td></tr><tr><td><code class="CONSTANT">-</code></td><td><code class="CONSTANT">V4L2_FIELD_ALTERNATE</code></td></tr></tbody></table><p></p></div><p></p><p>The color space flags were replaced by a
enum&nbsp;<a href="#V4L2-COLORSPACE">v4l2_colorspace</a> value in a newly added
<code class="STRUCTFIELD">colorspace</code> field, where one of
<code class="CONSTANT">V4L2_COLORSPACE_SMPTE170M</code>,
<code class="CONSTANT">V4L2_COLORSPACE_BT878</code>,
<code class="CONSTANT">V4L2_COLORSPACE_470_SYSTEM_M</code> or
<code class="CONSTANT">V4L2_COLORSPACE_470_SYSTEM_BG</code> replaces
<code class="CONSTANT">V4L2_FMT_CS_601YUV</code>.</p></li><li><p>In struct&nbsp;<a href="#V4L2-REQUESTBUFFERS">v4l2_requestbuffers</a> the
<code class="STRUCTFIELD">type</code> field was properly defined as
enum&nbsp;<a href="#V4L2-BUF-TYPE">v4l2_buf_type</a>. Buffer types changed as mentioned above. A new
<code class="STRUCTFIELD">memory</code> field of type enum&nbsp;<a href="#V4L2-MEMORY">v4l2_memory</a> was
added to distinguish between I/O methods using buffers allocated
by the driver or the application. See <a href="#IO">Chapter 3</a> for
details.</p></li><li><p>In struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a> the <code class="STRUCTFIELD">type</code>
field was properly defined as enum&nbsp;<a href="#V4L2-BUF-TYPE">v4l2_buf_type</a>. Buffer types changed as
mentioned above. A <code class="STRUCTFIELD">field</code> field of type
enum&nbsp;<a href="#V4L2-FIELD">v4l2_field</a> was added to indicate if a buffer contains a top or
bottom field. The old field flags were removed. Since no unadjusted
system time clock was added to the kernel as planned, the
<code class="STRUCTFIELD">timestamp</code> field changed back from type
stamp_t, an unsigned 64 bit integer expressing the sample time in
nanoseconds, to struct <code class="STRUCTNAME">timeval</code>. With the
addition of a second memory mapping method the
<code class="STRUCTFIELD">offset</code> field moved into union
<code class="STRUCTFIELD">m</code>, and a new
<code class="STRUCTFIELD">memory</code> field of type enum&nbsp;<a href="#V4L2-MEMORY">v4l2_memory</a> was
added to distinguish between I/O methods. See <a href="#IO">Chapter 3</a>
for details.</p><p>The <code class="CONSTANT">V4L2_BUF_REQ_CONTIG</code>
flag was used by the V4L compatibility layer, after changes to this
code it was no longer needed. The
<code class="CONSTANT">V4L2_BUF_ATTR_DEVICEMEM</code> flag would indicate if
the buffer was indeed allocated in device memory rather than DMA-able
system memory. It was barely useful and so was removed.</p></li><li><p>In struct&nbsp;<a href="#V4L2-FRAMEBUFFER">v4l2_framebuffer</a> the
<code class="STRUCTFIELD">base[3]</code> array anticipating double- and
triple-buffering in off-screen video memory, however without defining
a synchronization mechanism, was replaced by a single pointer. The
<code class="CONSTANT">V4L2_FBUF_CAP_SCALEUP</code> and
<code class="CONSTANT">V4L2_FBUF_CAP_SCALEDOWN</code> flags were removed.
Applications can determine this capability more accurately using the
new cropping and scaling interface. The
<code class="CONSTANT">V4L2_FBUF_CAP_CLIPPING</code> flag was replaced by
<code class="CONSTANT">V4L2_FBUF_CAP_LIST_CLIPPING</code> and
<code class="CONSTANT">V4L2_FBUF_CAP_BITMAP_CLIPPING</code>.</p></li><li><p>In struct&nbsp;<a href="#V4L2-CLIP">v4l2_clip</a> the <code class="STRUCTFIELD">x</code>,
<code class="STRUCTFIELD">y</code>, <code class="STRUCTFIELD">width</code> and
<code class="STRUCTFIELD">height</code> field moved into a
<code class="STRUCTFIELD">c</code> substructure of type struct&nbsp;<a href="#V4L2-RECT">v4l2_rect</a>. The
<code class="STRUCTFIELD">x</code> and <code class="STRUCTFIELD">y</code> fields
were renamed to <code class="STRUCTFIELD">left</code> and
<code class="STRUCTFIELD">top</code>, i.&nbsp;e. offsets to a context dependent
origin.</p></li><li><p>In struct&nbsp;<a href="#V4L2-WINDOW">v4l2_window</a> the <code class="STRUCTFIELD">x</code>,
<code class="STRUCTFIELD">y</code>, <code class="STRUCTFIELD">width</code> and
<code class="STRUCTFIELD">height</code> field moved into a
<code class="STRUCTFIELD">w</code> substructure as above. A
<code class="STRUCTFIELD">field</code> field of type %v4l2-field; was added
to distinguish between field and frame (interlaced) overlay.</p></li><li><p>The digital zoom interface, including struct
<code class="STRUCTNAME">v4l2_zoomcap</code>, struct
<code class="STRUCTNAME">v4l2_zoom</code>,
<code class="CONSTANT">V4L2_ZOOM_NONCAP</code> and
<code class="CONSTANT">V4L2_ZOOM_WHILESTREAMING</code> was replaced by a new
cropping and scaling interface. The previously unused struct
<code class="STRUCTNAME">v4l2_cropcap</code> and
<code class="STRUCTNAME">v4l2_crop</code> where redefined for this purpose.
See <a href="#CROP">Section 1.11</a> for details.</p></li><li><p>In struct&nbsp;<a href="#V4L2-VBI-FORMAT">v4l2_vbi_format</a> the
<code class="STRUCTFIELD">SAMPLE_FORMAT</code> field now contains a
four-character-code as used to identify video image formats and
<code class="CONSTANT">V4L2_PIX_FMT_GREY</code> replaces the
<code class="CONSTANT">V4L2_VBI_SF_UBYTE</code> define. The
<code class="STRUCTFIELD">reserved</code> field was extended.</p></li><li><p>In struct&nbsp;<a href="#V4L2-CAPTUREPARM">v4l2_captureparm</a> the type of the
<code class="STRUCTFIELD">timeperframe</code> field changed from unsigned
long to struct&nbsp;<a href="#V4L2-FRACT">v4l2_fract</a>. This allows the accurate expression of multiples
of the NTSC-M frame rate 30000 / 1001. A new field
<code class="STRUCTFIELD">readbuffers</code> was added to control the driver
behaviour in read I/O mode.</p><p>Similar changes were made to struct&nbsp;<a href="#V4L2-OUTPUTPARM">v4l2_outputparm</a>.</p></li><li><p>The struct <code class="STRUCTNAME">v4l2_performance</code>
and <code class="CONSTANT">VIDIOC_G_PERF</code> ioctl were dropped. Except when
using the <a href="#RW">read/write I/O method</a>, which is
limited anyway, this information is already available to
applications.</p></li><li><p>The example transformation from RGB to YCbCr color
space in the old V4L2 documentation was inaccurate, this has been
corrected in <a href="#PIXFMT">Chapter 2</a>.</p></li></ol></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16046">6.2.10. V4L2 2003-06-19</a></h3><p></p><ol type="1"><li><p>A new capability flag
<code class="CONSTANT">V4L2_CAP_RADIO</code> was added for radio devices. Prior
to this change radio devices would identify solely by having exactly one
tuner whose type field reads <code class="CONSTANT">V4L2_TUNER_RADIO</code>.</p></li><li><p>An optional driver access priority mechanism was
added, see <a href="#APP-PRI">Section 1.3</a> for details.</p></li><li><p>The audio input and output interface was found to be
incomplete.</p><p>Previously the <a href="#VIDIOC-G-AUDIO"><code class="CONSTANT">VIDIOC_G_AUDIO</code></a>
ioctl would enumerate the available audio inputs. An ioctl to
determine the current audio input, if more than one combines with the
current video input, did not exist. So
<code class="CONSTANT">VIDIOC_G_AUDIO</code> was renamed to
<code class="CONSTANT">VIDIOC_G_AUDIO_OLD</code>, this ioctl will be removed in
the future. The <a href="#VIDIOC-ENUMAUDIO"><code class="CONSTANT">VIDIOC_ENUMAUDIO</code></a> ioctl was added to enumerate
audio inputs, while <a href="#VIDIOC-G-AUDIO"><code class="CONSTANT">VIDIOC_G_AUDIO</code></a> now reports the current audio
input.</p><p>The same changes were made to <a href="#VIDIOC-G-AUDIOOUT"><code class="CONSTANT">VIDIOC_G_AUDOUT</code></a> and
<a href="#VIDIOC-ENUMAUDIOOUT"><code class="CONSTANT">VIDIOC_ENUMAUDOUT</code></a>.</p><p>Until further the "videodev" module will automatically
translate between the old and new ioctls, but drivers and applications
must be updated to successfully compile again.</p></li><li><p>The <a href="#VIDIOC-OVERLAY"><code class="CONSTANT">VIDIOC_OVERLAY</code></a> ioctl was incorrectly defined with
write-read parameter. It was changed to write-only, while the write-read
version was renamed to <code class="CONSTANT">VIDIOC_OVERLAY_OLD</code>. The old
ioctl will be removed in the future. Until further the "videodev"
kernel module will automatically translate to the new version, so drivers
must be recompiled, but not applications.</p></li><li><p><a href="#OVERLAY">Section 4.2</a> incorrectly stated that
clipping rectangles define regions where the video can be seen.
Correct is that clipping rectangles define regions where
<span class="emphasis"><i class="EMPHASIS">no</i></span> video shall be displayed and so the graphics
surface can be seen.</p></li><li><p>The <a href="#VIDIOC-G-PARM"><code class="CONSTANT">VIDIOC_S_PARM</code></a> and <a href="#VIDIOC-G-CTRL"><code class="CONSTANT">VIDIOC_S_CTRL</code></a> ioctls were
defined with write-only parameter, inconsistent with other ioctls
modifying their argument. They were changed to write-read, while a
<code class="CONSTANT">_OLD</code> suffix was added to the write-only versions.
The old ioctls will be removed in the future. Drivers and
applications assuming a constant parameter need an update.</p></li></ol></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16089">6.2.11. V4L2 2003-11-05</a></h3><p></p><ol type="1"><li><p>In <a href="#PIXFMT-RGB">Section 2.4</a> the following pixel
formats were incorrectly transferred from Bill Dirks' V4L2
specification. Descriptions below refer to bytes in memory, in
ascending address order.</p><div class="INFORMALTABLE"><p></p><a name="AEN16095"></a><table class="CALSTABLE" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Symbol</th><th>In this document prior to revision
0.5</th><th>Corrected</th></tr></thead><tbody valign="TOP"><tr><td><code class="CONSTANT">V4L2_PIX_FMT_RGB24</code></td><td>B, G, R</td><td>R, G, B</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_BGR24</code></td><td>R, G, B</td><td>B, G, R</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_RGB32</code></td><td>B, G, R, X</td><td>R, G, B, X</td></tr><tr><td><code class="CONSTANT">V4L2_PIX_FMT_BGR32</code></td><td>R, G, B, X</td><td>B, G, R, X</td></tr></tbody></table><p></p></div> The
<code class="CONSTANT">V4L2_PIX_FMT_BGR24</code> example was always
correct.<p></p><p>In <a href="#V4L-IMAGE-PROPERTIES">Section 6.1.5</a> the mapping
of the V4L <code class="CONSTANT">VIDEO_PALETTE_RGB24</code> and
<code class="CONSTANT">VIDEO_PALETTE_RGB32</code> formats to V4L2 pixel formats
was accordingly corrected.</p></li><li><p>Unrelated to the fixes above, drivers may still
interpret some V4L2 RGB pixel formats differently. These issues have
yet to be addressed, for details see <a href="#PIXFMT-RGB">Section 2.4</a>.</p></li></ol></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16131">6.2.12. V4L2 in Linux 2.6.6, 2004-05-09</a></h3><p></p><ol type="1"><li><p>The <a href="#VIDIOC-CROPCAP"><code class="CONSTANT">VIDIOC_CROPCAP</code></a> ioctl was incorrectly defined
with read-only parameter. It is now defined as write-read ioctl, while
the read-only version was renamed to
<code class="CONSTANT">VIDIOC_CROPCAP_OLD</code>. The old ioctl will be removed
in the future.</p></li></ol></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16139">6.2.13. V4L2 in Linux 2.6.8</a></h3><p></p><ol type="1"><li><p>A new field <code class="STRUCTFIELD">input</code> (former
<code class="STRUCTFIELD">reserved[0]</code>) was added to the struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a>
structure. Purpose of this field is to alternate between video inputs
(e.&nbsp;g. cameras) in step with the video capturing process. This function
must be enabled with the new <code class="CONSTANT">V4L2_BUF_FLAG_INPUT</code>
flag. The <code class="STRUCTFIELD">flags</code> field is no longer
read-only.</p></li></ol></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16149">6.2.14. V4L2 spec erratum 2004-08-01</a></h3><p></p><ol type="1"><li><p>The return value of the
<a href="#FUNC-OPEN">V4L2 open()(2)</a> function was incorrectly documented.</p></li><li><p>Audio output ioctls end in -AUDOUT, not -AUDIOOUT.</p></li><li><p>In the Current Audio Input example the
<code class="CONSTANT">VIDIOC_G_AUDIO</code> ioctl took the wrong
argument.</p></li><li><p>The documentation of the <a href="#VIDIOC-QBUF"><code class="CONSTANT">VIDIOC_QBUF</code></a> and
<a href="#VIDIOC-QBUF"><code class="CONSTANT">VIDIOC_DQBUF</code></a> ioctls did not mention the struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a>
<code class="STRUCTFIELD">memory</code> field. It was also missing from
examples. Also on the <code class="CONSTANT">VIDIOC_DQBUF</code> page the <span class="ERRORCODE">EIO</span> error code
was not documented.</p></li></ol></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16170">6.2.15. V4L2 in Linux 2.6.14</a></h3><p></p><ol type="1"><li><p>A new sliced VBI interface was added. It is documented
in <a href="#SLICED">Section 4.8</a> and replaces the interface first
proposed in V4L2 specification 0.8.</p></li></ol></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16176">6.2.16. V4L2 in Linux 2.6.15</a></h3><p></p><ol type="1"><li><p>The <a href="#VIDIOC-LOG-STATUS"><code class="CONSTANT">VIDIOC_LOG_STATUS</code></a> ioctl was added.</p></li><li><p>New video standards
<code class="CONSTANT">V4L2_STD_NTSC_443</code>,
<code class="CONSTANT">V4L2_STD_SECAM_LC</code>,
<code class="CONSTANT">V4L2_STD_SECAM_DK</code> (a set of SECAM D, K and K1),
and <code class="CONSTANT">V4L2_STD_ATSC</code> (a set of
<code class="CONSTANT">V4L2_STD_ATSC_8_VSB</code> and
<code class="CONSTANT">V4L2_STD_ATSC_16_VSB</code>) were defined. Note the
<code class="CONSTANT">V4L2_STD_525_60</code> set now includes
<code class="CONSTANT">V4L2_STD_NTSC_443</code>. See also <a href="#V4L2-STD-ID">Table 3</a>.</p></li><li><p>The <code class="CONSTANT">VIDIOC_G_COMP</code> and
<code class="CONSTANT">VIDIOC_S_COMP</code> ioctl were renamed to
<code class="CONSTANT">VIDIOC_G_MPEGCOMP</code> and
<code class="CONSTANT">VIDIOC_S_MPEGCOMP</code> respectively. Their argument
was replaced by a struct
<code class="STRUCTNAME">v4l2_mpeg_compression</code> pointer. (The
<code class="CONSTANT">VIDIOC_G_MPEGCOMP</code> and
<code class="CONSTANT">VIDIOC_S_MPEGCOMP</code> ioctls where removed in Linux
2.6.25.)</p></li></ol></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16203">6.2.17. V4L2 spec erratum 2005-11-27</a></h3><p>The capture example in <a href="#CAPTURE-EXAMPLE">Appendix B</a>
called the <a href="#VIDIOC-G-CROP"><code class="CONSTANT">VIDIOC_S_CROP</code></a> ioctl without checking if cropping is
supported. In the video standard selection example in
<a href="#STANDARD">Section 1.7</a> the <a href="#VIDIOC-G-STD"><code class="CONSTANT">VIDIOC_S_STD</code></a> call used the wrong
argument type.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16212">6.2.18. V4L2 spec erratum 2006-01-10</a></h3><p></p><ol type="1"><li><p>The <code class="CONSTANT">V4L2_IN_ST_COLOR_KILL</code> flag in
struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a> not only indicates if the color killer is enabled, but
also if it is active. (The color killer disables color decoding when
it detects no color in the video signal to improve the image
quality.)</p></li><li><p><a href="#VIDIOC-G-PARM"><code class="CONSTANT">VIDIOC_S_PARM</code></a> is a write-read ioctl, not write-only as
stated on its reference page. The ioctl changed in 2003 as noted above.</p></li></ol></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16223">6.2.19. V4L2 spec erratum 2006-02-03</a></h3><p></p><ol type="1"><li><p>In struct&nbsp;<a href="#V4L2-CAPTUREPARM">v4l2_captureparm</a> and struct&nbsp;<a href="#V4L2-OUTPUTPARM">v4l2_outputparm</a> the
<code class="STRUCTFIELD">timeperframe</code> field gives the time in
seconds, not microseconds.</p></li></ol></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16231">6.2.20. V4L2 spec erratum 2006-02-04</a></h3><p></p><ol type="1"><li><p>The <code class="STRUCTFIELD">clips</code> field in
struct&nbsp;<a href="#V4L2-WINDOW">v4l2_window</a> must point to an array of struct&nbsp;<a href="#V4L2-CLIP">v4l2_clip</a>, not a linked
list, because drivers ignore the struct
<code class="STRUCTNAME">v4l2_clip</code>.<code class="STRUCTFIELD">next</code>
pointer.</p></li></ol></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16241">6.2.21. V4L2 in Linux 2.6.17</a></h3><p></p><ol type="1"><li><p>New video standard macros were added:
<code class="CONSTANT">V4L2_STD_NTSC_M_KR</code> (NTSC M South Korea), and the
sets <code class="CONSTANT">V4L2_STD_MN</code>,
<code class="CONSTANT">V4L2_STD_B</code>, <code class="CONSTANT">V4L2_STD_GH</code> and
<code class="CONSTANT">V4L2_STD_DK</code>. The
<code class="CONSTANT">V4L2_STD_NTSC</code> and
<code class="CONSTANT">V4L2_STD_SECAM</code> sets now include
<code class="CONSTANT">V4L2_STD_NTSC_M_KR</code> and
<code class="CONSTANT">V4L2_STD_SECAM_LC</code> respectively.</p></li><li><p>A new <code class="CONSTANT">V4L2_TUNER_MODE_LANG1_LANG2</code>
was defined to record both languages of a bilingual program. The
use of <code class="CONSTANT">V4L2_TUNER_MODE_STEREO</code> for this purpose
is deprecated now. See the <a href="#VIDIOC-G-TUNER"><code class="CONSTANT">VIDIOC_G_TUNER</code></a> section for
details.</p></li></ol></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16261">6.2.22. V4L2 spec erratum 2006-09-23 (Draft 0.15)</a></h3><p></p><ol type="1"><li><p>In various places
<code class="CONSTANT">V4L2_BUF_TYPE_SLICED_VBI_CAPTURE</code> and
<code class="CONSTANT">V4L2_BUF_TYPE_SLICED_VBI_OUTPUT</code> of the sliced VBI
interface were not mentioned along with other buffer types.</p></li><li><p>In <a href="#VIDIOC-G-AUDIO">ioctl VIDIOC_G_AUDIO, VIDIOC_S_AUDIO(2)</a> it was clarified
that the struct&nbsp;<a href="#V4L2-AUDIO">v4l2_audio</a> <code class="STRUCTFIELD">mode</code> field is a flags
field.</p></li><li><p><a href="#VIDIOC-QUERYCAP">ioctl VIDIOC_QUERYCAP(2)</a> did not mention the
sliced VBI and radio capability flags.</p></li><li><p>In <a href="#VIDIOC-G-FREQUENCY">ioctl VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY(2)</a> it was
clarified that applications must initialize the tuner
<code class="STRUCTFIELD">type</code> field of struct&nbsp;<a href="#V4L2-FREQUENCY">v4l2_frequency</a> before
calling <a href="#VIDIOC-G-FREQUENCY"><code class="CONSTANT">VIDIOC_S_FREQUENCY</code></a>.</p></li><li><p>The <code class="STRUCTFIELD">reserved</code> array
in struct&nbsp;<a href="#V4L2-REQUESTBUFFERS">v4l2_requestbuffers</a> has 2 elements, not 32.</p></li><li><p>In <a href="#OUTPUT">Section 4.3</a> and <a href="#RAW-VBI">Section 4.7</a> the device file names
<tt class="FILENAME">/dev/vout</tt> which never caught on were replaced
by <tt class="FILENAME">/dev/video</tt>.</p></li><li><p>With Linux 2.6.15 the possible range for VBI device minor
numbers was extended from 224-239 to 224-255. Accordingly device file names
<tt class="FILENAME">/dev/vbi0</tt> to <tt class="FILENAME">/dev/vbi31</tt> are
possible now.</p></li></ol></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16297">6.2.23. V4L2 in Linux 2.6.18</a></h3><p></p><ol type="1"><li><p>New ioctls <a href="#VIDIOC-G-EXT-CTRLS"><code class="CONSTANT">VIDIOC_G_EXT_CTRLS</code></a>, <a href="#VIDIOC-G-EXT-CTRLS"><code class="CONSTANT">VIDIOC_S_EXT_CTRLS</code></a>
and <a href="#VIDIOC-G-EXT-CTRLS"><code class="CONSTANT">VIDIOC_TRY_EXT_CTRLS</code></a> were added, a flag to skip unsupported
controls with <a href="#VIDIOC-QUERYCTRL"><code class="CONSTANT">VIDIOC_QUERYCTRL</code></a>, new control types
<code class="CONSTANT">V4L2_CTRL_TYPE_INTEGER64</code> and
<code class="CONSTANT">V4L2_CTRL_TYPE_CTRL_CLASS</code> (<a href="#V4L2-CTRL-TYPE">Table 3</a>), and new control flags
<code class="CONSTANT">V4L2_CTRL_FLAG_READ_ONLY</code>,
<code class="CONSTANT">V4L2_CTRL_FLAG_UPDATE</code>,
<code class="CONSTANT">V4L2_CTRL_FLAG_INACTIVE</code> and
<code class="CONSTANT">V4L2_CTRL_FLAG_SLIDER</code> (<a href="#CONTROL-FLAGS">Table 4</a>). See <a href="#EXTENDED-CONTROLS">Section 1.9</a> for details.</p></li></ol></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16319">6.2.24. V4L2 in Linux 2.6.19</a></h3><p></p><ol type="1"><li><p>In struct&nbsp;<a href="#V4L2-SLICED-VBI-CAP">v4l2_sliced_vbi_cap</a> a buffer type field was added
replacing a reserved field. Note on architectures where the size of
enum types differs from int types the size of the structure changed.
The <a href="#VIDIOC-G-SLICED-VBI-CAP"><code class="CONSTANT">VIDIOC_G_SLICED_VBI_CAP</code></a> ioctl was redefined from being read-only
to write-read. Applications must initialize the type field and clear
the reserved fields now. These changes may <span class="emphasis"><i class="EMPHASIS">break the
compatibility</i></span> with older drivers and applications.</p></li><li><p>The ioctls <a href="#VIDIOC-ENUM-FRAMESIZES"><code class="CONSTANT">VIDIOC_ENUM_FRAMESIZES</code></a> and
<a href="#VIDIOC-ENUM-FRAMEINTERVALS"><code class="CONSTANT">VIDIOC_ENUM_FRAMEINTERVALS</code></a> were added.</p></li><li><p>A new pixel format <code class="CONSTANT">V4L2_PIX_FMT_RGB444</code> (<a href="#RGB-FORMATS">Table 2-1</a>) was added.</p></li></ol></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16338">6.2.25. V4L2 spec erratum 2006-10-12 (Draft 0.17)</a></h3><p></p><ol type="1"><li><p><code class="CONSTANT">V4L2_PIX_FMT_HM12</code> (<a href="#RESERVED-FORMATS">Table 2-8</a>) is a YUV 4:2:0, not 4:2:2 format.</p></li></ol></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16345">6.2.26. V4L2 in Linux 2.6.21</a></h3><p></p><ol type="1"><li><p>The <tt class="FILENAME">videodev2.h</tt> header file is
now dual licensed under GNU General Public License version two or
later, and under a 3-clause BSD-style license.</p></li></ol></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16351">6.2.27. V4L2 in Linux 2.6.22</a></h3><p></p><ol type="1"><li><p>Two new field orders
          <code class="CONSTANT">V4L2_FIELD_INTERLACED_TB</code> and
          <code class="CONSTANT">V4L2_FIELD_INTERLACED_BT</code> were
          added. See <a href="#V4L2-FIELD">Table 3-8</a> for details.</p></li><li><p>Three new clipping/blending methods with a global or
straight or inverted local alpha value were added to the video overlay
interface. See the description of the <a href="#VIDIOC-G-FBUF"><code class="CONSTANT">VIDIOC_G_FBUF</code></a> and
<a href="#VIDIOC-G-FBUF"><code class="CONSTANT">VIDIOC_S_FBUF</code></a> ioctls for details.</p><p>A new <code class="STRUCTFIELD">global_alpha</code> field
was added to <a href="#V4L2-WINDOW"><code class="STRUCTNAME">v4l2_window</code></a>,
extending the structure. This may <span class="emphasis"><i class="EMPHASIS">break
compatibility</i></span> with applications using a struct
<code class="STRUCTNAME">v4l2_window</code> directly. However the <a href="#VIDIOC-G-FMT">VIDIOC_G/S/TRY_FMT</a> ioctls, which take a
pointer to a <a href="#V4L2-FORMAT">v4l2_format</a> parent
structure with padding bytes at the end, are not affected.</p></li><li><p>The format of the <code class="STRUCTFIELD">chromakey</code>
field in struct&nbsp;<a href="#V4L2-WINDOW">v4l2_window</a> changed from "host order RGB32" to a pixel
value in the same format as the framebuffer. This may <span class="emphasis"><i class="EMPHASIS">break
compatibility</i></span> with existing applications. Drivers
supporting the "host order RGB32" format are not known.</p></li></ol></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16378">6.2.28. V4L2 in Linux 2.6.24</a></h3><p></p><ol type="1"><li><p>The pixel formats
<code class="CONSTANT">V4L2_PIX_FMT_PAL8</code>,
<code class="CONSTANT">V4L2_PIX_FMT_YUV444</code>,
<code class="CONSTANT">V4L2_PIX_FMT_YUV555</code>,
<code class="CONSTANT">V4L2_PIX_FMT_YUV565</code> and
<code class="CONSTANT">V4L2_PIX_FMT_YUV32</code> were added.</p></li></ol></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16388">6.2.29. V4L2 in Linux 2.6.25</a></h3><p></p><ol type="1"><li><p>The pixel formats <a href="#V4L2-PIX-FMT-Y16"><code class="CONSTANT">V4L2_PIX_FMT_Y16</code></a> and <a href="#V4L2-PIX-FMT-SBGGR16"><code class="CONSTANT">V4L2_PIX_FMT_SBGGR16</code></a> were added.</p></li><li><p>New <a href="#CONTROL">controls</a>
<code class="CONSTANT">V4L2_CID_POWER_LINE_FREQUENCY</code>,
<code class="CONSTANT">V4L2_CID_HUE_AUTO</code>,
<code class="CONSTANT">V4L2_CID_WHITE_BALANCE_TEMPERATURE</code>,
<code class="CONSTANT">V4L2_CID_SHARPNESS</code> and
<code class="CONSTANT">V4L2_CID_BACKLIGHT_COMPENSATION</code> were added. The
controls <code class="CONSTANT">V4L2_CID_BLACK_LEVEL</code>,
<code class="CONSTANT">V4L2_CID_WHITENESS</code>,
<code class="CONSTANT">V4L2_CID_HCENTER</code> and
<code class="CONSTANT">V4L2_CID_VCENTER</code> were deprecated.</p></li><li><p>A <a href="#CAMERA-CONTROLS">Camera controls
class</a> was added, with the new controls
<code class="CONSTANT">V4L2_CID_EXPOSURE_AUTO</code>,
<code class="CONSTANT">V4L2_CID_EXPOSURE_ABSOLUTE</code>,
<code class="CONSTANT">V4L2_CID_EXPOSURE_AUTO_PRIORITY</code>,
<code class="CONSTANT">V4L2_CID_PAN_RELATIVE</code>,
<code class="CONSTANT">V4L2_CID_TILT_RELATIVE</code>,
<code class="CONSTANT">V4L2_CID_PAN_RESET</code>,
<code class="CONSTANT">V4L2_CID_TILT_RESET</code>,
<code class="CONSTANT">V4L2_CID_PAN_ABSOLUTE</code>,
<code class="CONSTANT">V4L2_CID_TILT_ABSOLUTE</code>,
<code class="CONSTANT">V4L2_CID_FOCUS_ABSOLUTE</code>,
<code class="CONSTANT">V4L2_CID_FOCUS_RELATIVE</code> and
<code class="CONSTANT">V4L2_CID_FOCUS_AUTO</code>.</p></li><li><p>The <code class="CONSTANT">VIDIOC_G_MPEGCOMP</code> and
<code class="CONSTANT">VIDIOC_S_MPEGCOMP</code> ioctls, which were superseded
by the <a href="#EXTENDED-CONTROLS">extended controls</a>
interface in Linux 2.6.18, where finally removed from the
<tt class="FILENAME">videodev2.h</tt> header file.</p></li></ol></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="OTHER">6.3. Relation of V4L2 to other Linux multimedia APIs</a></h2><div class="SECTION"><h3 class="SECTION"><a name="XVIDEO">6.3.1. X Video Extension</a></h3><p>The X Video Extension (abbreviated XVideo or just Xv) is
an extension of the X Window system, implemented for example by the
XFree86 project. Its scope is similar to V4L2, an API to video capture
and output devices for X clients. Xv allows applications to display
live video in a window, send window contents to a TV output, and
capture or output still images in XPixmaps<a name="AEN16435" href="#FTN.AEN16435"><span class="footnote">[27]</span></a>. With their implementation XFree86 makes the
extension available across many operating systems and
architectures.</p><p>Because the driver is embedded into the X server Xv has a
number of advantages over the V4L2 <a href="#OVERLAY">video
overlay interface</a>. The driver can easily determine the overlay
target, i.&nbsp;e. visible graphics memory or off-screen buffers for a
destructive overlay. It can program the RAMDAC for a non-destructive
overlay, scaling or color-keying, or the clipping functions of the
video capture hardware, always in sync with drawing operations or
windows moving or changing their stacking order.</p><p>To combine the advantages of Xv and V4L a special Xv
driver exists in XFree86 and XOrg, just programming any overlay capable
Video4Linux device it finds. To enable it
<tt class="FILENAME">/etc/X11/XF86Config</tt> must contain these lines:</p><p></p><pre class="SCREEN">Section "Module"
    Load "v4l"
EndSection</pre><p></p><p>As of XFree86 4.2 this driver still supports only V4L
ioctls, however it should work just fine with all V4L2 devices through
the V4L2 backward-compatibility layer. Since V4L2 permits multiple
opens it is possible (if supported by the V4L2 driver) to capture
video while an X client requested video overlay. Restrictions of
simultaneous capturing and overlay are discussed in <a href="#OVERLAY">Section 4.2</a> apply.</p><p>Only marginally related to V4L2, XFree86 extended Xv to
support hardware YUV to RGB conversion and scaling for faster video
playback, and added an interface to MPEG-2 decoding hardware. This API
is useful to display images captured with V4L2 devices.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16446">6.3.2. Digital Video</a></h3><p>V4L2 does not support digital terrestrial, cable or
satellite broadcast. A separate project aiming at digital receivers
exists. You can find its homepage at <a href="http://linuxtv.org/" target="_top">http://linuxtv.org</a>. The Linux DVB API
has no connection to the V4L2 API except that drivers for hybrid
hardware may support both.</p></div><div class="SECTION"><hr><h3 class="SECTION"><a name="AEN16450">6.3.3. Audio Interfaces</a></h3><p>[to do - OSS/ALSA]</p></div></div><div class="SECTION"><hr><h2 class="SECTION"><a name="EXPERIMENTAL">6.4. Experimental API Elements</a></h2><p>The following V4L2 API elements are currently experimental
and may change in the future.</p><p></p><ul><li><p>Video Output Overlay (OSD) Interface, <a href="#OSD">Section 4.4</a>.</p></li><li><p><code class="CONSTANT">V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY</code>,
        enum&nbsp;<a href="#V4L2-BUF-TYPE">v4l2_buf_type</a>, <a href="#V4L2-BUF-TYPE">Table 3-2</a>.</p></li><li><p><code class="CONSTANT">V4L2_CAP_VIDEO_OUTPUT_OVERLAY</code>,
<a href="#VIDIOC-QUERYCAP"><code class="CONSTANT">VIDIOC_QUERYCAP</code></a> ioctl, <a href="#DEVICE-CAPABILITIES">Table 2</a>.</p></li><li><p><a href="#VIDIOC-ENUM-FRAMESIZES"><code class="CONSTANT">VIDIOC_ENUM_FRAMESIZES</code></a> and
<a href="#VIDIOC-ENUM-FRAMEINTERVALS"><code class="CONSTANT">VIDIOC_ENUM_FRAMEINTERVALS</code></a> ioctls.</p></li><li><p><a href="#VIDIOC-G-ENC-INDEX"><code class="CONSTANT">VIDIOC_G_ENC_INDEX</code></a> ioctl.</p></li><li><p><a href="#VIDIOC-ENCODER-CMD"><code class="CONSTANT">VIDIOC_ENCODER_CMD</code></a> and <a href="#VIDIOC-ENCODER-CMD"><code class="CONSTANT">VIDIOC_TRY_ENCODER_CMD</code></a>
ioctls.</p></li><li><p><a href="#VIDIOC-DBG-G-REGISTER"><code class="CONSTANT">VIDIOC_DBG_G_REGISTER</code></a> and <a href="#VIDIOC-DBG-G-REGISTER"><code class="CONSTANT">VIDIOC_DBG_S_REGISTER</code></a>
ioctls.</p></li><li><p><a href="#VIDIOC-G-CHIP-IDENT"><code class="CONSTANT">VIDIOC_G_CHIP_IDENT</code></a> ioctl.</p></li></ul></div><div class="SECTION"><hr><h2 class="SECTION"><a name="OBSOLETE">6.5. Obsolete API Elements</a></h2><p>The following V4L2 API elements were superseded by new
interfaces and should not be implemented in new drivers.</p><p></p><ul><li><p><code class="CONSTANT">VIDIOC_G_MPEGCOMP</code> and
<code class="CONSTANT">VIDIOC_S_MPEGCOMP</code> ioctls. Use Extended Controls,
<a href="#EXTENDED-CONTROLS">Section 1.9</a>.</p></li></ul></div></div><div class="APPENDIX"><hr><h1><a name="VIDEODEV"></a>Appendix A. Video For Linux Two Header File</h1><pre class="PROGRAMLISTING">/*
 *  Video for Linux Two header file
 *
 *  Copyright (C) 1999-2007 the contributors
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  Alternatively you can redistribute this file under the terms of the
 *  BSD license as stated below:
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in
 *     the documentation and/or other materials provided with the
 *     distribution.
 *  3. The names of its contributors may not be used to endorse or promote
 *     products derived from this software without specific prior written
 *     permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 *  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *      Header file for v4l or V4L2 drivers and applications
 * with public API.
 * All kernel-specific stuff were moved to media/v4l2-dev.h, so
 * no #if __KERNEL tests are allowed here
 *
 *      See http://linuxtv.org for more info
 *
 *      Author: Bill Dirks &lt;bill@thedirks.org&gt;
 *              Justin Schoeman
 *              Hans Verkuil &lt;hverkuil@xs4all.nl&gt;
 *              et al.
 */
#ifndef __LINUX_VIDEODEV2_H
#define __LINUX_VIDEODEV2_H
#ifdef __KERNEL__
#include &lt;linux/time.h&gt;     /* need struct timeval */
#include &lt;linux/compiler.h&gt; /* need __user */
#else
#define __user
#include &lt;sys/time.h&gt;
#endif
#include &lt;linux/ioctl.h&gt;
#include &lt;linux/types.h&gt;

/*
 * Common stuff for both V4L1 and V4L2
 * Moved from videodev.h
 */
#define VIDEO_MAX_FRAME               32

#define VID_TYPE_CAPTURE        1       /* Can capture */
#define VID_TYPE_TUNER          2       /* Can tune */
#define VID_TYPE_TELETEXT       4       /* Does teletext */
#define VID_TYPE_OVERLAY        8       /* Overlay onto frame buffer */
#define VID_TYPE_CHROMAKEY      16      /* Overlay by chromakey */
#define VID_TYPE_CLIPPING       32      /* Can clip */
#define VID_TYPE_FRAMERAM       64      /* Uses the frame buffer memory */
#define VID_TYPE_SCALES         128     /* Scalable */
#define VID_TYPE_MONOCHROME     256     /* Monochrome only */
#define VID_TYPE_SUBCAPTURE     512     /* Can capture subareas of the image */
#define VID_TYPE_MPEG_DECODER   1024    /* Can decode MPEG streams */
#define VID_TYPE_MPEG_ENCODER   2048    /* Can encode MPEG streams */
#define VID_TYPE_MJPEG_DECODER  4096    /* Can decode MJPEG streams */
#define VID_TYPE_MJPEG_ENCODER  8192    /* Can encode MJPEG streams */

/*
 *      M I S C E L L A N E O U S
 */

/*  Four-character-code (FOURCC) */
#define v4l2_fourcc(a,b,c,d)\
        (((__u32)(a)&lt;&lt;0)|((__u32)(b)&lt;&lt;8)|((__u32)(c)&lt;&lt;16)|((__u32)(d)&lt;&lt;24))

/*
 *      E N U M S
 */
enum <a href="#V4L2-FIELD">v4l2_field</a> {
        V4L2_FIELD_ANY           = 0, /* driver can choose from none,
                                         top, bottom, interlaced
                                         depending on whatever it thinks
                                         is approximate ... */
        V4L2_FIELD_NONE          = 1, /* this device has no fields ... */
        V4L2_FIELD_TOP           = 2, /* top field only */
        V4L2_FIELD_BOTTOM        = 3, /* bottom field only */
        V4L2_FIELD_INTERLACED    = 4, /* both fields interlaced */
        V4L2_FIELD_SEQ_TB        = 5, /* both fields sequential into one
                                         buffer, top-bottom order */
        V4L2_FIELD_SEQ_BT        = 6, /* same as above + bottom-top order */
        V4L2_FIELD_ALTERNATE     = 7, /* both fields alternating into
                                         separate buffers */
        V4L2_FIELD_INTERLACED_TB = 8, /* both fields interlaced, top field
                                         first and the top field is
                                         transmitted first */
        V4L2_FIELD_INTERLACED_BT = 9, /* both fields interlaced, top field
                                         first and the bottom field is
                                         transmitted first */
};
#define V4L2_FIELD_HAS_TOP(field)       \
        ((field) == V4L2_FIELD_TOP      ||\
         (field) == V4L2_FIELD_INTERLACED ||\
         (field) == V4L2_FIELD_INTERLACED_TB ||\
         (field) == V4L2_FIELD_INTERLACED_BT ||\
         (field) == V4L2_FIELD_SEQ_TB   ||\
         (field) == V4L2_FIELD_SEQ_BT)
#define V4L2_FIELD_HAS_BOTTOM(field)    \
        ((field) == V4L2_FIELD_BOTTOM   ||\
         (field) == V4L2_FIELD_INTERLACED ||\
         (field) == V4L2_FIELD_INTERLACED_TB ||\
         (field) == V4L2_FIELD_INTERLACED_BT ||\
         (field) == V4L2_FIELD_SEQ_TB   ||\
         (field) == V4L2_FIELD_SEQ_BT)
#define V4L2_FIELD_HAS_BOTH(field)      \
        ((field) == V4L2_FIELD_INTERLACED ||\
         (field) == V4L2_FIELD_INTERLACED_TB ||\
         (field) == V4L2_FIELD_INTERLACED_BT ||\
         (field) == V4L2_FIELD_SEQ_TB ||\
         (field) == V4L2_FIELD_SEQ_BT)

enum <a href="#V4L2-BUF-TYPE">v4l2_buf_type</a> {
        V4L2_BUF_TYPE_VIDEO_CAPTURE        = 1,
        V4L2_BUF_TYPE_VIDEO_OUTPUT         = 2,
        V4L2_BUF_TYPE_VIDEO_OVERLAY        = 3,
        V4L2_BUF_TYPE_VBI_CAPTURE          = 4,
        V4L2_BUF_TYPE_VBI_OUTPUT           = 5,
        V4L2_BUF_TYPE_SLICED_VBI_CAPTURE   = 6,
        V4L2_BUF_TYPE_SLICED_VBI_OUTPUT    = 7,
#if 1 /*KEEP*/
        /* Experimental */
        V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
#endif
        V4L2_BUF_TYPE_PRIVATE              = 0x80,
};

enum <a href="#V4L2-CTRL-TYPE">v4l2_ctrl_type</a> {
        V4L2_CTRL_TYPE_INTEGER       = 1,
        V4L2_CTRL_TYPE_BOOLEAN       = 2,
        V4L2_CTRL_TYPE_MENU          = 3,
        V4L2_CTRL_TYPE_BUTTON        = 4,
        V4L2_CTRL_TYPE_INTEGER64     = 5,
        V4L2_CTRL_TYPE_CTRL_CLASS    = 6,
};

enum <a href="#V4L2-TUNER-TYPE">v4l2_tuner_type</a> {
        V4L2_TUNER_RADIO             = 1,
        V4L2_TUNER_ANALOG_TV         = 2,
        V4L2_TUNER_DIGITAL_TV        = 3,
};

enum <a href="#V4L2-MEMORY">v4l2_memory</a> {
        V4L2_MEMORY_MMAP             = 1,
        V4L2_MEMORY_USERPTR          = 2,
        V4L2_MEMORY_OVERLAY          = 3,
};

/* see also http://vektor.theorem.ca/graphics/ycbcr/ */
enum <a href="#V4L2-COLORSPACE">v4l2_colorspace</a> {
        /* ITU-R 601 -- broadcast NTSC/PAL */
        V4L2_COLORSPACE_SMPTE170M     = 1,

        /* 1125-Line (US) HDTV */
        V4L2_COLORSPACE_SMPTE240M     = 2,

        /* HD and modern captures. */
        V4L2_COLORSPACE_REC709        = 3,

        /* broken BT878 extents (601, luma range 16-253 instead of 16-235) */
        V4L2_COLORSPACE_BT878         = 4,

        /* These should be useful.  Assume 601 extents. */
        V4L2_COLORSPACE_470_SYSTEM_M  = 5,
        V4L2_COLORSPACE_470_SYSTEM_BG = 6,

        /* I know there will be cameras that send this.  So, this is
         * unspecified chromaticities and full 0-255 on each of the
         * Y'CbCr components
         */
        V4L2_COLORSPACE_JPEG          = 7,

        /* For RGB colourspaces, this is probably a good start. */
        V4L2_COLORSPACE_SRGB          = 8,
};

enum <a href="#V4L2-PRIORITY">v4l2_priority</a> {
        V4L2_PRIORITY_UNSET       = 0,  /* not initialized */
        V4L2_PRIORITY_BACKGROUND  = 1,
        V4L2_PRIORITY_INTERACTIVE = 2,
        V4L2_PRIORITY_RECORD      = 3,
        V4L2_PRIORITY_DEFAULT     = V4L2_PRIORITY_INTERACTIVE,
};

struct <a href="#V4L2-RECT">v4l2_rect</a> {
        __s32   left;
        __s32   top;
        __s32   width;
        __s32   height;
};

struct <a href="#V4L2-FRACT">v4l2_fract</a> {
        __u32   numerator;
        __u32   denominator;
};

/*
 *      D R I V E R   C A P A B I L I T I E S
 */
struct <a href="#V4L2-CAPABILITY">v4l2_capability</a>
{
        __u8    driver[16];     /* i.e.ie; "bttv" */
        __u8    card[32];       /* i.e.ie; "Hauppauge WinTV" */
        __u8    bus_info[32];   /* "PCI:" + pci_name(pci_dev) */
        __u32   version;        /* should use KERNEL_VERSION() */
        __u32   capabilities;   /* Device capabilities */
        __u32   reserved[4];
};

/* Values for 'capabilities' field */
#define V4L2_CAP_VIDEO_CAPTURE          0x00000001  /* Is a video capture device */
#define V4L2_CAP_VIDEO_OUTPUT           0x00000002  /* Is a video output device */
#define V4L2_CAP_VIDEO_OVERLAY          0x00000004  /* Can do video overlay */
#define V4L2_CAP_VBI_CAPTURE            0x00000010  /* Is a raw VBI capture device */
#define V4L2_CAP_VBI_OUTPUT             0x00000020  /* Is a raw VBI output device */
#define V4L2_CAP_SLICED_VBI_CAPTURE     0x00000040  /* Is a sliced VBI capture device */
#define V4L2_CAP_SLICED_VBI_OUTPUT      0x00000080  /* Is a sliced VBI output device */
#define V4L2_CAP_RDS_CAPTURE            0x00000100  /* RDS data capture */
#define V4L2_CAP_VIDEO_OUTPUT_OVERLAY   0x00000200  /* Can do video output overlay */

#define V4L2_CAP_TUNER                  0x00010000  /* has a tuner */
#define V4L2_CAP_AUDIO                  0x00020000  /* has audio support */
#define V4L2_CAP_RADIO                  0x00040000  /* is a radio device */

#define V4L2_CAP_READWRITE              0x01000000  /* read/write systemcalls */
#define V4L2_CAP_ASYNCIO                0x02000000  /* async I/O */
#define V4L2_CAP_STREAMING              0x04000000  /* streaming I/O ioctls */

/*
 *      V I D E O   I M A G E   F O R M A T
 */
struct <a href="#V4L2-PIX-FORMAT">v4l2_pix_format</a>
{
        __u32                   width;
        __u32                   height;
        __u32                   pixelformat;
        enum <a href="#V4L2-FIELD">v4l2_field</a>         field;
        __u32                   bytesperline;   /* for padding, zero if unused */
        __u32                   sizeimage;
        enum <a href="#V4L2-COLORSPACE">v4l2_colorspace</a>    colorspace;
        __u32                   priv;           /* private data, depends on pixelformat */
};

/*      Pixel format         FOURCC                        depth  Description  */
#define <a href="#V4L2-PIX-FMT-RGB332">V4L2_PIX_FMT_RGB332</a>  v4l2_fourcc('R','G','B','1') /*  8  RGB-3-3-2     */
#define <a href="#V4L2-PIX-FMT-RGB444">V4L2_PIX_FMT_RGB444</a>  v4l2_fourcc('R','4','4','4') /* 16  xxxxrrrr ggggbbbb */
#define <a href="#V4L2-PIX-FMT-RGB555">V4L2_PIX_FMT_RGB555</a>  v4l2_fourcc('R','G','B','O') /* 16  RGB-5-5-5     */
#define <a href="#V4L2-PIX-FMT-RGB565">V4L2_PIX_FMT_RGB565</a>  v4l2_fourcc('R','G','B','P') /* 16  RGB-5-6-5     */
#define <a href="#V4L2-PIX-FMT-RGB555X">V4L2_PIX_FMT_RGB555X</a> v4l2_fourcc('R','G','B','Q') /* 16  RGB-5-5-5 BE  */
#define <a href="#V4L2-PIX-FMT-RGB565X">V4L2_PIX_FMT_RGB565X</a> v4l2_fourcc('R','G','B','R') /* 16  RGB-5-6-5 BE  */
#define <a href="#V4L2-PIX-FMT-BGR24">V4L2_PIX_FMT_BGR24</a>   v4l2_fourcc('B','G','R','3') /* 24  BGR-8-8-8     */
#define <a href="#V4L2-PIX-FMT-RGB24">V4L2_PIX_FMT_RGB24</a>   v4l2_fourcc('R','G','B','3') /* 24  RGB-8-8-8     */
#define <a href="#V4L2-PIX-FMT-BGR32">V4L2_PIX_FMT_BGR32</a>   v4l2_fourcc('B','G','R','4') /* 32  BGR-8-8-8-8   */
#define <a href="#V4L2-PIX-FMT-RGB32">V4L2_PIX_FMT_RGB32</a>   v4l2_fourcc('R','G','B','4') /* 32  RGB-8-8-8-8   */
#define <a href="#V4L2-PIX-FMT-GREY">V4L2_PIX_FMT_GREY</a>    v4l2_fourcc('G','R','E','Y') /*  8  Greyscale     */
#define <a href="#V4L2-PIX-FMT-Y16">V4L2_PIX_FMT_Y16</a>     v4l2_fourcc('Y','1','6',' ') /* 16  Greyscale     */
#define <a href="#V4L2-PIX-FMT-PAL8">V4L2_PIX_FMT_PAL8</a>    v4l2_fourcc('P','A','L','8') /*  8  8-bit palette */
#define <a href="#V4L2-PIX-FMT-YVU410">V4L2_PIX_FMT_YVU410</a>  v4l2_fourcc('Y','V','U','9') /*  9  YVU 4:1:0     */
#define <a href="#V4L2-PIX-FMT-YVU420">V4L2_PIX_FMT_YVU420</a>  v4l2_fourcc('Y','V','1','2') /* 12  YVU 4:2:0     */
#define <a href="#V4L2-PIX-FMT-YUYV">V4L2_PIX_FMT_YUYV</a>    v4l2_fourcc('Y','U','Y','V') /* 16  YUV 4:2:2     */
#define <a href="#V4L2-PIX-FMT-UYVY">V4L2_PIX_FMT_UYVY</a>    v4l2_fourcc('U','Y','V','Y') /* 16  YUV 4:2:2     */
#define <a href="#V4L2-PIX-FMT-YUV422P">V4L2_PIX_FMT_YUV422P</a> v4l2_fourcc('4','2','2','P') /* 16  YVU422 planar */
#define <a href="#V4L2-PIX-FMT-YUV411P">V4L2_PIX_FMT_YUV411P</a> v4l2_fourcc('4','1','1','P') /* 16  YVU411 planar */
#define <a href="#V4L2-PIX-FMT-Y41P">V4L2_PIX_FMT_Y41P</a>    v4l2_fourcc('Y','4','1','P') /* 12  YUV 4:1:1     */
#define <a href="#V4L2-PIX-FMT-YUV444">V4L2_PIX_FMT_YUV444</a>  v4l2_fourcc('Y','4','4','4') /* 16  xxxxyyyy uuuuvvvv */
#define <a href="#V4L2-PIX-FMT-YUV555">V4L2_PIX_FMT_YUV555</a>  v4l2_fourcc('Y','U','V','O') /* 16  YUV-5-5-5     */
#define <a href="#V4L2-PIX-FMT-YUV565">V4L2_PIX_FMT_YUV565</a>  v4l2_fourcc('Y','U','V','P') /* 16  YUV-5-6-5     */
#define <a href="#V4L2-PIX-FMT-YUV32">V4L2_PIX_FMT_YUV32</a>   v4l2_fourcc('Y','U','V','4') /* 32  YUV-8-8-8-8   */

/* two planes -- one Y, one Cr + Cb interleaved  */
#define <a href="#V4L2-PIX-FMT-NV12">V4L2_PIX_FMT_NV12</a>    v4l2_fourcc('N','V','1','2') /* 12  Y/CbCr 4:2:0  */
#define <a href="#V4L2-PIX-FMT-NV21">V4L2_PIX_FMT_NV21</a>    v4l2_fourcc('N','V','2','1') /* 12  Y/CrCb 4:2:0  */

/*  The following formats are not defined in the V4L2 specification */
#define <a href="#V4L2-PIX-FMT-YUV410">V4L2_PIX_FMT_YUV410</a>  v4l2_fourcc('Y','U','V','9') /*  9  YUV 4:1:0     */
#define <a href="#V4L2-PIX-FMT-YUV420">V4L2_PIX_FMT_YUV420</a>  v4l2_fourcc('Y','U','1','2') /* 12  YUV 4:2:0     */
#define <a href="#V4L2-PIX-FMT-YYUV">V4L2_PIX_FMT_YYUV</a>    v4l2_fourcc('Y','Y','U','V') /* 16  YUV 4:2:2     */
#define <a href="#V4L2-PIX-FMT-HI240">V4L2_PIX_FMT_HI240</a>   v4l2_fourcc('H','I','2','4') /*  8  8-bit color   */
#define <a href="#V4L2-PIX-FMT-HM12">V4L2_PIX_FMT_HM12</a>    v4l2_fourcc('H','M','1','2') /*  8  YUV 4:2:0 16x16 macroblocks */

/* see http://www.siliconimaging.com/RGB%20Bayer.htm */
#define <a href="#V4L2-PIX-FMT-SBGGR8">V4L2_PIX_FMT_SBGGR8</a>  v4l2_fourcc('B','A','8','1') /*  8  BGBG.. GRGR.. */
#define <a href="#V4L2-PIX-FMT-SBGGR16">V4L2_PIX_FMT_SBGGR16</a> v4l2_fourcc('B','Y','R','2') /* 16  BGBG.. GRGR.. */

/* compressed formats */
#define <a href="#V4L2-PIX-FMT-MJPEG">V4L2_PIX_FMT_MJPEG</a>    v4l2_fourcc('M','J','P','G') /* Motion-JPEG   */
#define <a href="#V4L2-PIX-FMT-JPEG">V4L2_PIX_FMT_JPEG</a>     v4l2_fourcc('J','P','E','G') /* JFIF JPEG     */
#define <a href="#V4L2-PIX-FMT-DV">V4L2_PIX_FMT_DV</a>       v4l2_fourcc('d','v','s','d') /* 1394          */
#define <a href="#V4L2-PIX-FMT-MPEG">V4L2_PIX_FMT_MPEG</a>     v4l2_fourcc('M','P','E','G') /* MPEG-1/2/4    */

/*  Vendor-specific formats   */
#define <a href="#V4L2-PIX-FMT-WNVA">V4L2_PIX_FMT_WNVA</a>     v4l2_fourcc('W','N','V','A') /* Winnov hw compress */
#define <a href="#V4L2-PIX-FMT-SN9C10X">V4L2_PIX_FMT_SN9C10X</a>  v4l2_fourcc('S','9','1','0') /* SN9C10x compression */
#define <a href="#V4L2-PIX-FMT-PWC1">V4L2_PIX_FMT_PWC1</a>     v4l2_fourcc('P','W','C','1') /* pwc older webcam */
#define <a href="#V4L2-PIX-FMT-PWC2">V4L2_PIX_FMT_PWC2</a>     v4l2_fourcc('P','W','C','2') /* pwc newer webcam */
#define <a href="#V4L2-PIX-FMT-ET61X251">V4L2_PIX_FMT_ET61X251</a> v4l2_fourcc('E','6','2','5') /* ET61X251 compression */

/*
 *      F O R M A T   E N U M E R A T I O N
 */
struct <a href="#V4L2-FMTDESC">v4l2_fmtdesc</a>
{
        __u32               index;             /* Format number      */
        enum <a href="#V4L2-BUF-TYPE">v4l2_buf_type</a>  type;              /* buffer type        */
        __u32               flags;
        __u8                description[32];   /* Description string */
        __u32               pixelformat;       /* Format fourcc      */
        __u32               reserved[4];
};

#define V4L2_FMT_FLAG_COMPRESSED 0x0001

#if 1 /*KEEP*/
        /* Experimental Frame Size and frame rate enumeration */
/*
 *      F R A M E   S I Z E   E N U M E R A T I O N
 */
enum <a href="#V4L2-FRMSIZETYPES">v4l2_frmsizetypes</a>
{
        V4L2_FRMSIZE_TYPE_DISCRETE      = 1,
        V4L2_FRMSIZE_TYPE_CONTINUOUS    = 2,
        V4L2_FRMSIZE_TYPE_STEPWISE      = 3,
};

struct <a href="#V4L2-FRMSIZE-DISCRETE">v4l2_frmsize_discrete</a>
{
        __u32                   width;          /* Frame width [pixel] */
        __u32                   height;         /* Frame height [pixel] */
};

struct <a href="#V4L2-FRMSIZE-STEPWISE">v4l2_frmsize_stepwise</a>
{
        __u32                   min_width;      /* Minimum frame width [pixel] */
        __u32                   max_width;      /* Maximum frame width [pixel] */
        __u32                   step_width;     /* Frame width step size [pixel] */
        __u32                   min_height;     /* Minimum frame height [pixel] */
        __u32                   max_height;     /* Maximum frame height [pixel] */
        __u32                   step_height;    /* Frame height step size [pixel] */
};

struct <a href="#V4L2-FRMSIZEENUM">v4l2_frmsizeenum</a>
{
        __u32                   index;          /* Frame size number */
        __u32                   pixel_format;   /* Pixel format */
        __u32                   type;           /* Frame size type the device supports. */

        union {                                 /* Frame size */
                struct <a href="#V4L2-FRMSIZE-DISCRETE">v4l2_frmsize_discrete</a>    discrete;
                struct <a href="#V4L2-FRMSIZE-STEPWISE">v4l2_frmsize_stepwise</a>    stepwise;
        };

        __u32   reserved[2];                    /* Reserved space for future use */
};

/*
 *      F R A M E   R A T E   E N U M E R A T I O N
 */
enum <a href="#V4L2-FRMIVALTYPES">v4l2_frmivaltypes</a>
{
        V4L2_FRMIVAL_TYPE_DISCRETE      = 1,
        V4L2_FRMIVAL_TYPE_CONTINUOUS    = 2,
        V4L2_FRMIVAL_TYPE_STEPWISE      = 3,
};

struct <a href="#V4L2-FRMIVAL-STEPWISE">v4l2_frmival_stepwise</a>
{
        struct <a href="#V4L2-FRACT">v4l2_fract</a>       min;            /* Minimum frame interval [s] */
        struct <a href="#V4L2-FRACT">v4l2_fract</a>       max;            /* Maximum frame interval [s] */
        struct <a href="#V4L2-FRACT">v4l2_fract</a>       step;           /* Frame interval step size [s] */
};

struct <a href="#V4L2-FRMIVALENUM">v4l2_frmivalenum</a>
{
        __u32                   index;          /* Frame format index */
        __u32                   pixel_format;   /* Pixel format */
        __u32                   width;          /* Frame width */
        __u32                   height;         /* Frame height */
        __u32                   type;           /* Frame interval type the device supports. */

        union {                                 /* Frame interval */
                struct <a href="#V4L2-FRACT">v4l2_fract</a>               discrete;
                struct <a href="#V4L2-FRMIVAL-STEPWISE">v4l2_frmival_stepwise</a>    stepwise;
        };

        __u32   reserved[2];                    /* Reserved space for future use */
};
#endif

/*
 *      T I M E C O D E
 */
struct <a href="#V4L2-TIMECODE">v4l2_timecode</a>
{
        __u32   type;
        __u32   flags;
        __u8    frames;
        __u8    seconds;
        __u8    minutes;
        __u8    hours;
        __u8    userbits[4];
};

/*  Type  */
#define V4L2_TC_TYPE_24FPS              1
#define V4L2_TC_TYPE_25FPS              2
#define V4L2_TC_TYPE_30FPS              3
#define V4L2_TC_TYPE_50FPS              4
#define V4L2_TC_TYPE_60FPS              5

/*  Flags  */
#define V4L2_TC_FLAG_DROPFRAME          0x0001 /* "drop-frame" mode */
#define V4L2_TC_FLAG_COLORFRAME         0x0002
#define V4L2_TC_USERBITS_field          0x000C
#define V4L2_TC_USERBITS_USERDEFINED    0x0000
#define V4L2_TC_USERBITS_8BITCHARS      0x0008
/* The above is based on SMPTE timecodes */

struct <a href="#V4L2-JPEGCOMPRESSION">v4l2_jpegcompression</a>
{
        int quality;

        int  APPn;              /* Number of APP segment to be written,
                                 * must be 0..15 */
        int  APP_len;           /* Length of data in JPEG APPn segment */
        char APP_data[60];      /* Data in the JPEG APPn segment. */

        int  COM_len;           /* Length of data in JPEG COM segment */
        char COM_data[60];      /* Data in JPEG COM segment */

        __u32 jpeg_markers;     /* Which markers should go into the JPEG
                                 * output. Unless you exactly know what
                                 * you do, leave them untouched.
                                 * Inluding less markers will make the
                                 * resulting code smaller, but there will
                                 * be fewer aplications which can read it.
                                 * The presence of the APP and COM marker
                                 * is influenced by APP_len and COM_len
                                 * ONLY, not by this property! */

#define V4L2_JPEG_MARKER_DHT (1&lt;&lt;3)    /* Define Huffman Tables */
#define V4L2_JPEG_MARKER_DQT (1&lt;&lt;4)    /* Define Quantization Tables */
#define V4L2_JPEG_MARKER_DRI (1&lt;&lt;5)    /* Define Restart Interval */
#define V4L2_JPEG_MARKER_COM (1&lt;&lt;6)    /* Comment segment */
#define V4L2_JPEG_MARKER_APP (1&lt;&lt;7)    /* App segment, driver will
                                        * allways use APP0 */
};

/*
 *      M E M O R Y - M A P P I N G   B U F F E R S
 */
struct <a href="#V4L2-REQUESTBUFFERS">v4l2_requestbuffers</a>
{
        __u32                   count;
        enum <a href="#V4L2-BUF-TYPE">v4l2_buf_type</a>      type;
        enum <a href="#V4L2-MEMORY">v4l2_memory</a>        memory;
        __u32                   reserved[2];
};

struct <a href="#V4L2-BUFFER">v4l2_buffer</a>
{
        __u32                   index;
        enum <a href="#V4L2-BUF-TYPE">v4l2_buf_type</a>      type;
        __u32                   bytesused;
        __u32                   flags;
        enum <a href="#V4L2-FIELD">v4l2_field</a>         field;
        struct timeval          timestamp;
        struct <a href="#V4L2-TIMECODE">v4l2_timecode</a>    timecode;
        __u32                   sequence;

        /* memory location */
        enum <a href="#V4L2-MEMORY">v4l2_memory</a>        memory;
        union {
                __u32           offset;
                unsigned long   userptr;
        } m;
        __u32                   length;
        __u32                   input;
        __u32                   reserved;
};

/*  Flags for 'flags' field */
#define V4L2_BUF_FLAG_MAPPED    0x0001  /* Buffer is mapped (flag) */
#define V4L2_BUF_FLAG_QUEUED    0x0002  /* Buffer is queued for processing */
#define V4L2_BUF_FLAG_DONE      0x0004  /* Buffer is ready */
#define V4L2_BUF_FLAG_KEYFRAME  0x0008  /* Image is a keyframe (I-frame) */
#define V4L2_BUF_FLAG_PFRAME    0x0010  /* Image is a P-frame */
#define V4L2_BUF_FLAG_BFRAME    0x0020  /* Image is a B-frame */
#define V4L2_BUF_FLAG_TIMECODE  0x0100  /* timecode field is valid */
#define V4L2_BUF_FLAG_INPUT     0x0200  /* input field is valid */

/*
 *      O V E R L A Y   P R E V I E W
 */
struct <a href="#V4L2-FRAMEBUFFER">v4l2_framebuffer</a>
{
        __u32                   capability;
        __u32                   flags;
/* FIXME: in theory we should pass something like PCI device + memory
 * region + offset instead of some physical address */
        void*                   base;
        struct <a href="#V4L2-PIX-FORMAT">v4l2_pix_format</a>  fmt;
};
/*  Flags for the 'capability' field. Read only */
#define V4L2_FBUF_CAP_EXTERNOVERLAY     0x0001
#define V4L2_FBUF_CAP_CHROMAKEY         0x0002
#define V4L2_FBUF_CAP_LIST_CLIPPING     0x0004
#define V4L2_FBUF_CAP_BITMAP_CLIPPING   0x0008
#define V4L2_FBUF_CAP_LOCAL_ALPHA       0x0010
#define V4L2_FBUF_CAP_GLOBAL_ALPHA      0x0020
#define V4L2_FBUF_CAP_LOCAL_INV_ALPHA   0x0040
/*  Flags for the 'flags' field. */
#define V4L2_FBUF_FLAG_PRIMARY          0x0001
#define V4L2_FBUF_FLAG_OVERLAY          0x0002
#define V4L2_FBUF_FLAG_CHROMAKEY        0x0004
#define V4L2_FBUF_FLAG_LOCAL_ALPHA      0x0008
#define V4L2_FBUF_FLAG_GLOBAL_ALPHA     0x0010
#define V4L2_FBUF_FLAG_LOCAL_INV_ALPHA  0x0020

struct <a href="#V4L2-CLIP">v4l2_clip</a>
{
        struct <a href="#V4L2-RECT">v4l2_rect</a>        c;
        struct <a href="#V4L2-CLIP">v4l2_clip</a>        __user *next;
};

struct <a href="#V4L2-WINDOW">v4l2_window</a>
{
        struct <a href="#V4L2-RECT">v4l2_rect</a>        w;
        enum <a href="#V4L2-FIELD">v4l2_field</a>         field;
        __u32                   chromakey;
        struct <a href="#V4L2-CLIP">v4l2_clip</a>        __user *clips;
        __u32                   clipcount;
        void                    __user *bitmap;
        __u8                    global_alpha;
};

/*
 *      C A P T U R E   P A R A M E T E R S
 */
struct <a href="#V4L2-CAPTUREPARM">v4l2_captureparm</a>
{
        __u32              capability;    /*  Supported modes */
        __u32              capturemode;   /*  Current mode */
        struct <a href="#V4L2-FRACT">v4l2_fract</a>  timeperframe;  /*  Time per frame in .1us units */
        __u32              extendedmode;  /*  Driver-specific extensions */
        __u32              readbuffers;   /*  # of buffers for read */
        __u32              reserved[4];
};

/*  Flags for 'capability' and 'capturemode' fields */
#define V4L2_MODE_HIGHQUALITY   0x0001  /*  High quality imaging mode */
#define V4L2_CAP_TIMEPERFRAME   0x1000  /*  timeperframe field is supported */

struct <a href="#V4L2-OUTPUTPARM">v4l2_outputparm</a>
{
        __u32              capability;   /*  Supported modes */
        __u32              outputmode;   /*  Current mode */
        struct <a href="#V4L2-FRACT">v4l2_fract</a>  timeperframe; /*  Time per frame in seconds */
        __u32              extendedmode; /*  Driver-specific extensions */
        __u32              writebuffers; /*  # of buffers for write */
        __u32              reserved[4];
};

/*
 *      I N P U T   I M A G E   C R O P P I N G
 */
struct <a href="#V4L2-CROPCAP">v4l2_cropcap</a> {
        enum <a href="#V4L2-BUF-TYPE">v4l2_buf_type</a>      type;
        struct <a href="#V4L2-RECT">v4l2_rect</a>        bounds;
        struct <a href="#V4L2-RECT">v4l2_rect</a>        defrect;
        struct <a href="#V4L2-FRACT">v4l2_fract</a>       pixelaspect;
};

struct <a href="#V4L2-CROP">v4l2_crop</a> {
        enum <a href="#V4L2-BUF-TYPE">v4l2_buf_type</a>      type;
        struct <a href="#V4L2-RECT">v4l2_rect</a>        c;
};

/*
 *      A N A L O G   V I D E O   S T A N D A R D
 */

typedef __u64 v4l2_std_id;

/* one bit for each */
#define V4L2_STD_PAL_B          ((v4l2_std_id)0x00000001)
#define V4L2_STD_PAL_B1         ((v4l2_std_id)0x00000002)
#define V4L2_STD_PAL_G          ((v4l2_std_id)0x00000004)
#define V4L2_STD_PAL_H          ((v4l2_std_id)0x00000008)
#define V4L2_STD_PAL_I          ((v4l2_std_id)0x00000010)
#define V4L2_STD_PAL_D          ((v4l2_std_id)0x00000020)
#define V4L2_STD_PAL_D1         ((v4l2_std_id)0x00000040)
#define V4L2_STD_PAL_K          ((v4l2_std_id)0x00000080)

#define V4L2_STD_PAL_M          ((v4l2_std_id)0x00000100)
#define V4L2_STD_PAL_N          ((v4l2_std_id)0x00000200)
#define V4L2_STD_PAL_Nc         ((v4l2_std_id)0x00000400)
#define V4L2_STD_PAL_60         ((v4l2_std_id)0x00000800)

#define V4L2_STD_NTSC_M         ((v4l2_std_id)0x00001000)
#define V4L2_STD_NTSC_M_JP      ((v4l2_std_id)0x00002000)
#define V4L2_STD_NTSC_443       ((v4l2_std_id)0x00004000)
#define V4L2_STD_NTSC_M_KR      ((v4l2_std_id)0x00008000)

#define V4L2_STD_SECAM_B        ((v4l2_std_id)0x00010000)
#define V4L2_STD_SECAM_D        ((v4l2_std_id)0x00020000)
#define V4L2_STD_SECAM_G        ((v4l2_std_id)0x00040000)
#define V4L2_STD_SECAM_H        ((v4l2_std_id)0x00080000)
#define V4L2_STD_SECAM_K        ((v4l2_std_id)0x00100000)
#define V4L2_STD_SECAM_K1       ((v4l2_std_id)0x00200000)
#define V4L2_STD_SECAM_L        ((v4l2_std_id)0x00400000)
#define V4L2_STD_SECAM_LC       ((v4l2_std_id)0x00800000)

/* ATSC/HDTV */
#define V4L2_STD_ATSC_8_VSB     ((v4l2_std_id)0x01000000)
#define V4L2_STD_ATSC_16_VSB    ((v4l2_std_id)0x02000000)

/* FIXME:
   Although std_id is 64 bits, there is an issue on PPC32 architecture that
   makes switch(__u64) to break. So, there's a hack on v4l2-common.c rounding
   this value to 32 bits.
   As, currently, the max value is for V4L2_STD_ATSC_16_VSB (30 bits wide),
   it should work fine. However, if needed to add more than two standards,
   v4l2-common.c should be fixed.
 */

/* some merged standards */
#define V4L2_STD_MN     (V4L2_STD_PAL_M|V4L2_STD_PAL_N|V4L2_STD_PAL_Nc|V4L2_STD_NTSC)
#define V4L2_STD_B      (V4L2_STD_PAL_B|V4L2_STD_PAL_B1|V4L2_STD_SECAM_B)
#define V4L2_STD_GH     (V4L2_STD_PAL_G|V4L2_STD_PAL_H|V4L2_STD_SECAM_G|V4L2_STD_SECAM_H)
#define V4L2_STD_DK     (V4L2_STD_PAL_DK|V4L2_STD_SECAM_DK)

/* some common needed stuff */
#define V4L2_STD_PAL_BG         (V4L2_STD_PAL_B         |\
                                 V4L2_STD_PAL_B1        |\
                                 V4L2_STD_PAL_G)
#define V4L2_STD_PAL_DK         (V4L2_STD_PAL_D         |\
                                 V4L2_STD_PAL_D1        |\
                                 V4L2_STD_PAL_K)
#define V4L2_STD_PAL            (V4L2_STD_PAL_BG        |\
                                 V4L2_STD_PAL_DK        |\
                                 V4L2_STD_PAL_H         |\
                                 V4L2_STD_PAL_I)
#define V4L2_STD_NTSC           (V4L2_STD_NTSC_M        |\
                                 V4L2_STD_NTSC_M_JP     |\
                                 V4L2_STD_NTSC_M_KR)
#define V4L2_STD_SECAM_DK       (V4L2_STD_SECAM_D       |\
                                 V4L2_STD_SECAM_K       |\
                                 V4L2_STD_SECAM_K1)
#define V4L2_STD_SECAM          (V4L2_STD_SECAM_B       |\
                                 V4L2_STD_SECAM_G       |\
                                 V4L2_STD_SECAM_H       |\
                                 V4L2_STD_SECAM_DK      |\
                                 V4L2_STD_SECAM_L       |\
                                 V4L2_STD_SECAM_LC)

#define V4L2_STD_525_60         (V4L2_STD_PAL_M         |\
                                 V4L2_STD_PAL_60        |\
                                 V4L2_STD_NTSC          |\
                                 V4L2_STD_NTSC_443)
#define V4L2_STD_625_50         (V4L2_STD_PAL           |\
                                 V4L2_STD_PAL_N         |\
                                 V4L2_STD_PAL_Nc        |\
                                 V4L2_STD_SECAM)
#define V4L2_STD_ATSC           (V4L2_STD_ATSC_8_VSB    |\
                                 V4L2_STD_ATSC_16_VSB)

#define V4L2_STD_UNKNOWN        0
#define V4L2_STD_ALL            (V4L2_STD_525_60        |\
                                 V4L2_STD_625_50)

struct <a href="#V4L2-STANDARD">v4l2_standard</a>
{
        __u32                index;
        v4l2_std_id          id;
        __u8                 name[24];
        struct <a href="#V4L2-FRACT">v4l2_fract</a>    frameperiod; /* Frames, not fields */
        __u32                framelines;
        __u32                reserved[4];
};

/*
 *      V I D E O   I N P U T S
 */
struct <a href="#V4L2-INPUT">v4l2_input</a>
{
        __u32        index;             /*  Which input */
        __u8         name[32];          /*  Label */
        __u32        type;              /*  Type of input */
        __u32        audioset;          /*  Associated audios (bitfield) */
        __u32        tuner;             /*  Associated tuner */
        v4l2_std_id  std;
        __u32        status;
        __u32        reserved[4];
};

/*  Values for the 'type' field */
#define V4L2_INPUT_TYPE_TUNER           1
#define V4L2_INPUT_TYPE_CAMERA          2

/* field 'status' - general */
#define V4L2_IN_ST_NO_POWER    0x00000001  /* Attached device is off */
#define V4L2_IN_ST_NO_SIGNAL   0x00000002
#define V4L2_IN_ST_NO_COLOR    0x00000004

/* field 'status' - analog */
#define V4L2_IN_ST_NO_H_LOCK   0x00000100  /* No horizontal sync lock */
#define V4L2_IN_ST_COLOR_KILL  0x00000200  /* Color killer is active */

/* field 'status' - digital */
#define V4L2_IN_ST_NO_SYNC     0x00010000  /* No synchronization lock */
#define V4L2_IN_ST_NO_EQU      0x00020000  /* No equalizer lock */
#define V4L2_IN_ST_NO_CARRIER  0x00040000  /* Carrier recovery failed */

/* field 'status' - VCR and set-top box */
#define V4L2_IN_ST_MACROVISION 0x01000000  /* Macrovision detected */
#define V4L2_IN_ST_NO_ACCESS   0x02000000  /* Conditional access denied */
#define V4L2_IN_ST_VTR         0x04000000  /* VTR time constant */

/*
 *      V I D E O   O U T P U T S
 */
struct <a href="#V4L2-OUTPUT">v4l2_output</a>
{
        __u32        index;             /*  Which output */
        __u8         name[32];          /*  Label */
        __u32        type;              /*  Type of output */
        __u32        audioset;          /*  Associated audios (bitfield) */
        __u32        modulator;         /*  Associated modulator */
        v4l2_std_id  std;
        __u32        reserved[4];
};
/*  Values for the 'type' field */
#define V4L2_OUTPUT_TYPE_MODULATOR              1
#define V4L2_OUTPUT_TYPE_ANALOG                 2
#define V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY       3

/*
 *      C O N T R O L S
 */
struct <a href="#V4L2-CONTROL">v4l2_control</a>
{
        __u32                id;
        __s32                value;
};

struct <a href="#V4L2-EXT-CONTROL">v4l2_ext_control</a>
{
        __u32 id;
        __u32 reserved2[2];
        union {
                __s32 value;
                __s64 value64;
                void *reserved;
        };
} __attribute__ ((packed));

struct <a href="#V4L2-EXT-CONTROLS">v4l2_ext_controls</a>
{
        __u32 ctrl_class;
        __u32 count;
        __u32 error_idx;
        __u32 reserved[2];
        struct <a href="#V4L2-EXT-CONTROL">v4l2_ext_control</a> *controls;
};

/*  Values for ctrl_class field */
#define V4L2_CTRL_CLASS_USER 0x00980000 /* Old-style 'user' controls */
#define V4L2_CTRL_CLASS_MPEG 0x00990000 /* MPEG-compression controls */
#define V4L2_CTRL_CLASS_CAMERA 0x009a0000       /* Camera class controls */

#define V4L2_CTRL_ID_MASK         (0x0fffffff)
#define V4L2_CTRL_ID2CLASS(id)    ((id) &amp; 0x0fff0000UL)
#define V4L2_CTRL_DRIVER_PRIV(id) (((id) &amp; 0xffff) &gt;= 0x1000)

/*  Used in the VIDIOC_QUERYCTRL ioctl for querying controls */
struct <a href="#V4L2-QUERYCTRL">v4l2_queryctrl</a>
{
        __u32                id;
        enum <a href="#V4L2-CTRL-TYPE">v4l2_ctrl_type</a>  type;
        __u8                 name[32];  /* Whatever */
        __s32                minimum;   /* Note signedness */
        __s32                maximum;
        __s32                step;
        __s32                default_value;
        __u32                flags;
        __u32                reserved[2];
};

/*  Used in the VIDIOC_QUERYMENU ioctl for querying menu items */
struct <a href="#V4L2-QUERYMENU">v4l2_querymenu</a>
{
        __u32           id;
        __u32           index;
        __u8            name[32];       /* Whatever */
        __u32           reserved;
};

/*  Control flags  */
#define V4L2_CTRL_FLAG_DISABLED         0x0001
#define V4L2_CTRL_FLAG_GRABBED          0x0002
#define V4L2_CTRL_FLAG_READ_ONLY        0x0004
#define V4L2_CTRL_FLAG_UPDATE           0x0008
#define V4L2_CTRL_FLAG_INACTIVE         0x0010
#define V4L2_CTRL_FLAG_SLIDER           0x0020

/*  Query flag, to be ORed with the control ID */
#define V4L2_CTRL_FLAG_NEXT_CTRL        0x80000000

/*  User-class control IDs defined by V4L2 */
#define V4L2_CID_BASE                   (V4L2_CTRL_CLASS_USER | 0x900)
#define V4L2_CID_USER_BASE              V4L2_CID_BASE
/*  IDs reserved for driver specific controls */
#define V4L2_CID_PRIVATE_BASE           0x08000000

#define V4L2_CID_USER_CLASS             (V4L2_CTRL_CLASS_USER | 1)
#define V4L2_CID_BRIGHTNESS             (V4L2_CID_BASE+0)
#define V4L2_CID_CONTRAST               (V4L2_CID_BASE+1)
#define V4L2_CID_SATURATION             (V4L2_CID_BASE+2)
#define V4L2_CID_HUE                    (V4L2_CID_BASE+3)
#define V4L2_CID_AUDIO_VOLUME           (V4L2_CID_BASE+5)
#define V4L2_CID_AUDIO_BALANCE          (V4L2_CID_BASE+6)
#define V4L2_CID_AUDIO_BASS             (V4L2_CID_BASE+7)
#define V4L2_CID_AUDIO_TREBLE           (V4L2_CID_BASE+8)
#define V4L2_CID_AUDIO_MUTE             (V4L2_CID_BASE+9)
#define V4L2_CID_AUDIO_LOUDNESS         (V4L2_CID_BASE+10)
#define V4L2_CID_BLACK_LEVEL            (V4L2_CID_BASE+11) /* Deprecated */
#define V4L2_CID_AUTO_WHITE_BALANCE     (V4L2_CID_BASE+12)
#define V4L2_CID_DO_WHITE_BALANCE       (V4L2_CID_BASE+13)
#define V4L2_CID_RED_BALANCE            (V4L2_CID_BASE+14)
#define V4L2_CID_BLUE_BALANCE           (V4L2_CID_BASE+15)
#define V4L2_CID_GAMMA                  (V4L2_CID_BASE+16)
#define V4L2_CID_WHITENESS              (V4L2_CID_GAMMA) /* Deprecated */
#define V4L2_CID_EXPOSURE               (V4L2_CID_BASE+17)
#define V4L2_CID_AUTOGAIN               (V4L2_CID_BASE+18)
#define V4L2_CID_GAIN                   (V4L2_CID_BASE+19)
#define V4L2_CID_HFLIP                  (V4L2_CID_BASE+20)
#define V4L2_CID_VFLIP                  (V4L2_CID_BASE+21)

/* Deprecated, use V4L2_CID_PAN_RESET and V4L2_CID_TILT_RESET */
#define V4L2_CID_HCENTER_DEPRECATED     (V4L2_CID_BASE+22)
#define V4L2_CID_VCENTER_DEPRECATED     (V4L2_CID_BASE+23)

#define V4L2_CID_POWER_LINE_FREQUENCY   (V4L2_CID_BASE+24)
enum&nbsp;v4l2_power_line_frequency {
        V4L2_CID_POWER_LINE_FREQUENCY_DISABLED  = 0,
        V4L2_CID_POWER_LINE_FREQUENCY_50HZ      = 1,
        V4L2_CID_POWER_LINE_FREQUENCY_60HZ      = 2,
};
#define V4L2_CID_HUE_AUTO                       (V4L2_CID_BASE+25)
#define V4L2_CID_WHITE_BALANCE_TEMPERATURE      (V4L2_CID_BASE+26)
#define V4L2_CID_SHARPNESS                      (V4L2_CID_BASE+27)
#define V4L2_CID_BACKLIGHT_COMPENSATION         (V4L2_CID_BASE+28)
#define V4L2_CID_LASTP1                         (V4L2_CID_BASE+29) /* last CID + 1 */

/*  MPEG-class control IDs defined by V4L2 */
#define V4L2_CID_MPEG_BASE                      (V4L2_CTRL_CLASS_MPEG | 0x900)
#define V4L2_CID_MPEG_CLASS                     (V4L2_CTRL_CLASS_MPEG | 1)

/*  MPEG streams */
#define V4L2_CID_MPEG_STREAM_TYPE               (V4L2_CID_MPEG_BASE+0)
enum&nbsp;v4l2_mpeg_stream_type {
        V4L2_MPEG_STREAM_TYPE_MPEG2_PS   = 0, /* MPEG-2 program stream */
        V4L2_MPEG_STREAM_TYPE_MPEG2_TS   = 1, /* MPEG-2 transport stream */
        V4L2_MPEG_STREAM_TYPE_MPEG1_SS   = 2, /* MPEG-1 system stream */
        V4L2_MPEG_STREAM_TYPE_MPEG2_DVD  = 3, /* MPEG-2 DVD-compatible stream */
        V4L2_MPEG_STREAM_TYPE_MPEG1_VCD  = 4, /* MPEG-1 VCD-compatible stream */
        V4L2_MPEG_STREAM_TYPE_MPEG2_SVCD = 5, /* MPEG-2 SVCD-compatible stream */
};
#define V4L2_CID_MPEG_STREAM_PID_PMT            (V4L2_CID_MPEG_BASE+1)
#define V4L2_CID_MPEG_STREAM_PID_AUDIO          (V4L2_CID_MPEG_BASE+2)
#define V4L2_CID_MPEG_STREAM_PID_VIDEO          (V4L2_CID_MPEG_BASE+3)
#define V4L2_CID_MPEG_STREAM_PID_PCR            (V4L2_CID_MPEG_BASE+4)
#define V4L2_CID_MPEG_STREAM_PES_ID_AUDIO       (V4L2_CID_MPEG_BASE+5)
#define V4L2_CID_MPEG_STREAM_PES_ID_VIDEO       (V4L2_CID_MPEG_BASE+6)
#define V4L2_CID_MPEG_STREAM_VBI_FMT            (V4L2_CID_MPEG_BASE+7)
enum&nbsp;v4l2_mpeg_stream_vbi_fmt {
        V4L2_MPEG_STREAM_VBI_FMT_NONE = 0,  /* No VBI in the MPEG stream */
        V4L2_MPEG_STREAM_VBI_FMT_IVTV = 1,  /* VBI in private packets, IVTV format */
};

/*  MPEG audio */
#define V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ       (V4L2_CID_MPEG_BASE+100)
enum&nbsp;v4l2_mpeg_audio_sampling_freq {
        V4L2_MPEG_AUDIO_SAMPLING_FREQ_44100 = 0,
        V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000 = 1,
        V4L2_MPEG_AUDIO_SAMPLING_FREQ_32000 = 2,
};
#define V4L2_CID_MPEG_AUDIO_ENCODING            (V4L2_CID_MPEG_BASE+101)
enum&nbsp;v4l2_mpeg_audio_encoding {
        V4L2_MPEG_AUDIO_ENCODING_LAYER_1 = 0,
        V4L2_MPEG_AUDIO_ENCODING_LAYER_2 = 1,
        V4L2_MPEG_AUDIO_ENCODING_LAYER_3 = 2,
};
#define V4L2_CID_MPEG_AUDIO_L1_BITRATE          (V4L2_CID_MPEG_BASE+102)
enum&nbsp;v4l2_mpeg_audio_l1_bitrate {
        V4L2_MPEG_AUDIO_L1_BITRATE_32K  = 0,
        V4L2_MPEG_AUDIO_L1_BITRATE_64K  = 1,
        V4L2_MPEG_AUDIO_L1_BITRATE_96K  = 2,
        V4L2_MPEG_AUDIO_L1_BITRATE_128K = 3,
        V4L2_MPEG_AUDIO_L1_BITRATE_160K = 4,
        V4L2_MPEG_AUDIO_L1_BITRATE_192K = 5,
        V4L2_MPEG_AUDIO_L1_BITRATE_224K = 6,
        V4L2_MPEG_AUDIO_L1_BITRATE_256K = 7,
        V4L2_MPEG_AUDIO_L1_BITRATE_288K = 8,
        V4L2_MPEG_AUDIO_L1_BITRATE_320K = 9,
        V4L2_MPEG_AUDIO_L1_BITRATE_352K = 10,
        V4L2_MPEG_AUDIO_L1_BITRATE_384K = 11,
        V4L2_MPEG_AUDIO_L1_BITRATE_416K = 12,
        V4L2_MPEG_AUDIO_L1_BITRATE_448K = 13,
};
#define V4L2_CID_MPEG_AUDIO_L2_BITRATE          (V4L2_CID_MPEG_BASE+103)
enum&nbsp;v4l2_mpeg_audio_l2_bitrate {
        V4L2_MPEG_AUDIO_L2_BITRATE_32K  = 0,
        V4L2_MPEG_AUDIO_L2_BITRATE_48K  = 1,
        V4L2_MPEG_AUDIO_L2_BITRATE_56K  = 2,
        V4L2_MPEG_AUDIO_L2_BITRATE_64K  = 3,
        V4L2_MPEG_AUDIO_L2_BITRATE_80K  = 4,
        V4L2_MPEG_AUDIO_L2_BITRATE_96K  = 5,
        V4L2_MPEG_AUDIO_L2_BITRATE_112K = 6,
        V4L2_MPEG_AUDIO_L2_BITRATE_128K = 7,
        V4L2_MPEG_AUDIO_L2_BITRATE_160K = 8,
        V4L2_MPEG_AUDIO_L2_BITRATE_192K = 9,
        V4L2_MPEG_AUDIO_L2_BITRATE_224K = 10,
        V4L2_MPEG_AUDIO_L2_BITRATE_256K = 11,
        V4L2_MPEG_AUDIO_L2_BITRATE_320K = 12,
        V4L2_MPEG_AUDIO_L2_BITRATE_384K = 13,
};
#define V4L2_CID_MPEG_AUDIO_L3_BITRATE          (V4L2_CID_MPEG_BASE+104)
enum&nbsp;v4l2_mpeg_audio_l3_bitrate {
        V4L2_MPEG_AUDIO_L3_BITRATE_32K  = 0,
        V4L2_MPEG_AUDIO_L3_BITRATE_40K  = 1,
        V4L2_MPEG_AUDIO_L3_BITRATE_48K  = 2,
        V4L2_MPEG_AUDIO_L3_BITRATE_56K  = 3,
        V4L2_MPEG_AUDIO_L3_BITRATE_64K  = 4,
        V4L2_MPEG_AUDIO_L3_BITRATE_80K  = 5,
        V4L2_MPEG_AUDIO_L3_BITRATE_96K  = 6,
        V4L2_MPEG_AUDIO_L3_BITRATE_112K = 7,
        V4L2_MPEG_AUDIO_L3_BITRATE_128K = 8,
        V4L2_MPEG_AUDIO_L3_BITRATE_160K = 9,
        V4L2_MPEG_AUDIO_L3_BITRATE_192K = 10,
        V4L2_MPEG_AUDIO_L3_BITRATE_224K = 11,
        V4L2_MPEG_AUDIO_L3_BITRATE_256K = 12,
        V4L2_MPEG_AUDIO_L3_BITRATE_320K = 13,
};
#define V4L2_CID_MPEG_AUDIO_MODE                (V4L2_CID_MPEG_BASE+105)
enum&nbsp;v4l2_mpeg_audio_mode {
        V4L2_MPEG_AUDIO_MODE_STEREO       = 0,
        V4L2_MPEG_AUDIO_MODE_JOINT_STEREO = 1,
        V4L2_MPEG_AUDIO_MODE_DUAL         = 2,
        V4L2_MPEG_AUDIO_MODE_MONO         = 3,
};
#define V4L2_CID_MPEG_AUDIO_MODE_EXTENSION      (V4L2_CID_MPEG_BASE+106)
enum&nbsp;&nbsp;v4l2_mpeg_audio_mode_extension {
        V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_4  = 0,
        V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_8  = 1,
        V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_12 = 2,
        V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_16 = 3,
};
#define V4L2_CID_MPEG_AUDIO_EMPHASIS            (V4L2_CID_MPEG_BASE+107)
enum&nbsp;v4l2_mpeg_audio_emphasis {
        V4L2_MPEG_AUDIO_EMPHASIS_NONE         = 0,
        V4L2_MPEG_AUDIO_EMPHASIS_50_DIV_15_uS = 1,
        V4L2_MPEG_AUDIO_EMPHASIS_CCITT_J17    = 2,
};
#define V4L2_CID_MPEG_AUDIO_CRC                 (V4L2_CID_MPEG_BASE+108)
enum&nbsp;v4l2_mpeg_audio_crc {
        V4L2_MPEG_AUDIO_CRC_NONE  = 0,
        V4L2_MPEG_AUDIO_CRC_CRC16 = 1,
};
#define V4L2_CID_MPEG_AUDIO_MUTE                (V4L2_CID_MPEG_BASE+109)

/*  MPEG video */
#define V4L2_CID_MPEG_VIDEO_ENCODING            (V4L2_CID_MPEG_BASE+200)
enum&nbsp;v4l2_mpeg_video_encoding {
        V4L2_MPEG_VIDEO_ENCODING_MPEG_1 = 0,
        V4L2_MPEG_VIDEO_ENCODING_MPEG_2 = 1,
};
#define V4L2_CID_MPEG_VIDEO_ASPECT              (V4L2_CID_MPEG_BASE+201)
enum&nbsp;v4l2_mpeg_video_aspect {
        V4L2_MPEG_VIDEO_ASPECT_1x1     = 0,
        V4L2_MPEG_VIDEO_ASPECT_4x3     = 1,
        V4L2_MPEG_VIDEO_ASPECT_16x9    = 2,
        V4L2_MPEG_VIDEO_ASPECT_221x100 = 3,
};
#define V4L2_CID_MPEG_VIDEO_B_FRAMES            (V4L2_CID_MPEG_BASE+202)
#define V4L2_CID_MPEG_VIDEO_GOP_SIZE            (V4L2_CID_MPEG_BASE+203)
#define V4L2_CID_MPEG_VIDEO_GOP_CLOSURE         (V4L2_CID_MPEG_BASE+204)
#define V4L2_CID_MPEG_VIDEO_PULLDOWN            (V4L2_CID_MPEG_BASE+205)
#define V4L2_CID_MPEG_VIDEO_BITRATE_MODE        (V4L2_CID_MPEG_BASE+206)
enum&nbsp;v4l2_mpeg_video_bitrate_mode {
        V4L2_MPEG_VIDEO_BITRATE_MODE_VBR = 0,
        V4L2_MPEG_VIDEO_BITRATE_MODE_CBR = 1,
};
#define V4L2_CID_MPEG_VIDEO_BITRATE             (V4L2_CID_MPEG_BASE+207)
#define V4L2_CID_MPEG_VIDEO_BITRATE_PEAK        (V4L2_CID_MPEG_BASE+208)
#define V4L2_CID_MPEG_VIDEO_TEMPORAL_DECIMATION (V4L2_CID_MPEG_BASE+209)
#define V4L2_CID_MPEG_VIDEO_MUTE                (V4L2_CID_MPEG_BASE+210)
#define V4L2_CID_MPEG_VIDEO_MUTE_YUV            (V4L2_CID_MPEG_BASE+211)

/*  MPEG-class control IDs specific to the CX2584x driver as defined by V4L2 */
#define V4L2_CID_MPEG_CX2341X_BASE                              (V4L2_CTRL_CLASS_MPEG | 0x1000)
#define V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE         (V4L2_CID_MPEG_CX2341X_BASE+0)
enum&nbsp;v4l2_mpeg_cx2341x_video_spatial_filter_mode {
        V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_MANUAL = 0,
        V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_AUTO   = 1,
};
#define V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER              (V4L2_CID_MPEG_CX2341X_BASE+1)
#define V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE    (V4L2_CID_MPEG_CX2341X_BASE+2)
enum&nbsp;v4l2_mpeg_cx2341x_video_luma_spatial_filter_type {
        V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_OFF                  = 0,
        V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_HOR               = 1,
        V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_VERT              = 2,
        V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_HV_SEPARABLE      = 3,
        V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_SYM_NON_SEPARABLE = 4,
};
#define V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE  (V4L2_CID_MPEG_CX2341X_BASE+3)
enum&nbsp;v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type {
        V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_OFF    = 0,
        V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_1D_HOR = 1,
};
#define V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE        (V4L2_CID_MPEG_CX2341X_BASE+4)
enum&nbsp;v4l2_mpeg_cx2341x_video_temporal_filter_mode {
        V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_MANUAL = 0,
        V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_AUTO   = 1,
};
#define V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER             (V4L2_CID_MPEG_CX2341X_BASE+5)
#define V4L2_CID_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE          (V4L2_CID_MPEG_CX2341X_BASE+6)
enum&nbsp;v4l2_mpeg_cx2341x_video_median_filter_type {
        V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_OFF      = 0,
        V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR      = 1,
        V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_VERT     = 2,
        V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR_VERT = 3,
        V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_DIAG     = 4,
};
#define V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_BOTTOM   (V4L2_CID_MPEG_CX2341X_BASE+7)
#define V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_TOP      (V4L2_CID_MPEG_CX2341X_BASE+8)
#define V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_BOTTOM (V4L2_CID_MPEG_CX2341X_BASE+9)
#define V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_TOP    (V4L2_CID_MPEG_CX2341X_BASE+10)
#define V4L2_CID_MPEG_CX2341X_STREAM_INSERT_NAV_PACKETS         (V4L2_CID_MPEG_CX2341X_BASE+11)

/*  Camera class control IDs */
#define V4L2_CID_CAMERA_CLASS_BASE      (V4L2_CTRL_CLASS_CAMERA | 0x900)
#define V4L2_CID_CAMERA_CLASS           (V4L2_CTRL_CLASS_CAMERA | 1)

#define V4L2_CID_EXPOSURE_AUTO                  (V4L2_CID_CAMERA_CLASS_BASE+1)
enum&nbsp;v4l2_exposure_auto_type {
        V4L2_EXPOSURE_AUTO = 0,
        V4L2_EXPOSURE_MANUAL = 1,
        V4L2_EXPOSURE_SHUTTER_PRIORITY = 2,
        V4L2_EXPOSURE_APERTURE_PRIORITY = 3
};
#define V4L2_CID_EXPOSURE_ABSOLUTE              (V4L2_CID_CAMERA_CLASS_BASE+2)
#define V4L2_CID_EXPOSURE_AUTO_PRIORITY         (V4L2_CID_CAMERA_CLASS_BASE+3)

#define V4L2_CID_PAN_RELATIVE                   (V4L2_CID_CAMERA_CLASS_BASE+4)
#define V4L2_CID_TILT_RELATIVE                  (V4L2_CID_CAMERA_CLASS_BASE+5)
#define V4L2_CID_PAN_RESET                      (V4L2_CID_CAMERA_CLASS_BASE+6)
#define V4L2_CID_TILT_RESET                     (V4L2_CID_CAMERA_CLASS_BASE+7)

#define V4L2_CID_PAN_ABSOLUTE                   (V4L2_CID_CAMERA_CLASS_BASE+8)
#define V4L2_CID_TILT_ABSOLUTE                  (V4L2_CID_CAMERA_CLASS_BASE+9)

#define V4L2_CID_FOCUS_ABSOLUTE                 (V4L2_CID_CAMERA_CLASS_BASE+10)
#define V4L2_CID_FOCUS_RELATIVE                 (V4L2_CID_CAMERA_CLASS_BASE+11)
#define V4L2_CID_FOCUS_AUTO                     (V4L2_CID_CAMERA_CLASS_BASE+12)

/*
 *      T U N I N G
 */
struct <a href="#V4L2-TUNER">v4l2_tuner</a>
{
        __u32                   index;
        __u8                    name[32];
        enum <a href="#V4L2-TUNER-TYPE">v4l2_tuner_type</a>    type;
        __u32                   capability;
        __u32                   rangelow;
        __u32                   rangehigh;
        __u32                   rxsubchans;
        __u32                   audmode;
        __s32                   signal;
        __s32                   afc;
        __u32                   reserved[4];
};

struct <a href="#V4L2-MODULATOR">v4l2_modulator</a>
{
        __u32                   index;
        __u8                    name[32];
        __u32                   capability;
        __u32                   rangelow;
        __u32                   rangehigh;
        __u32                   txsubchans;
        __u32                   reserved[4];
};

/*  Flags for the 'capability' field */
#define V4L2_TUNER_CAP_LOW              0x0001
#define V4L2_TUNER_CAP_NORM             0x0002
#define V4L2_TUNER_CAP_STEREO           0x0010
#define V4L2_TUNER_CAP_LANG2            0x0020
#define V4L2_TUNER_CAP_SAP              0x0020
#define V4L2_TUNER_CAP_LANG1            0x0040

/*  Flags for the 'rxsubchans' field */
#define V4L2_TUNER_SUB_MONO             0x0001
#define V4L2_TUNER_SUB_STEREO           0x0002
#define V4L2_TUNER_SUB_LANG2            0x0004
#define V4L2_TUNER_SUB_SAP              0x0004
#define V4L2_TUNER_SUB_LANG1            0x0008

/*  Values for the 'audmode' field */
#define V4L2_TUNER_MODE_MONO            0x0000
#define V4L2_TUNER_MODE_STEREO          0x0001
#define V4L2_TUNER_MODE_LANG2           0x0002
#define V4L2_TUNER_MODE_SAP             0x0002
#define V4L2_TUNER_MODE_LANG1           0x0003
#define V4L2_TUNER_MODE_LANG1_LANG2     0x0004

struct <a href="#V4L2-FREQUENCY">v4l2_frequency</a>
{
        __u32                 tuner;
        enum <a href="#V4L2-TUNER-TYPE">v4l2_tuner_type</a>  type;
        __u32                 frequency;
        __u32                 reserved[8];
};

/*
 *      A U D I O
 */
struct <a href="#V4L2-AUDIO">v4l2_audio</a>
{
        __u32   index;
        __u8    name[32];
        __u32   capability;
        __u32   mode;
        __u32   reserved[2];
};

/*  Flags for the 'capability' field */
#define V4L2_AUDCAP_STEREO              0x00001
#define V4L2_AUDCAP_AVL                 0x00002

/*  Flags for the 'mode' field */
#define V4L2_AUDMODE_AVL                0x00001

struct <a href="#V4L2-AUDIOOUT">v4l2_audioout</a>
{
        __u32   index;
        __u8    name[32];
        __u32   capability;
        __u32   mode;
        __u32   reserved[2];
};

/*
 *      M P E G   S E R V I C E S
 *
 *      NOTE: EXPERIMENTAL API
 */
#if 1 /*KEEP*/
#define V4L2_ENC_IDX_FRAME_I    (0)
#define V4L2_ENC_IDX_FRAME_P    (1)
#define V4L2_ENC_IDX_FRAME_B    (2)
#define V4L2_ENC_IDX_FRAME_MASK (0xf)

struct <a href="#V4L2-ENC-IDX-ENTRY">v4l2_enc_idx_entry</a> {
        __u64 offset;
        __u64 pts;
        __u32 length;
        __u32 flags;
        __u32 reserved[2];
};

#define V4L2_ENC_IDX_ENTRIES (64)
struct <a href="#V4L2-ENC-IDX">v4l2_enc_idx</a> {
        __u32 entries;
        __u32 entries_cap;
        __u32 reserved[4];
        struct <a href="#V4L2-ENC-IDX-ENTRY">v4l2_enc_idx_entry</a> entry[V4L2_ENC_IDX_ENTRIES];
};


#define V4L2_ENC_CMD_START      (0)
#define V4L2_ENC_CMD_STOP       (1)
#define V4L2_ENC_CMD_PAUSE      (2)
#define V4L2_ENC_CMD_RESUME     (3)

/* Flags for V4L2_ENC_CMD_STOP */
#define V4L2_ENC_CMD_STOP_AT_GOP_END    (1 &lt;&lt; 0)

struct <a href="#V4L2-ENCODER-CMD">v4l2_encoder_cmd</a> {
        __u32 cmd;
        __u32 flags;
        union {
                struct {
                        __u32 data[8];
                } raw;
        };
};

#endif


/*
 *      D A T A   S E R V I C E S   ( V B I )
 *
 *      Data services API by Michael Schimek
 */

/* Raw VBI */
struct <a href="#V4L2-VBI-FORMAT">v4l2_vbi_format</a>
{
        __u32   sampling_rate;          /* in 1 Hz */
        __u32   offset;
        __u32   samples_per_line;
        __u32   sample_format;          /* V4L2_PIX_FMT_* */
        __s32   start[2];
        __u32   count[2];
        __u32   flags;                  /* V4L2_VBI_* */
        __u32   reserved[2];            /* must be zero */
};

/*  VBI flags  */
#define V4L2_VBI_UNSYNC         (1&lt;&lt; 0)
#define V4L2_VBI_INTERLACED     (1&lt;&lt; 1)

/* Sliced VBI
 *
 *    This implements is a proposal V4L2 API to allow SLICED VBI
 * required for some hardware encoders. It should change without
 * notice in the definitive implementation.
 */

struct <a href="#V4L2-SLICED-VBI-FORMAT">v4l2_sliced_vbi_format</a>
{
        __u16   service_set;
        /* service_lines[0][...] specifies lines 0-23 (1-23 used) of the first field
           service_lines[1][...] specifies lines 0-23 (1-23 used) of the second field
                                 (equals frame lines 313-336 for 625 line video
                                  standards, 263-286 for 525 line standards) */
        __u16   service_lines[2][24];
        __u32   io_size;
        __u32   reserved[2];            /* must be zero */
};

/* Teletext World System Teletext
   (WST), defined on ITU-R BT.653-2 */
#define V4L2_SLICED_TELETEXT_B          (0x0001)
/* Video Program System, defined on ETS 300 231*/
#define V4L2_SLICED_VPS                 (0x0400)
/* Closed Caption, defined on EIA-608 */
#define V4L2_SLICED_CAPTION_525         (0x1000)
/* Wide Screen System, defined on ITU-R BT1119.1 */
#define V4L2_SLICED_WSS_625             (0x4000)

#define V4L2_SLICED_VBI_525             (V4L2_SLICED_CAPTION_525)
#define V4L2_SLICED_VBI_625             (V4L2_SLICED_TELETEXT_B | V4L2_SLICED_VPS | V4L2_SLICED_WSS_625)

struct <a href="#V4L2-SLICED-VBI-CAP">v4l2_sliced_vbi_cap</a>
{
        __u16   service_set;
        /* service_lines[0][...] specifies lines 0-23 (1-23 used) of the first field
           service_lines[1][...] specifies lines 0-23 (1-23 used) of the second field
                                 (equals frame lines 313-336 for 625 line video
                                  standards, 263-286 for 525 line standards) */
        __u16   service_lines[2][24];
        enum <a href="#V4L2-BUF-TYPE">v4l2_buf_type</a> type;
        __u32   reserved[3];    /* must be 0 */
};

struct <a href="#V4L2-SLICED-VBI-DATA">v4l2_sliced_vbi_data</a>
{
        __u32   id;
        __u32   field;          /* 0: first field, 1: second field */
        __u32   line;           /* 1-23 */
        __u32   reserved;       /* must be 0 */
        __u8    data[48];
};

/*
 *      A G G R E G A T E   S T R U C T U R E S
 */

/*      Stream data format
 */
struct <a href="#V4L2-FORMAT">v4l2_format</a>
{
        enum <a href="#V4L2-BUF-TYPE">v4l2_buf_type</a> type;
        union
        {
                struct <a href="#V4L2-PIX-FORMAT">v4l2_pix_format</a>          pix;     // V4L2_BUF_TYPE_VIDEO_CAPTURE
                struct <a href="#V4L2-WINDOW">v4l2_window</a>              win;     // V4L2_BUF_TYPE_VIDEO_OVERLAY
                struct <a href="#V4L2-VBI-FORMAT">v4l2_vbi_format</a>          vbi;     // V4L2_BUF_TYPE_VBI_CAPTURE
                struct <a href="#V4L2-SLICED-VBI-FORMAT">v4l2_sliced_vbi_format</a>   sliced;  // V4L2_BUF_TYPE_SLICED_VBI_CAPTURE
                __u8    raw_data[200];                   // user-defined
        } fmt;
};


/*      Stream type-dependent parameters
 */
struct <a href="#V4L2-STREAMPARM">v4l2_streamparm</a>
{
        enum <a href="#V4L2-BUF-TYPE">v4l2_buf_type</a> type;
        union
        {
                struct <a href="#V4L2-CAPTUREPARM">v4l2_captureparm</a> capture;
                struct <a href="#V4L2-OUTPUTPARM">v4l2_outputparm</a>  output;
                __u8    raw_data[200];  /* user-defined */
        } parm;
};

/*
 *      A D V A N C E D   D E B U G G I N G
 *
 *      NOTE: EXPERIMENTAL API
 */

/* VIDIOC_DBG_G_REGISTER and VIDIOC_DBG_S_REGISTER */

#define V4L2_CHIP_MATCH_HOST       0  /* Match against chip ID on host (0 for the host) */
#define V4L2_CHIP_MATCH_I2C_DRIVER 1  /* Match against I2C driver ID */
#define V4L2_CHIP_MATCH_I2C_ADDR   2  /* Match against I2C 7-bit address */

struct <a href="#V4L2-REGISTER">v4l2_register</a> {
        __u32 match_type; /* Match type */
        __u32 match_chip; /* Match this chip, meaning determined by match_type */
        __u64 reg;
        __u64 val;
};

/* VIDIOC_G_CHIP_IDENT */
struct <a href="#V4L2-CHIP-IDENT">v4l2_chip_ident</a> {
        __u32 match_type;  /* Match type */
        __u32 match_chip;  /* Match this chip, meaning determined by match_type */
        __u32 ident;       /* chip identifier as specified in &lt;media/v4l2-chip-ident.h&gt; */
        __u32 revision;    /* chip revision, chip specific */
};

/*
 *      I O C T L   C O D E S   F O R   V I D E O   D E V I C E S
 *
 */
#define VIDIOC_QUERYCAP         _IOR  ('V',  0, struct <a href="#V4L2-CAPABILITY">v4l2_capability</a>)
#define VIDIOC_RESERVED         _IO   ('V',  1)
#define VIDIOC_ENUM_FMT         _IOWR ('V',  2, struct <a href="#V4L2-FMTDESC">v4l2_fmtdesc</a>)
#define VIDIOC_G_FMT            _IOWR ('V',  4, struct <a href="#V4L2-FORMAT">v4l2_format</a>)
#define VIDIOC_S_FMT            _IOWR ('V',  5, struct <a href="#V4L2-FORMAT">v4l2_format</a>)
#define VIDIOC_REQBUFS          _IOWR ('V',  8, struct <a href="#V4L2-REQUESTBUFFERS">v4l2_requestbuffers</a>)
#define VIDIOC_QUERYBUF         _IOWR ('V',  9, struct <a href="#V4L2-BUFFER">v4l2_buffer</a>)
#define VIDIOC_G_FBUF           _IOR  ('V', 10, struct <a href="#V4L2-FRAMEBUFFER">v4l2_framebuffer</a>)
#define VIDIOC_S_FBUF           _IOW  ('V', 11, struct <a href="#V4L2-FRAMEBUFFER">v4l2_framebuffer</a>)
#define VIDIOC_OVERLAY          _IOW  ('V', 14, int)
#define VIDIOC_QBUF             _IOWR ('V', 15, struct <a href="#V4L2-BUFFER">v4l2_buffer</a>)
#define VIDIOC_DQBUF            _IOWR ('V', 17, struct <a href="#V4L2-BUFFER">v4l2_buffer</a>)
#define VIDIOC_STREAMON         _IOW  ('V', 18, int)
#define VIDIOC_STREAMOFF        _IOW  ('V', 19, int)
#define VIDIOC_G_PARM           _IOWR ('V', 21, struct <a href="#V4L2-STREAMPARM">v4l2_streamparm</a>)
#define VIDIOC_S_PARM           _IOWR ('V', 22, struct <a href="#V4L2-STREAMPARM">v4l2_streamparm</a>)
#define VIDIOC_G_STD            _IOR  ('V', 23, v4l2_std_id)
#define VIDIOC_S_STD            _IOW  ('V', 24, v4l2_std_id)
#define VIDIOC_ENUMSTD          _IOWR ('V', 25, struct <a href="#V4L2-STANDARD">v4l2_standard</a>)
#define VIDIOC_ENUMINPUT        _IOWR ('V', 26, struct <a href="#V4L2-INPUT">v4l2_input</a>)
#define VIDIOC_G_CTRL           _IOWR ('V', 27, struct <a href="#V4L2-CONTROL">v4l2_control</a>)
#define VIDIOC_S_CTRL           _IOWR ('V', 28, struct <a href="#V4L2-CONTROL">v4l2_control</a>)
#define VIDIOC_G_TUNER          _IOWR ('V', 29, struct <a href="#V4L2-TUNER">v4l2_tuner</a>)
#define VIDIOC_S_TUNER          _IOW  ('V', 30, struct <a href="#V4L2-TUNER">v4l2_tuner</a>)
#define VIDIOC_G_AUDIO          _IOR  ('V', 33, struct <a href="#V4L2-AUDIO">v4l2_audio</a>)
#define VIDIOC_S_AUDIO          _IOW  ('V', 34, struct <a href="#V4L2-AUDIO">v4l2_audio</a>)
#define VIDIOC_QUERYCTRL        _IOWR ('V', 36, struct <a href="#V4L2-QUERYCTRL">v4l2_queryctrl</a>)
#define VIDIOC_QUERYMENU        _IOWR ('V', 37, struct <a href="#V4L2-QUERYMENU">v4l2_querymenu</a>)
#define VIDIOC_G_INPUT          _IOR  ('V', 38, int)
#define VIDIOC_S_INPUT          _IOWR ('V', 39, int)
#define VIDIOC_G_OUTPUT         _IOR  ('V', 46, int)
#define VIDIOC_S_OUTPUT         _IOWR ('V', 47, int)
#define VIDIOC_ENUMOUTPUT       _IOWR ('V', 48, struct <a href="#V4L2-OUTPUT">v4l2_output</a>)
#define VIDIOC_G_AUDOUT         _IOR  ('V', 49, struct <a href="#V4L2-AUDIOOUT">v4l2_audioout</a>)
#define VIDIOC_S_AUDOUT         _IOW  ('V', 50, struct <a href="#V4L2-AUDIOOUT">v4l2_audioout</a>)
#define VIDIOC_G_MODULATOR      _IOWR ('V', 54, struct <a href="#V4L2-MODULATOR">v4l2_modulator</a>)
#define VIDIOC_S_MODULATOR      _IOW  ('V', 55, struct <a href="#V4L2-MODULATOR">v4l2_modulator</a>)
#define VIDIOC_G_FREQUENCY      _IOWR ('V', 56, struct <a href="#V4L2-FREQUENCY">v4l2_frequency</a>)
#define VIDIOC_S_FREQUENCY      _IOW  ('V', 57, struct <a href="#V4L2-FREQUENCY">v4l2_frequency</a>)
#define VIDIOC_CROPCAP          _IOWR ('V', 58, struct <a href="#V4L2-CROPCAP">v4l2_cropcap</a>)
#define VIDIOC_G_CROP           _IOWR ('V', 59, struct <a href="#V4L2-CROP">v4l2_crop</a>)
#define VIDIOC_S_CROP           _IOW  ('V', 60, struct <a href="#V4L2-CROP">v4l2_crop</a>)
#define VIDIOC_G_JPEGCOMP       _IOR  ('V', 61, struct <a href="#V4L2-JPEGCOMPRESSION">v4l2_jpegcompression</a>)
#define VIDIOC_S_JPEGCOMP       _IOW  ('V', 62, struct <a href="#V4L2-JPEGCOMPRESSION">v4l2_jpegcompression</a>)
#define VIDIOC_QUERYSTD         _IOR  ('V', 63, v4l2_std_id)
#define VIDIOC_TRY_FMT          _IOWR ('V', 64, struct <a href="#V4L2-FORMAT">v4l2_format</a>)
#define VIDIOC_ENUMAUDIO        _IOWR ('V', 65, struct <a href="#V4L2-AUDIO">v4l2_audio</a>)
#define VIDIOC_ENUMAUDOUT       _IOWR ('V', 66, struct <a href="#V4L2-AUDIOOUT">v4l2_audioout</a>)
#define VIDIOC_G_PRIORITY       _IOR  ('V', 67, enum <a href="#V4L2-PRIORITY">v4l2_priority</a>)
#define VIDIOC_S_PRIORITY       _IOW  ('V', 68, enum <a href="#V4L2-PRIORITY">v4l2_priority</a>)
#define VIDIOC_G_SLICED_VBI_CAP _IOWR ('V', 69, struct <a href="#V4L2-SLICED-VBI-CAP">v4l2_sliced_vbi_cap</a>)
#define VIDIOC_LOG_STATUS       _IO   ('V', 70)
#define VIDIOC_G_EXT_CTRLS      _IOWR ('V', 71, struct <a href="#V4L2-EXT-CONTROLS">v4l2_ext_controls</a>)
#define VIDIOC_S_EXT_CTRLS      _IOWR ('V', 72, struct <a href="#V4L2-EXT-CONTROLS">v4l2_ext_controls</a>)
#define VIDIOC_TRY_EXT_CTRLS    _IOWR ('V', 73, struct <a href="#V4L2-EXT-CONTROLS">v4l2_ext_controls</a>)
#if 1 /*KEEP*/
#define VIDIOC_ENUM_FRAMESIZES  _IOWR ('V', 74, struct <a href="#V4L2-FRMSIZEENUM">v4l2_frmsizeenum</a>)
#define VIDIOC_ENUM_FRAMEINTERVALS      _IOWR ('V', 75, struct <a href="#V4L2-FRMIVALENUM">v4l2_frmivalenum</a>)
#define VIDIOC_G_ENC_INDEX      _IOR  ('V', 76, struct <a href="#V4L2-ENC-IDX">v4l2_enc_idx</a>)
#define VIDIOC_ENCODER_CMD      _IOWR ('V', 77, struct <a href="#V4L2-ENCODER-CMD">v4l2_encoder_cmd</a>)
#define VIDIOC_TRY_ENCODER_CMD  _IOWR ('V', 78, struct <a href="#V4L2-ENCODER-CMD">v4l2_encoder_cmd</a>)

/* Experimental, only implemented if CONFIG_VIDEO_ADV_DEBUG is defined */
#define VIDIOC_DBG_S_REGISTER   _IOW  ('V', 79, struct <a href="#V4L2-REGISTER">v4l2_register</a>)
#define VIDIOC_DBG_G_REGISTER   _IOWR ('V', 80, struct <a href="#V4L2-REGISTER">v4l2_register</a>)

#define VIDIOC_G_CHIP_IDENT     _IOWR ('V', 81, struct <a href="#V4L2-CHIP-IDENT">v4l2_chip_ident</a>)
#endif

#ifdef __OLD_VIDIOC_
/* for compatibility, will go away some day */
#define VIDIOC_OVERLAY_OLD      _IOWR ('V', 14, int)
#define VIDIOC_S_PARM_OLD       _IOW  ('V', 22, struct <a href="#V4L2-STREAMPARM">v4l2_streamparm</a>)
#define VIDIOC_S_CTRL_OLD       _IOW  ('V', 28, struct <a href="#V4L2-CONTROL">v4l2_control</a>)
#define VIDIOC_G_AUDIO_OLD      _IOWR ('V', 33, struct <a href="#V4L2-AUDIO">v4l2_audio</a>)
#define VIDIOC_G_AUDOUT_OLD     _IOWR ('V', 49, struct <a href="#V4L2-AUDIOOUT">v4l2_audioout</a>)
#define VIDIOC_CROPCAP_OLD      _IOR  ('V', 58, struct <a href="#V4L2-CROPCAP">v4l2_cropcap</a>)
#endif

#define BASE_VIDIOC_PRIVATE     192             /* 192-255 are private */

#endif /* __LINUX_VIDEODEV2_H */

/*
 * Local variables:
 * c-basic-offset: 8
 * End:
 */</pre></div><div class="APPENDIX"><hr><h1><a name="CAPTURE-EXAMPLE"></a>Appendix B. Video Capture Example</h1><pre class="PROGRAMLISTING">/*
 *  V4L2 video capture example
 *
 *  This program can be used and distributed without restrictions.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

#include &lt;getopt.h&gt;             /* getopt_long() */

#include &lt;fcntl.h&gt;              /* low-level i/o */
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;malloc.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/ioctl.h&gt;

#include &lt;asm/types.h&gt;          /* for videodev2.h */

#include &lt;linux/videodev2.h&gt;

#define CLEAR(x) memset (&amp;(x), 0, sizeof (x))

typedef enum {
        IO_METHOD_READ,
        IO_METHOD_MMAP,
        IO_METHOD_USERPTR,
} io_method;

struct buffer {
        void *                  start;
        size_t                  length;
};

static char *           dev_name        = NULL;
static io_method        io              = IO_METHOD_MMAP;
static int              fd              = -1;
struct buffer *         buffers         = NULL;
static unsigned int     n_buffers       = 0;

static void
errno_exit                      (const char *           s)
{
        fprintf (stderr, "%s error %d, %s\n",
                 s, errno, strerror (errno));

        exit (EXIT_FAILURE);
}

static int
xioctl                          (int                    fd,
                                 int                    request,
                                 void *                 arg)
{
        int r;

        do r = ioctl (fd, request, arg);
        while (-1 == r &amp;&amp; EINTR == errno);

        return r;
}

static void
process_image                   (const void *           p)
{
        fputc ('.', stdout);
        fflush (stdout);
}

static int
read_frame                      (void)
{
        struct <a href="#V4L2-BUFFER">v4l2_buffer</a> buf;
        unsigned int i;

        switch (io) {
        case IO_METHOD_READ:
                if (-1 == read (fd, buffers[0].start, buffers[0].length)) {
                        switch (errno) {
                        case EAGAIN:
                                return 0;

                        case EIO:
                                /* Could ignore EIO, see spec. */

                                /* fall through */

                        default:
                                errno_exit ("read");
                        }
                }

                process_image (buffers[0].start);

                break;

        case IO_METHOD_MMAP:
                CLEAR (buf);

                buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
                buf.memory = V4L2_MEMORY_MMAP;

                if (-1 == xioctl (fd, VIDIOC_DQBUF, &amp;buf)) {
                        switch (errno) {
                        case EAGAIN:
                                return 0;

                        case EIO:
                                /* Could ignore EIO, see spec. */

                                /* fall through */

                        default:
                                errno_exit ("VIDIOC_DQBUF");
                        }
                }

                assert (buf.index &lt; n_buffers);

                process_image (buffers[buf.index].start);

                if (-1 == xioctl (fd, VIDIOC_QBUF, &amp;buf))
                        errno_exit ("VIDIOC_QBUF");

                break;

        case IO_METHOD_USERPTR:
                CLEAR (buf);

                buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
                buf.memory = V4L2_MEMORY_USERPTR;

                if (-1 == xioctl (fd, VIDIOC_DQBUF, &amp;buf)) {
                        switch (errno) {
                        case EAGAIN:
                                return 0;

                        case EIO:
                                /* Could ignore EIO, see spec. */

                                /* fall through */

                        default:
                                errno_exit ("VIDIOC_DQBUF");
                        }
                }

                for (i = 0; i &lt; n_buffers; ++i)
                        if (buf.m.userptr == (unsigned long) buffers[i].start
                            &amp;&amp; buf.length == buffers[i].length)
                                break;

                assert (i &lt; n_buffers);

                process_image ((void *) buf.m.userptr);

                if (-1 == xioctl (fd, VIDIOC_QBUF, &amp;buf))
                        errno_exit ("VIDIOC_QBUF");

                break;
        }

        return 1;
}

static void
mainloop                        (void)
{
        unsigned int count;

        count = 100;

        while (count-- &gt; 0) {
                for (;;) {
                        fd_set fds;
                        struct timeval tv;
                        int r;

                        FD_ZERO (&amp;fds);
                        FD_SET (fd, &amp;fds);

                        /* Timeout. */
                        tv.tv_sec = 2;
                        tv.tv_usec = 0;

                        r = select (fd + 1, &amp;fds, NULL, NULL, &amp;tv);

                        if (-1 == r) {
                                if (EINTR == errno)
                                        continue;

                                errno_exit ("select");
                        }

                        if (0 == r) {
                                fprintf (stderr, "select timeout\n");
                                exit (EXIT_FAILURE);
                        }

                        if (read_frame ())
                                break;
        
                        /* EAGAIN - continue select loop. */
                }
        }
}

static void
stop_capturing                  (void)
{
        enum <a href="#V4L2-BUF-TYPE">v4l2_buf_type</a> type;

        switch (io) {
        case IO_METHOD_READ:
                /* Nothing to do. */
                break;

        case IO_METHOD_MMAP:
        case IO_METHOD_USERPTR:
                type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

                if (-1 == xioctl (fd, VIDIOC_STREAMOFF, &amp;type))
                        errno_exit ("VIDIOC_STREAMOFF");

                break;
        }
}

static void
start_capturing                 (void)
{
        unsigned int i;
        enum <a href="#V4L2-BUF-TYPE">v4l2_buf_type</a> type;

        switch (io) {
        case IO_METHOD_READ:
                /* Nothing to do. */
                break;

        case IO_METHOD_MMAP:
                for (i = 0; i &lt; n_buffers; ++i) {
                        struct <a href="#V4L2-BUFFER">v4l2_buffer</a> buf;

                        CLEAR (buf);

                        buf.type        = V4L2_BUF_TYPE_VIDEO_CAPTURE;
                        buf.memory      = V4L2_MEMORY_MMAP;
                        buf.index       = i;

                        if (-1 == xioctl (fd, VIDIOC_QBUF, &amp;buf))
                                errno_exit ("VIDIOC_QBUF");
                }
                
                type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

                if (-1 == xioctl (fd, VIDIOC_STREAMON, &amp;type))
                        errno_exit ("VIDIOC_STREAMON");

                break;

        case IO_METHOD_USERPTR:
                for (i = 0; i &lt; n_buffers; ++i) {
                        struct <a href="#V4L2-BUFFER">v4l2_buffer</a> buf;

                        CLEAR (buf);

                        buf.type        = V4L2_BUF_TYPE_VIDEO_CAPTURE;
                        buf.memory      = V4L2_MEMORY_USERPTR;
                        buf.index       = i;
                        buf.m.userptr   = (unsigned long) buffers[i].start;
                        buf.length      = buffers[i].length;

                        if (-1 == xioctl (fd, VIDIOC_QBUF, &amp;buf))
                                errno_exit ("VIDIOC_QBUF");
                }

                type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

                if (-1 == xioctl (fd, VIDIOC_STREAMON, &amp;type))
                        errno_exit ("VIDIOC_STREAMON");

                break;
        }
}

static void
uninit_device                   (void)
{
        unsigned int i;

        switch (io) {
        case IO_METHOD_READ:
                free (buffers[0].start);
                break;

        case IO_METHOD_MMAP:
                for (i = 0; i &lt; n_buffers; ++i)
                        if (-1 == munmap (buffers[i].start, buffers[i].length))
                                errno_exit ("munmap");
                break;

        case IO_METHOD_USERPTR:
                for (i = 0; i &lt; n_buffers; ++i)
                        free (buffers[i].start);
                break;
        }

        free (buffers);
}

static void
init_read                       (unsigned int           buffer_size)
{
        buffers = calloc (1, sizeof (*buffers));

        if (!buffers) {
                fprintf (stderr, "Out of memory\n");
                exit (EXIT_FAILURE);
        }

        buffers[0].length = buffer_size;
        buffers[0].start = malloc (buffer_size);

        if (!buffers[0].start) {
                fprintf (stderr, "Out of memory\n");
                exit (EXIT_FAILURE);
        }
}

static void
init_mmap                       (void)
{
        struct <a href="#V4L2-REQUESTBUFFERS">v4l2_requestbuffers</a> req;

        CLEAR (req);

        req.count               = 4;
        req.type                = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        req.memory              = V4L2_MEMORY_MMAP;

        if (-1 == xioctl (fd, VIDIOC_REQBUFS, &amp;req)) {
                if (EINVAL == errno) {
                        fprintf (stderr, "%s does not support "
                                 "memory mapping\n", dev_name);
                        exit (EXIT_FAILURE);
                } else {
                        errno_exit ("VIDIOC_REQBUFS");
                }
        }

        if (req.count &lt; 2) {
                fprintf (stderr, "Insufficient buffer memory on %s\n",
                         dev_name);
                exit (EXIT_FAILURE);
        }

        buffers = calloc (req.count, sizeof (*buffers));

        if (!buffers) {
                fprintf (stderr, "Out of memory\n");
                exit (EXIT_FAILURE);
        }

        for (n_buffers = 0; n_buffers &lt; req.count; ++n_buffers) {
                struct <a href="#V4L2-BUFFER">v4l2_buffer</a> buf;

                CLEAR (buf);

                buf.type        = V4L2_BUF_TYPE_VIDEO_CAPTURE;
                buf.memory      = V4L2_MEMORY_MMAP;
                buf.index       = n_buffers;

                if (-1 == xioctl (fd, VIDIOC_QUERYBUF, &amp;buf))
                        errno_exit ("VIDIOC_QUERYBUF");

                buffers[n_buffers].length = buf.length;
                buffers[n_buffers].start =
                        mmap (NULL /* start anywhere */,
                              buf.length,
                              PROT_READ | PROT_WRITE /* required */,
                              MAP_SHARED /* recommended */,
                              fd, buf.m.offset);

                if (MAP_FAILED == buffers[n_buffers].start)
                        errno_exit ("mmap");
        }
}

static void
init_userp                      (unsigned int           buffer_size)
{
        struct <a href="#V4L2-REQUESTBUFFERS">v4l2_requestbuffers</a> req;
        unsigned int page_size;

        page_size = getpagesize ();
        buffer_size = (buffer_size + page_size - 1) &amp; ~(page_size - 1);

        CLEAR (req);

        req.count               = 4;
        req.type                = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        req.memory              = V4L2_MEMORY_USERPTR;

        if (-1 == xioctl (fd, VIDIOC_REQBUFS, &amp;req)) {
                if (EINVAL == errno) {
                        fprintf (stderr, "%s does not support "
                                 "user pointer i/o\n", dev_name);
                        exit (EXIT_FAILURE);
                } else {
                        errno_exit ("VIDIOC_REQBUFS");
                }
        }

        buffers = calloc (4, sizeof (*buffers));

        if (!buffers) {
                fprintf (stderr, "Out of memory\n");
                exit (EXIT_FAILURE);
        }

        for (n_buffers = 0; n_buffers &lt; 4; ++n_buffers) {
                buffers[n_buffers].length = buffer_size;
                buffers[n_buffers].start = memalign (/* boundary */ page_size,
                                                     buffer_size);

                if (!buffers[n_buffers].start) {
                        fprintf (stderr, "Out of memory\n");
                        exit (EXIT_FAILURE);
                }
        }
}

static void
init_device                     (void)
{
        struct <a href="#V4L2-CAPABILITY">v4l2_capability</a> cap;
        struct <a href="#V4L2-CROPCAP">v4l2_cropcap</a> cropcap;
        struct <a href="#V4L2-CROP">v4l2_crop</a> crop;
        struct <a href="#V4L2-FORMAT">v4l2_format</a> fmt;
        unsigned int min;

        if (-1 == xioctl (fd, VIDIOC_QUERYCAP, &amp;cap)) {
                if (EINVAL == errno) {
                        fprintf (stderr, "%s is no V4L2 device\n",
                                 dev_name);
                        exit (EXIT_FAILURE);
                } else {
                        errno_exit ("VIDIOC_QUERYCAP");
                }
        }

        if (!(cap.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE)) {
                fprintf (stderr, "%s is no video capture device\n",
                         dev_name);
                exit (EXIT_FAILURE);
        }

        switch (io) {
        case IO_METHOD_READ:
                if (!(cap.capabilities &amp; V4L2_CAP_READWRITE)) {
                        fprintf (stderr, "%s does not support read i/o\n",
                                 dev_name);
                        exit (EXIT_FAILURE);
                }

                break;

        case IO_METHOD_MMAP:
        case IO_METHOD_USERPTR:
                if (!(cap.capabilities &amp; V4L2_CAP_STREAMING)) {
                        fprintf (stderr, "%s does not support streaming i/o\n",
                                 dev_name);
                        exit (EXIT_FAILURE);
                }

                break;
        }


        /* Select video input, video standard and tune here. */


        CLEAR (cropcap);

        cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

        if (0 == xioctl (fd, VIDIOC_CROPCAP, &amp;cropcap)) {
                crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
                crop.c = cropcap.defrect; /* reset to default */

                if (-1 == xioctl (fd, VIDIOC_S_CROP, &amp;crop)) {
                        switch (errno) {
                        case EINVAL:
                                /* Cropping not supported. */
                                break;
                        default:
                                /* Errors ignored. */
                                break;
                        }
                }
        } else {        
                /* Errors ignored. */
        }


        CLEAR (fmt);

        fmt.type                = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        fmt.fmt.pix.width       = 640; 
        fmt.fmt.pix.height      = 480;
        fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;
        fmt.fmt.pix.field       = V4L2_FIELD_INTERLACED;

        if (-1 == xioctl (fd, VIDIOC_S_FMT, &amp;fmt))
                errno_exit ("VIDIOC_S_FMT");

        /* Note VIDIOC_S_FMT may change width and height. */

        /* Buggy driver paranoia. */
        min = fmt.fmt.pix.width * 2;
        if (fmt.fmt.pix.bytesperline &lt; min)
                fmt.fmt.pix.bytesperline = min;
        min = fmt.fmt.pix.bytesperline * fmt.fmt.pix.height;
        if (fmt.fmt.pix.sizeimage &lt; min)
                fmt.fmt.pix.sizeimage = min;

        switch (io) {
        case IO_METHOD_READ:
                init_read (fmt.fmt.pix.sizeimage);
                break;

        case IO_METHOD_MMAP:
                init_mmap ();
                break;

        case IO_METHOD_USERPTR:
                init_userp (fmt.fmt.pix.sizeimage);
                break;
        }
}

static void
close_device                    (void)
{
        if (-1 == close (fd))
                errno_exit ("close");

        fd = -1;
}

static void
open_device                     (void)
{
        struct stat st; 

        if (-1 == stat (dev_name, &amp;st)) {
                fprintf (stderr, "Cannot identify '%s': %d, %s\n",
                         dev_name, errno, strerror (errno));
                exit (EXIT_FAILURE);
        }

        if (!S_ISCHR (st.st_mode)) {
                fprintf (stderr, "%s is no device\n", dev_name);
                exit (EXIT_FAILURE);
        }

        fd = open (dev_name, O_RDWR /* required */ | O_NONBLOCK, 0);

        if (-1 == fd) {
                fprintf (stderr, "Cannot open '%s': %d, %s\n",
                         dev_name, errno, strerror (errno));
                exit (EXIT_FAILURE);
        }
}

static void
usage                           (FILE *                 fp,
                                 int                    argc,
                                 char **                argv)
{
        fprintf (fp,
                 "Usage: %s [options]\n\n"
                 "Options:\n"
                 "-d | --device name   Video device name [/dev/video]\n"
                 "-h | --help          Print this message\n"
                 "-m | --mmap          Use memory mapped buffers\n"
                 "-r | --read          Use read() calls\n"
                 "-u | --userp         Use application allocated buffers\n"
                 "",
                 argv[0]);
}

static const char short_options [] = "d:hmru";

static const struct option
long_options [] = {
        { "device",     required_argument,      NULL,           'd' },
        { "help",       no_argument,            NULL,           'h' },
        { "mmap",       no_argument,            NULL,           'm' },
        { "read",       no_argument,            NULL,           'r' },
        { "userp",      no_argument,            NULL,           'u' },
        { 0, 0, 0, 0 }
};

int
main                            (int                    argc,
                                 char **                argv)
{
        dev_name = "/dev/video";

        for (;;) {
                int index;
                int c;
                
                c = getopt_long (argc, argv,
                                 short_options, long_options,
                                 &amp;index);

                if (-1 == c)
                        break;

                switch (c) {
                case 0: /* getopt_long() flag */
                        break;

                case 'd':
                        dev_name = optarg;
                        break;

                case 'h':
                        usage (stdout, argc, argv);
                        exit (EXIT_SUCCESS);

                case 'm':
                        io = IO_METHOD_MMAP;
                        break;

                case 'r':
                        io = IO_METHOD_READ;
                        break;

                case 'u':
                        io = IO_METHOD_USERPTR;
                        break;

                default:
                        usage (stderr, argc, argv);
                        exit (EXIT_FAILURE);
                }
        }

        open_device ();

        init_device ();

        start_capturing ();

        mainloop ();

        stop_capturing ();

        uninit_device ();

        close_device ();

        exit (EXIT_SUCCESS);

        return 0;
}</pre></div><div class="APPENDIX"><hr><h1><a name="FDL"></a>Appendix C. GNU Free Documentation License</h1><div class="SECT1"><h2 class="SECT1"><a name="FDL-PREAMBLE">C.1. 0. PREAMBLE</a></h2><p>      The purpose of this License is to make a manual, textbook, or
      other written document <span class="QUOTE">"free"</span> in the sense of
      freedom: to assure everyone the effective freedom to copy and
      redistribute it, with or without modifying it, either
      commercially or noncommercially. Secondarily, this License
      preserves for the author and publisher a way to get credit for
      their work, while not being considered responsible for
      modifications made by others.
    </p><p>      This License is a kind of <span class="QUOTE">"copyleft"</span>, which means
      that derivative works of the document must themselves be free in
      the same sense. It complements the GNU General Public License,
      which is a copyleft license designed for free software.
    </p><p>      We have designed this License in order to use it for manuals for
      free software, because free software needs free documentation: a
      free program should come with manuals providing the same
      freedoms that the software does. But this License is not limited
      to software manuals; it can be used for any textual work,
      regardless of subject matter or whether it is published as a
      printed book. We recommend this License principally for works
      whose purpose is instruction or reference.
    </p></div><div class="SECT1"><hr><h2 class="SECT1"><a name="FDL-SECTION1">C.2. 1. APPLICABILITY AND DEFINITIONS</a></h2><p>      This License applies to any manual or other work that contains a
      notice placed by the copyright holder saying it can be
      distributed under the terms of this License. The
      <span class="QUOTE">"Document"</span>, below, refers to any such manual or
      work. Any member of the public is a licensee, and is addressed
      as <span class="QUOTE">"you"</span>.
    </p><p>      A <span class="QUOTE">"Modified Version"</span> of the Document means any work
      containing the Document or a portion of it, either copied
      verbatim, or with modifications and/or translated into another
      language.
    </p><p>      A <span class="QUOTE">"Secondary Section"</span> is a named appendix or a
      front-matter section of the <a href="#FDL-DOCUMENT">Document</a> that deals exclusively
      with the relationship of the publishers or authors of the
      Document to the Document's overall subject (or to related
      matters) and contains nothing that could fall directly within
      that overall subject. (For example, if the Document is in part a
      textbook of mathematics, a Secondary Section may not explain any
      mathematics.)  The relationship could be a matter of historical
      connection with the subject or with related matters, or of
      legal, commercial, philosophical, ethical or political position
      regarding them.
    </p><p>      The <span class="QUOTE">"Invariant Sections"</span> are certain <a href="#FDL-SECONDARY"> Secondary Sections</a> whose titles
      are designated, as being those of Invariant Sections, in the
      notice that says that the <a href="#FDL-DOCUMENT">Document</a> is released under this
      License.
    </p><p>      The <span class="QUOTE">"Cover Texts"</span> are certain short passages of
      text that are listed, as Front-Cover Texts or Back-Cover Texts,
      in the notice that says that the <a href="#FDL-DOCUMENT">Document</a> is released under this
      License.
    </p><p>      A <span class="QUOTE">"Transparent"</span> copy of the <a href="#FDL-DOCUMENT"> Document</a> means a machine-readable
      copy, represented in a format whose specification is available
      to the general public, whose contents can be viewed and edited
      directly and straightforwardly with generic text editors or (for
      images composed of pixels) generic paint programs or (for
      drawings) some widely available drawing editor, and that is
      suitable for input to text formatters or for automatic
      translation to a variety of formats suitable for input to text
      formatters. A copy made in an otherwise Transparent file format
      whose markup has been designed to thwart or discourage
      subsequent modification by readers is not Transparent.  A copy
      that is not <span class="QUOTE">"Transparent"</span> is called
      <span class="QUOTE">"Opaque"</span>.
    </p><p>      Examples of suitable formats for Transparent copies include
      plain ASCII without markup, Texinfo input format, LaTeX input
      format, SGML or XML using a publicly available DTD, and
      standard-conforming simple HTML designed for human
      modification. Opaque formats include PostScript, PDF,
      proprietary formats that can be read and edited only by
      proprietary word processors, SGML or XML for which the DTD
      and/or processing tools are not generally available, and the
      machine-generated HTML produced by some word processors for
      output purposes only.
    </p><p>      The <span class="QUOTE">"Title Page"</span> means, for a printed book, the
      title page itself, plus such following pages as are needed to
      hold, legibly, the material this License requires to appear in
      the title page. For works in formats which do not have any title
      page as such, <span class="QUOTE">"Title Page"</span> means the text near the
      most prominent appearance of the work's title, preceding the
      beginning of the body of the text.
    </p></div><div class="SECT1"><hr><h2 class="SECT1"><a name="FDL-SECTION2">C.3. 2. VERBATIM COPYING</a></h2><p>      You may copy and distribute the <a href="#FDL-DOCUMENT">Document</a> in any medium, either
      commercially or noncommercially, provided that this License, the
      copyright notices, and the license notice saying this License
      applies to the Document are reproduced in all copies, and that
      you add no other conditions whatsoever to those of this
      License. You may not use technical measures to obstruct or
      control the reading or further copying of the copies you make or
      distribute. However, you may accept compensation in exchange for
      copies. If you distribute a large enough number of copies you
      must also follow the conditions in <a href="#FDL-SECTION3">section 3</a>.
    </p><p>      You may also lend copies, under the same conditions stated
      above, and you may publicly display copies.
    </p></div><div class="SECT1"><hr><h2 class="SECT1"><a name="FDL-SECTION3">C.4. 3. COPYING IN QUANTITY</a></h2><p>      If you publish printed copies of the <a href="#FDL-DOCUMENT">Document</a> numbering more than 100,
      and the Document's license notice requires <a href="#FDL-COVER-TEXTS">Cover Texts</a>, you must enclose
      the copies in covers that carry, clearly and legibly, all these
      Cover Texts: Front-Cover Texts on the front cover, and
      Back-Cover Texts on the back cover. Both covers must also
      clearly and legibly identify you as the publisher of these
      copies. The front cover must present the full title with all
      words of the title equally prominent and visible. You may add
      other material on the covers in addition. Copying with changes
      limited to the covers, as long as they preserve the title of the
      <a href="#FDL-DOCUMENT">Document</a> and satisfy these
      conditions, can be treated as verbatim copying in other
      respects.
    </p><p>      If the required texts for either cover are too voluminous to fit
      legibly, you should put the first ones listed (as many as fit
      reasonably) on the actual cover, and continue the rest onto
      adjacent pages.
    </p><p>      If you publish or distribute <a href="#FDL-TRANSPARENT">Opaque</a> copies of the <a href="#FDL-DOCUMENT">Document</a> numbering more than 100,
      you must either include a machine-readable <a href="#FDL-TRANSPARENT">Transparent</a> copy along with
      each Opaque copy, or state in or with each Opaque copy a
      publicly-accessible computer-network location containing a
      complete Transparent copy of the Document, free of added
      material, which the general network-using public has access to
      download anonymously at no charge using public-standard network
      protocols. If you use the latter option, you must take
      reasonably prudent steps, when you begin distribution of Opaque
      copies in quantity, to ensure that this Transparent copy will
      remain thus accessible at the stated location until at least one
      year after the last time you distribute an Opaque copy (directly
      or through your agents or retailers) of that edition to the
      public.
    </p><p>      It is requested, but not required, that you contact the authors
      of the <a href="#FDL-DOCUMENT">Document</a> well before
      redistributing any large number of copies, to give them a chance
      to provide you with an updated version of the Document.
    </p></div><div class="SECT1"><hr><h2 class="SECT1"><a name="FDL-SECTION4">C.5. 4. MODIFICATIONS</a></h2><p>      You may copy and distribute a <a href="#FDL-MODIFIED">Modified Version</a> of the <a href="#FDL-DOCUMENT">Document</a> under the conditions of
      sections <a href="#FDL-SECTION2">2</a> and <a href="#FDL-SECTION3">3</a> above, provided that you release
      the Modified Version under precisely this License, with the
      Modified Version filling the role of the Document, thus
      licensing distribution and modification of the Modified Version
      to whoever possesses a copy of it. In addition, you must do
      these things in the Modified Version:
    </p><p></p><ul><li style="list-style-type: opencircle"><div class="FORMALPARA"><p><b>A. </b>            Use in the <a href="#FDL-TITLE-PAGE">Title
            Page</a> (and on the covers, if any) a title distinct
            from that of the <a href="#FDL-DOCUMENT">Document</a>, and from those of
            previous versions (which should, if there were any, be
            listed in the History section of the Document). You may
            use the same title as a previous version if the original
            publisher of that version gives permission.
          </p></div></li><li style="list-style-type: opencircle"><div class="FORMALPARA"><p><b>B. </b>            List on the <a href="#FDL-TITLE-PAGE">Title
            Page</a>, as authors, one or more persons or entities
            responsible for authorship of the modifications in the
            <a href="#FDL-MODIFIED">Modified Version</a>,
            together with at least five of the principal authors of
            the <a href="#FDL-DOCUMENT">Document</a> (all of
            its principal authors, if it has less than five).
          </p></div></li><li style="list-style-type: opencircle"><div class="FORMALPARA"><p><b>C. </b>            State on the <a href="#FDL-TITLE-PAGE">Title
            Page</a> the name of the publisher of the <a href="#FDL-MODIFIED">Modified Version</a>, as the
            publisher.
          </p></div></li><li style="list-style-type: opencircle"><div class="FORMALPARA"><p><b>D. </b>            Preserve all the copyright notices of the <a href="#FDL-DOCUMENT">Document</a>.
          </p></div></li><li style="list-style-type: opencircle"><div class="FORMALPARA"><p><b>E. </b>            Add an appropriate copyright notice for your modifications
            adjacent to the other copyright notices.
          </p></div></li><li style="list-style-type: opencircle"><div class="FORMALPARA"><p><b>F. </b>            Include, immediately after the copyright notices, a
            license notice giving the public permission to use the
            <a href="#FDL-MODIFIED">Modified Version</a> under
            the terms of this License, in the form shown in the
            Addendum below.
          </p></div></li><li style="list-style-type: opencircle"><div class="FORMALPARA"><p><b>G. </b>            Preserve in that license notice the full lists of <a href="#FDL-INVARIANT"> Invariant Sections</a> and
            required <a href="#FDL-COVER-TEXTS">Cover
            Texts</a> given in the <a href="#FDL-DOCUMENT">Document's</a> license notice.
          </p></div></li><li style="list-style-type: opencircle"><div class="FORMALPARA"><p><b>H. </b>            Include an unaltered copy of this License.
          </p></div></li><li style="list-style-type: opencircle"><div class="FORMALPARA"><p><b>I. </b>            Preserve the section entitled <span class="QUOTE">"History"</span>, and
            its title, and add to it an item stating at least the
            title, year, new authors, and publisher of the <a href="#FDL-MODIFIED">Modified Version </a>as given on
            the <a href="#FDL-TITLE-PAGE">Title Page</a>.  If
            there is no section entitled <span class="QUOTE">"History"</span> in the
            <a href="#FDL-DOCUMENT">Document</a>, create one
            stating the title, year, authors, and publisher of the
            Document as given on its Title Page, then add an item
            describing the Modified Version as stated in the previous
            sentence.
          </p></div></li><li style="list-style-type: opencircle"><div class="FORMALPARA"><p><b>J. </b>            Preserve the network location, if any, given in the <a href="#FDL-DOCUMENT">Document</a> for public access
            to a <a href="#FDL-TRANSPARENT">Transparent</a>
            copy of the Document, and likewise the network locations
            given in the Document for previous versions it was based
            on. These may be placed in the <span class="QUOTE">"History"</span>
            section.  You may omit a network location for a work that
            was published at least four years before the Document
            itself, or if the original publisher of the version it
            refers to gives permission.
          </p></div></li><li style="list-style-type: opencircle"><div class="FORMALPARA"><p><b>K. </b>            In any section entitled <span class="QUOTE">"Acknowledgements"</span> or
            <span class="QUOTE">"Dedications"</span>, preserve the section's title,
            and preserve in the section all the substance and tone of
            each of the contributor acknowledgements and/or
            dedications given therein.
          </p></div></li><li style="list-style-type: opencircle"><div class="FORMALPARA"><p><b>L. </b>            Preserve all the <a href="#FDL-INVARIANT">Invariant
            Sections</a> of the <a href="#FDL-DOCUMENT">Document</a>, unaltered in their
            text and in their titles.  Section numbers or the
            equivalent are not considered part of the section titles.
          </p></div></li><li style="list-style-type: opencircle"><div class="FORMALPARA"><p><b>M. </b>            Delete any section entitled
            <span class="QUOTE">"Endorsements"</span>. Such a section may not be
            included in the <a href="#FDL-MODIFIED">Modified
            Version</a>.
          </p></div></li><li style="list-style-type: opencircle"><div class="FORMALPARA"><p><b>N. </b>            Do not retitle any existing section as
            <span class="QUOTE">"Endorsements"</span> or to conflict in title with
            any <a href="#FDL-INVARIANT">Invariant
            Section</a>.
          </p></div></li></ul><p>      If the <a href="#FDL-MODIFIED">Modified Version</a>
      includes new front-matter sections or appendices that qualify as
      <a href="#FDL-SECONDARY">Secondary Sections</a> and
      contain no material copied from the Document, you may at your
      option designate some or all of these sections as invariant. To
      do this, add their titles to the list of <a href="#FDL-INVARIANT">Invariant Sections</a> in the
      Modified Version's license notice.  These titles must be
      distinct from any other section titles.
    </p><p>      You may add a section entitled <span class="QUOTE">"Endorsements"</span>,
      provided it contains nothing but endorsements of your <a href="#FDL-MODIFIED">Modified Version</a> by various
      parties--for example, statements of peer review or that the text
      has been approved by an organization as the authoritative
      definition of a standard.
    </p><p>      You may add a passage of up to five words as a <a href="#FDL-COVER-TEXTS">Front-Cover Text</a>, and a passage
      of up to 25 words as a <a href="#FDL-COVER-TEXTS">Back-Cover Text</a>, to the end of
      the list of <a href="#FDL-COVER-TEXTS">Cover Texts</a>
      in the <a href="#FDL-MODIFIED">Modified Version</a>.
      Only one passage of Front-Cover Text and one of Back-Cover Text
      may be added by (or through arrangements made by) any one
      entity. If the <a href="#FDL-DOCUMENT">Document</a>
      already includes a cover text for the same cover, previously
      added by you or by arrangement made by the same entity you are
      acting on behalf of, you may not add another; but you may
      replace the old one, on explicit permission from the previous
      publisher that added the old one.
    </p><p>      The author(s) and publisher(s) of the <a href="#FDL-DOCUMENT">Document</a> do not by this License
      give permission to use their names for publicity for or to
      assert or imply endorsement of any <a href="#FDL-MODIFIED">Modified Version </a>.
    </p></div><div class="SECT1"><hr><h2 class="SECT1"><a name="FDL-SECTION5">C.6. 5. COMBINING DOCUMENTS</a></h2><p>      You may combine the <a href="#FDL-DOCUMENT">Document</a>
      with other documents released under this License, under the
      terms defined in <a href="#FDL-SECTION4">section 4</a>
      above for modified versions, provided that you include in the
      combination all of the <a href="#FDL-INVARIANT">Invariant
      Sections</a> of all of the original documents, unmodified,
      and list them all as Invariant Sections of your combined work in
      its license notice.
    </p><p>      The combined work need only contain one copy of this License,
      and multiple identical <a href="#FDL-INVARIANT">Invariant
      Sections</a> may be replaced with a single copy. If there are
      multiple Invariant Sections with the same name but different
      contents, make the title of each such section unique by adding
      at the end of it, in parentheses, the name of the original
      author or publisher of that section if known, or else a unique
      number. Make the same adjustment to the section titles in the
      list of Invariant Sections in the license notice of the combined
      work.
    </p><p>      In the combination, you must combine any sections entitled
      <span class="QUOTE">"History"</span> in the various original documents,
      forming one section entitled <span class="QUOTE">"History"</span>; likewise
      combine any sections entitled <span class="QUOTE">"Acknowledgements"</span>,
      and any sections entitled <span class="QUOTE">"Dedications"</span>.  You must
      delete all sections entitled <span class="QUOTE">"Endorsements."</span>
    </p></div><div class="SECT1"><hr><h2 class="SECT1"><a name="FDL-SECTION6">C.7. 6. COLLECTIONS OF DOCUMENTS</a></h2><p>      You may make a collection consisting of the <a href="#FDL-DOCUMENT">Document</a> and other documents
      released under this License, and replace the individual copies
      of this License in the various documents with a single copy that
      is included in the collection, provided that you follow the
      rules of this License for verbatim copying of each of the
      documents in all other respects.
    </p><p>      You may extract a single document from such a collection, and
      dispbibute it individually under this License, provided you
      insert a copy of this License into the extracted document, and
      follow this License in all other respects regarding verbatim
      copying of that document.
    </p></div><div class="SECT1"><hr><h2 class="SECT1"><a name="FDL-SECTION7">C.8. 7. AGGREGATION WITH INDEPENDENT WORKS</a></h2><p>      A compilation of the <a href="#FDL-DOCUMENT">Document</a> or its derivatives with
      other separate and independent documents or works, in or on a
      volume of a storage or distribution medium, does not as a whole
      count as a <a href="#FDL-MODIFIED">Modified Version</a>
      of the Document, provided no compilation copyright is claimed
      for the compilation.  Such a compilation is called an
      <span class="QUOTE">"aggregate"</span>, and this License does not apply to the
      other self-contained works thus compiled with the Document , on
      account of their being thus compiled, if they are not themselves
      derivative works of the Document.  If the <a href="#FDL-COVER-TEXTS">Cover Text</a> requirement of <a href="#FDL-SECTION3">section 3</a> is applicable to these
      copies of the Document, then if the Document is less than one
      quarter of the entire aggregate, the Document's Cover Texts may
      be placed on covers that surround only the Document within the
      aggregate. Otherwise they must appear on covers around the whole
      aggregate.
    </p></div><div class="SECT1"><hr><h2 class="SECT1"><a name="FDL-SECTION8">C.9. 8. TRANSLATION</a></h2><p>      Translation is considered a kind of modification, so you may
      distribute translations of the <a href="#FDL-DOCUMENT">Document</a> under the terms of <a href="#FDL-SECTION4">section 4</a>. Replacing <a href="#FDL-INVARIANT"> Invariant Sections</a> with
      translations requires special permission from their copyright
      holders, but you may include translations of some or all
      Invariant Sections in addition to the original versions of these
      Invariant Sections. You may include a translation of this
      License provided that you also include the original English
      version of this License. In case of a disagreement between the
      translation and the original English version of this License,
      the original English version will prevail.
    </p></div><div class="SECT1"><hr><h2 class="SECT1"><a name="FDL-SECTION9">C.10. 9. TERMINATION</a></h2><p>      You may not copy, modify, sublicense, or distribute the <a href="#FDL-DOCUMENT">Document</a> except as expressly
      provided for under this License. Any other attempt to copy,
      modify, sublicense or distribute the Document is void, and will
      automatically terminate your rights under this License. However,
      parties who have received copies, or rights, from you under this
      License will not have their licenses terminated so long as such
      parties remain in full compliance.
    </p></div><div class="SECT1"><hr><h2 class="SECT1"><a name="FDL-SECTION10">C.11. 10. FUTURE REVISIONS OF THIS LICENSE</a></h2><p>      The <a href="http://www.gnu.org/fsf/fsf.html" target="_top">Free Software
      Foundation</a> may publish new, revised versions of the GNU
      Free Documentation License from time to time. Such new versions
      will be similar in spirit to the present version, but may differ
      in detail to address new problems or concerns. See <a href="http://www.gnu.org/copyleft" target="_top">http://www.gnu.org/copyleft/</a>.
    </p><p>      Each version of the License is given a distinguishing version
      number. If the <a href="#FDL-DOCUMENT">Document</a>
      specifies that a particular numbered version of this License
      <span class="QUOTE">"or any later version"</span> applies to it, you have the
      option of following the terms and conditions either of that
      specified version or of any later version that has been
      published (not as a draft) by the Free Software Foundation. If
      the Document does not specify a version number of this License,
      you may choose any version ever published (not as a draft) by
      the Free Software Foundation.
    </p></div><div class="SECT1"><hr><h2 class="SECT1"><a name="FDL-USING">C.12. Addendum</a></h2><p>      To use this License in a document you have written, include a copy of
      the License in the document and put the following copyright and
      license notices just after the title page:
    </p><a name="AEN16944"></a><blockquote class="BLOCKQUOTE"><p>        Copyright &#169; YEAR YOUR NAME.
      </p><p>        Permission is granted to copy, distribute and/or modify this
        document under the terms of the GNU Free Documentation
        License, Version 1.1 or any later version published by the
        Free Software Foundation; with the <a href="#FDL-INVARIANT">Invariant Sections</a> being LIST
        THEIR TITLES, with the <a href="#FDL-COVER-TEXTS">Front-Cover Texts</a> being LIST,
        and with the <a href="#FDL-COVER-TEXTS">Back-Cover
        Texts</a> being LIST.  A copy of the license is included in
        the section entitled <span class="QUOTE">"GNU Free Documentation
        License"</span>.
      </p></blockquote><p>      If you have no <a href="#FDL-INVARIANT">Invariant
      Sections</a>, write <span class="QUOTE">"with no Invariant Sections"</span>
      instead of saying which ones are invariant.  If you have no
      <a href="#FDL-COVER-TEXTS">Front-Cover Texts</a>, write
      <span class="QUOTE">"no Front-Cover Texts"</span> instead of
      <span class="QUOTE">"Front-Cover Texts being LIST"</span>; likewise for <a href="#FDL-COVER-TEXTS">Back-Cover Texts</a>.
    </p><p>      If your document contains nontrivial examples of program code,
      we recommend releasing these examples in parallel under your
      choice of free software license, such as the <a href="http://www.gnu.org/copyleft/gpl.html" target="_top"> GNU General Public
      License</a>, to permit their use in free software.
    </p></div></div><div class="INDEX"><hr><h1><a name="AEN16960"></a>List of Types</h1><dl><dt><a href="#V4L2-STD-ID">v4l2_std_id</a></dt><dt>enum&nbsp;<a href="#V4L2-BUF-TYPE">v4l2_buf_type</a></dt><dt>enum&nbsp;<a href="#V4L2-COLORSPACE">v4l2_colorspace</a></dt><dt>enum&nbsp;<a href="#V4L2-CTRL-TYPE">v4l2_ctrl_type</a></dt><dt>enum&nbsp;<a href="#V4L2-FIELD">v4l2_field</a></dt><dt>enum&nbsp;<a href="#V4L2-FRMIVALTYPES">v4l2_frmivaltypes</a></dt><dt>enum&nbsp;<a href="#V4L2-FRMSIZETYPES">v4l2_frmsizetypes</a></dt><dt>enum&nbsp;<a href="#V4L2-MEMORY">v4l2_memory</a></dt><dt>enum&nbsp;<a href="#V4L2-PRIORITY">v4l2_priority</a></dt><dt>enum&nbsp;<a href="#V4L2-TUNER-TYPE">v4l2_tuner_type</a></dt><dt>struct&nbsp;<a href="#V4L2-AUDIO">v4l2_audio</a></dt><dt>struct&nbsp;<a href="#V4L2-AUDIOOUT">v4l2_audioout</a></dt><dt>struct&nbsp;<a href="#V4L2-BUFFER">v4l2_buffer</a></dt><dt>struct&nbsp;<a href="#V4L2-CAPABILITY">v4l2_capability</a></dt><dt>struct&nbsp;<a href="#V4L2-CAPTUREPARM">v4l2_captureparm</a></dt><dt>struct&nbsp;<a href="#V4L2-CHIP-IDENT">v4l2_chip_ident</a></dt><dt>struct&nbsp;<a href="#V4L2-CLIP">v4l2_clip</a></dt><dt>struct&nbsp;<a href="#V4L2-CONTROL">v4l2_control</a></dt><dt>struct&nbsp;<a href="#V4L2-CROP">v4l2_crop</a></dt><dt>struct&nbsp;<a href="#V4L2-CROPCAP">v4l2_cropcap</a></dt><dt>struct&nbsp;<a href="#V4L2-ENC-IDX">v4l2_enc_idx</a></dt><dt>struct&nbsp;<a href="#V4L2-ENC-IDX-ENTRY">v4l2_enc_idx_entry</a></dt><dt>struct&nbsp;<a href="#V4L2-ENCODER-CMD">v4l2_encoder_cmd</a></dt><dt>struct&nbsp;<a href="#V4L2-EXT-CONTROL">v4l2_ext_control</a></dt><dt>struct&nbsp;<a href="#V4L2-EXT-CONTROLS">v4l2_ext_controls</a></dt><dt>struct&nbsp;<a href="#V4L2-FMTDESC">v4l2_fmtdesc</a></dt><dt>struct&nbsp;<a href="#V4L2-FORMAT">v4l2_format</a></dt><dt>struct&nbsp;<a href="#V4L2-FRACT">v4l2_fract</a></dt><dt>struct&nbsp;<a href="#V4L2-FRAMEBUFFER">v4l2_framebuffer</a></dt><dt>struct&nbsp;<a href="#V4L2-FREQUENCY">v4l2_frequency</a></dt><dt>struct&nbsp;<a href="#V4L2-FRMIVAL-STEPWISE">v4l2_frmival_stepwise</a></dt><dt>struct&nbsp;<a href="#V4L2-FRMIVALENUM">v4l2_frmivalenum</a></dt><dt>struct&nbsp;<a href="#V4L2-FRMSIZE-DISCRETE">v4l2_frmsize_discrete</a></dt><dt>struct&nbsp;<a href="#V4L2-FRMSIZE-STEPWISE">v4l2_frmsize_stepwise</a></dt><dt>struct&nbsp;<a href="#V4L2-FRMSIZEENUM">v4l2_frmsizeenum</a></dt><dt>struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a></dt><dt>struct&nbsp;<a href="#V4L2-JPEGCOMPRESSION">v4l2_jpegcompression</a></dt><dt>struct&nbsp;<a href="#V4L2-MODULATOR">v4l2_modulator</a></dt><dt>struct&nbsp;<a href="#V4L2-OUTPUT">v4l2_output</a></dt><dt>struct&nbsp;<a href="#V4L2-OUTPUTPARM">v4l2_outputparm</a></dt><dt>struct&nbsp;<a href="#V4L2-PIX-FORMAT">v4l2_pix_format</a></dt><dt>struct&nbsp;<a href="#V4L2-QUERYCTRL">v4l2_queryctrl</a></dt><dt>struct&nbsp;<a href="#V4L2-QUERYMENU">v4l2_querymenu</a></dt><dt>struct&nbsp;<a href="#V4L2-RECT">v4l2_rect</a></dt><dt>struct&nbsp;<a href="#V4L2-REGISTER">v4l2_register</a></dt><dt>struct&nbsp;<a href="#V4L2-REQUESTBUFFERS">v4l2_requestbuffers</a></dt><dt>struct&nbsp;<a href="#V4L2-SLICED-VBI-CAP">v4l2_sliced_vbi_cap</a></dt><dt>struct&nbsp;<a href="#V4L2-SLICED-VBI-DATA">v4l2_sliced_vbi_data</a></dt><dt>struct&nbsp;<a href="#V4L2-SLICED-VBI-FORMAT">v4l2_sliced_vbi_format</a></dt><dt>struct&nbsp;<a href="#V4L2-STANDARD">v4l2_standard</a></dt><dt>struct&nbsp;<a href="#V4L2-STREAMPARM">v4l2_streamparm</a></dt><dt>struct&nbsp;<a href="#V4L2-TIMECODE">v4l2_timecode</a></dt><dt>struct&nbsp;<a href="#V4L2-TUNER">v4l2_tuner</a></dt><dt>struct&nbsp;<a href="#V4L2-VBI-FORMAT">v4l2_vbi_format</a></dt><dt>struct&nbsp;<a href="#V4L2-WINDOW">v4l2_window</a></dt></dl></div><a name="AEN17127"></a><hr><h1><a name="AEN17127"></a>References</h1><div class="BIBLIOENTRY"><a name="EIA608"></a><p>[EIA&nbsp;608-B]&nbsp;Electronic Industries Alliance (<a href="http://www.eia.org/" target="_top">http://www.eia.org</a>), <i>EIA 608-B "Recommended Practice for Line 21 Data
Service"</i>.</p><div class="BIBLIOENTRYBLOCK" style="margin-left: 0.5in"></div></div><div class="BIBLIOENTRY"><a name="EN300294"></a><p>[EN&nbsp;300&nbsp;294]&nbsp;European Telecommunication Standards Institute
(<a href="http://www.etsi.org/" target="_top">http://www.etsi.org</a>), <i>EN 300 294 "625-line television Wide Screen Signalling
(WSS)"</i>.</p><div class="BIBLIOENTRYBLOCK" style="margin-left: 0.5in"></div></div><div class="BIBLIOENTRY"><a name="ETS300231"></a><p>[ETS&nbsp;300&nbsp;231]&nbsp;European Telecommunication Standards Institute
(<a href="http://www.etsi.org/" target="_top">http://www.etsi.org</a>), <i>ETS 300 231 "Specification of the domestic video
Programme Delivery Control system (PDC)"</i>.</p><div class="BIBLIOENTRYBLOCK" style="margin-left: 0.5in"></div></div><div class="BIBLIOENTRY"><a name="ETS300706"></a><p>[ETS&nbsp;300&nbsp;706]&nbsp;European Telecommunication Standards Institute
(<a href="http://www.etsi.org/" target="_top">http://www.etsi.org</a>), <i>ETS 300 706 "Enhanced Teletext specification"</i>.</p><div class="BIBLIOENTRYBLOCK" style="margin-left: 0.5in"></div></div><div class="BIBLIOENTRY"><a name="MPEG2PART1"></a><p>[ISO&nbsp;13818-1]&nbsp;International Telecommunication Union (<a href="http://www.itu.ch/" target="_top">http://www.itu.ch</a>), International
Organisation for Standardisation (<a href="http://www.iso.ch/" target="_top">http://www.iso.ch</a>), <i>ITU-T Rec. H.222.0 | ISO/IEC 13818-1 "Information
technology ¡ª Generic coding of moving pictures and associated
audio information: Systems"</i>.</p><div class="BIBLIOENTRYBLOCK" style="margin-left: 0.5in"></div></div><div class="BIBLIOENTRY"><a name="MPEG2PART2"></a><p>[ISO&nbsp;13818-2]&nbsp;International Telecommunication Union (<a href="http://www.itu.ch/" target="_top">http://www.itu.ch</a>), International
Organisation for Standardisation (<a href="http://www.iso.ch/" target="_top">http://www.iso.ch</a>), <i>ITU-T Rec. H.262 | ISO/IEC 13818-2 "Information
technology ¡ª Generic coding of moving pictures and associated
audio information: Video"</i>.</p><div class="BIBLIOENTRYBLOCK" style="margin-left: 0.5in"></div></div><div class="BIBLIOENTRY"><a name="ITU470"></a><p>[ITU&nbsp;BT.470]&nbsp;International Telecommunication Union (<a href="http://www.itu.ch/" target="_top">http://www.itu.ch</a>), <i>ITU-R Recommendation BT.470-6 "Conventional Television
Systems"</i>.</p><div class="BIBLIOENTRYBLOCK" style="margin-left: 0.5in"></div></div><div class="BIBLIOENTRY"><a name="ITU601"></a><p>[ITU&nbsp;BT.601]&nbsp;International Telecommunication Union (<a href="http://www.itu.ch/" target="_top">http://www.itu.ch</a>), <i>ITU-R Recommendation BT.601-5 "Studio Encoding Parameters
of Digital Television for Standard 4:3 and Wide-Screen 16:9 Aspect
Ratios"</i>.</p><div class="BIBLIOENTRYBLOCK" style="margin-left: 0.5in"></div></div><div class="BIBLIOENTRY"><a name="ITU653"></a><p>[ITU&nbsp;BT.653]&nbsp;International Telecommunication Union (<a href="http://www.itu.ch/" target="_top">http://www.itu.ch</a>), <i>ITU-R Recommendation BT.653-3 "Teletext systems"</i>.</p><div class="BIBLIOENTRYBLOCK" style="margin-left: 0.5in"></div></div><div class="BIBLIOENTRY"><a name="ITU709"></a><p>[ITU&nbsp;BT.709]&nbsp;International Telecommunication Union (<a href="http://www.itu.ch/" target="_top">http://www.itu.ch</a>), <i>ITU-R Recommendation BT.709-5 "Parameter values for the
HDTV standards for production and international programme
exchange"</i>.</p><div class="BIBLIOENTRYBLOCK" style="margin-left: 0.5in"></div></div><div class="BIBLIOENTRY"><a name="ITU1119"></a><p>[ITU&nbsp;BT.1119]&nbsp;International Telecommunication Union (<a href="http://www.itu.ch/" target="_top">http://www.itu.ch</a>), <i>ITU-R Recommendation BT.1119 "625-line
television Wide Screen Signalling (WSS)"</i>.</p><div class="BIBLIOENTRYBLOCK" style="margin-left: 0.5in"></div></div><div class="BIBLIOENTRY"><a name="JFIF"></a><p>[JFIF]&nbsp;Independent JPEG Group (<a href="http://www.ijg.org/" target="_top">http://www.ijg.org</a>), <i>JPEG File Interchange Format</i><i>: </i><i>Version 1.02</i>.</p><div class="BIBLIOENTRYBLOCK" style="margin-left: 0.5in"></div></div><div class="BIBLIOENTRY"><a name="SMPTE12M"></a><p>[SMPTE&nbsp;12M]&nbsp;Society of Motion Picture and Television Engineers
(<a href="http://www.smpte.org/" target="_top">http://www.smpte.org</a>), <i>SMPTE 12M-1999 "Television, Audio and Film - Time and
Control Code"</i>.</p><div class="BIBLIOENTRYBLOCK" style="margin-left: 0.5in"></div></div><div class="BIBLIOENTRY"><a name="SMPTE170M"></a><p>[SMPTE&nbsp;170M]&nbsp;Society of Motion Picture and Television Engineers
(<a href="http://www.smpte.org/" target="_top">http://www.smpte.org</a>), <i>SMPTE 170M-1999 "Television - Composite Analog Video
Signal - NTSC for Studio Applications"</i>.</p><div class="BIBLIOENTRYBLOCK" style="margin-left: 0.5in"></div></div><div class="BIBLIOENTRY"><a name="SMPTE240M"></a><p>[SMPTE&nbsp;240M]&nbsp;Society of Motion Picture and Television Engineers
(<a href="http://www.smpte.org/" target="_top">http://www.smpte.org</a>), <i>SMPTE 240M-1999 "Television - Signal Parameters -
1125-Line High-Definition Production"</i>.</p><div class="BIBLIOENTRYBLOCK" style="margin-left: 0.5in"></div></div><div class="BIBLIOENTRY"><a name="V4L"></a><p>[V4L]&nbsp;<span class="AUTHOR">Alan Cox</span>, <i>Video4Linux API Specification</i>.</p><div class="BIBLIOENTRYBLOCK" style="margin-left: 0.5in"><div class="ABSTRACT"><p>This file is part of the Linux kernel sources under
<tt class="FILENAME">Documentation/video4linux</tt>.</p></div></div></div><div class="BIBLIOENTRY"><a name="V4LPROG"></a><p>[V4LPROG]&nbsp;<span class="AUTHOR">Alan Cox</span>, <i>Video4Linux Programming (a.k.a. The Video4Linux
Book)</i>, 2000.</p><div class="BIBLIOENTRYBLOCK" style="margin-left: 0.5in"><div class="ABSTRACT"><p>About V4L <span class="emphasis"><i class="EMPHASIS">driver</i></span> programming. This
book is part of the Linux kernel DocBook documentation, for example at
<a href="http://kernelnewbies.org/documents/" target="_top">http://kernelnewbies.org/documents/</a>. SGML sources are included
in the kernel sources.</p></div></div></div></div><h3 class="FOOTNOTES">Notes</h3><table class="FOOTNOTES" border="0" width="100%"><tbody><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN198" href="#AEN198"><span class="footnote">[1]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>Access permissions are associated with character
device special files, hence we must ensure device numbers cannot
change with the module load order. To this end minor numbers are no
longer automatically assigned by the "videodev" module as in V4L but
requested by the driver. The defaults will suffice for most people
unless two drivers compete for the same minor numbers.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN201" href="#AEN201"><span class="footnote">[2]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>In earlier versions of the V4L2 API the module options
where named after the device special file with a "unit_" prefix, expressing
the minor number itself, not an offset. Rationale for this change is unknown.
Lastly the naming and semantics are just a convention among driver writers,
the point to note is that minor numbers are not supposed to be hardcoded
into drivers.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN229" href="#AEN229"><span class="footnote">[3]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>Given a device file name one cannot reliable find
related devices. For once names are arbitrary and in a system with
multiple devices, where only some support VBI capturing, a
<tt class="FILENAME">/dev/video2</tt> is not necessarily related to
<tt class="FILENAME">/dev/vbi2</tt>. The V4L
<code class="CONSTANT">VIDIOCGUNIT</code> ioctl would require a search for a
device file with a particular major and minor number.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN266" href="#AEN266"><span class="footnote">[4]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>Drivers could recognize the
<code class="CONSTANT">O_EXCL</code> open flag. Presently this is not required,
so applications cannot know if it really works.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN345" href="#AEN345"><span class="footnote">[5]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>Actually struct&nbsp;<a href="#V4L2-AUDIO">v4l2_audio</a> ought to have a
<code class="STRUCTFIELD">tuner</code> field like struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a>, not only
making the API more consistent but also permitting radio devices with
multiple tuners.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN463" href="#AEN463"><span class="footnote">[6]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>Some users are already confused by technical terms PAL,
NTSC and SECAM. There is no point asking them to distinguish between
B, G, D, or K when the software or hardware can do that
automatically.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN475" href="#AEN475"><span class="footnote">[7]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>An alternative to the current scheme is to use pointers
to indices as arguments of <code class="CONSTANT">VIDIOC_G_STD</code> and
<code class="CONSTANT">VIDIOC_S_STD</code>, the struct&nbsp;<a href="#V4L2-INPUT">v4l2_input</a> and
struct&nbsp;<a href="#V4L2-OUTPUT">v4l2_output</a> <code class="STRUCTFIELD">std</code> field would be a set of
indices like <code class="STRUCTFIELD">audioset</code>.</p><p>Indices are consistent with the rest of the API
and identify the standard unambiguously. In the present scheme of
things an enumerated standard is looked up by <a href="#V4L2-STD-ID">v4l2_std_id</a>. Now the
standards supported by the inputs of a device can overlap. Just
assume the tuner and composite input in the example above both
exist on a device. An enumeration of "PAL-B/G", "PAL-H/I" suggests
a choice which does not exist. We cannot merge or omit sets, because
applications would be unable to find the standards reported by
<code class="CONSTANT">VIDIOC_G_STD</code>. That leaves separate enumerations
for each input. Also selecting a standard by <a href="#V4L2-STD-ID">v4l2_std_id</a> can be
ambiguous. Advantage of this method is that applications need not
identify the standard indirectly, after enumerating.</p><p>So in
summary, the lookup itself is unavoidable. The difference is only
whether the lookup is necessary to find an enumerated standard or to
switch to a standard by <a href="#V4L2-STD-ID">v4l2_std_id</a>.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN507" href="#AEN507"><span class="footnote">[8]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>See <a href="#BUFFER">Section 3.5</a> for a rationale. Probably
even USB cameras follow some well known video standard. It might have
been better to explicitly indicate elsewhere if a device cannot live
up to normal expectations, instead of this exception.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN552" href="#AEN552"><span class="footnote">[9]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>It will be more convenient for applications if drivers
make use of the <code class="CONSTANT">V4L2_CTRL_FLAG_DISABLED</code> flag, but
that was never required.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN555" href="#AEN555"><span class="footnote">[10]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>Applications could call an ioctl to request events.
After another process called <a href="#VIDIOC-G-CTRL"><code class="CONSTANT">VIDIOC_S_CTRL</code></a> or another ioctl changing
shared properties the <a href="#FUNC-SELECT"><code class="FUNCTION">select()</code></a> function would indicate
readability until any ioctl (querying the properties) is
called.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN1897" href="#AEN1897"><span class="footnote">[11]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>Enumerating formats an application has no a-priori
knowledge of (otherwise it could explicitely ask for them and need not
enumerate) seems useless, but there are applications serving as proxy
between drivers and the actual video applications for which this is
useful.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN5780" href="#AEN5780"><span class="footnote">[12]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>It would be desirable if applications could depend on
drivers supporting all I/O interfaces, but as much as the complex
memory mapping I/O can be inadequate for some devices we have no
reason to require this interface, which is most useful for simple
applications capturing still images.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN5786" href="#AEN5786"><span class="footnote">[13]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>At the driver level <code class="FUNCTION">select()</code> and
<code class="FUNCTION">poll()</code> are the same, and
<code class="FUNCTION">select()</code> is too important to be optional.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN5803" href="#AEN5803"><span class="footnote">[14]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>One could use one file descriptor and set the buffer
type field accordingly when calling <a href="#VIDIOC-QBUF"><code class="CONSTANT">VIDIOC_QBUF</code></a> etc., but it makes
the <code class="FUNCTION">select()</code> function ambiguous. We also like the
clean approach of one file descriptor per logical stream. Video
overlay for example is also a logical stream, although the CPU is not
needed for continuous operation.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN5836" href="#AEN5836"><span class="footnote">[15]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>Random enqueue order permits applications processing
images out of order (such as video codecs) to return buffers earlier,
reducing the probability of data loss. Random fill order allows
drivers to reuse buffers on a LIFO-basis, taking advantage of caches
holding scatter-gather lists and the like.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN5878" href="#AEN5878"><span class="footnote">[16]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>At the driver level <code class="FUNCTION">select()</code> and
<code class="FUNCTION">poll()</code> are the same, and
<code class="FUNCTION">select()</code> is too important to be optional. The
rest should be evident.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN5909" href="#AEN5909"><span class="footnote">[17]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>We expect that frequently used buffers are typically not
swapped out. Anyway, the process of swapping, locking or generating
scatter-gather lists may be time consuming. The delay can be masked by
the depth of the incoming buffer queue, and perhaps by maintaining
caches assuming a buffer will be soon enqueued again. On the other
hand, to optimize memory usage drivers can limit the number of buffers
locked in advance and recycle the most recently used buffers first. Of
course, the pages of empty buffers in the incoming queue need not be
saved to disk. Output buffers must be saved on the incoming and
outgoing queue because an application may share them with other
processes.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN5945" href="#AEN5945"><span class="footnote">[18]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>At the driver level <code class="FUNCTION">select()</code> and
<code class="FUNCTION">poll()</code> are the same, and
<code class="FUNCTION">select()</code> is too important to be optional. The
rest should be evident.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN5967" href="#AEN5967"><span class="footnote">[19]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>Since no other Linux multimedia
API supports unadjusted time it would be foolish to introduce here. We
must use a universally supported clock to synchronize different media,
hence time of day.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN6581" href="#AEN6581"><span class="footnote">[20]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>A common application of two file descriptors is the
XFree86 <a href="#XVIDEO">Xv/V4L</a> interface driver and
a V4L2 application. While the X server controls video overlay, the
application can take advantage of memory mapping and DMA.</p><p>In the opinion of the designers of this API, no driver
writer taking the efforts to support simultaneous capturing and
overlay will restrict this ability by requiring a single file
descriptor, as in V4L and earlier versions of V4L2. Making this
optional means applications depending on two file descriptors need
backup routines to be compatible with all drivers, which is
considerable more work than using two fds in applications which do
not. Also two fd's fit the general concept of one file descriptor for
each logical stream. Hence as a complexity trade-off drivers
<span class="emphasis"><i class="EMPHASIS">must</i></span> support two file descriptors and
<span class="emphasis"><i class="EMPHASIS">may</i></span> support single fd operation.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN6776" href="#AEN6776"><span class="footnote">[21]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>The X Window system defines "regions" which are
vectors of struct BoxRec { short x1, y1, x2, y2; } with width = x2 -
x1 and height = y2 - y1, so one cannot pass X11 clip lists
directly.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN7016" href="#AEN7016"><span class="footnote">[22]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>ASK: Amplitude-Shift Keying. A high signal
level represents a '1' bit, a low level a '0' bit.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN9334" href="#AEN9334"><span class="footnote">[23]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>The supported standards may overlap and we need an
unambiguous set to find the current standard returned by
<code class="CONSTANT">VIDIOC_G_STD</code>.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN13386" href="#AEN13386"><span class="footnote">[24]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p><code class="CONSTANT">V4L2_CTRL_FLAG_DISABLED</code> was
intended for two purposes: Drivers can skip predefined controls not
supported by the hardware (although returning EINVAL would do as
well), or disable predefined and private controls after hardware
detection without the trouble of reordering control arrays and indices
(EINVAL cannot be used to skip private controls because it would
prematurely end the enumeration).</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN13746" href="#AEN13746"><span class="footnote">[25]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>For example video output requires at least two buffers,
one displayed and one filled by the application.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN14434" href="#AEN14434"><span class="footnote">[26]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>The Linux kernel implements
<code class="FUNCTION">select()</code> like the <a href="#FUNC-POLL"><code class="FUNCTION">poll()</code></a> function, but
<code class="FUNCTION">select()</code> cannot return a
<code class="CONSTANT">POLLERR</code>.</p></td></tr><tr><td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN16435" href="#AEN16435"><span class="footnote">[27]</span></a></td><td align="LEFT" valign="TOP" width="95%"><p>This is not implemented in XFree86.</p></td></tr></tbody></table></body></html>